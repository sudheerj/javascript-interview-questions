---
title: "مجموعه سوال و جواب‌های جاواسکریپتی"
author: Sudheerj - translated by Mariotek team
date: August 30, 2020
export_on_save:
html: true
puppeteer:
     landscape: false
     printBackground: true
     timeout: 3000
     width: "170mm"
     height: "240mm"
     margin: { top: '50px', bottom: '55px', right: '40px', left: '40px'}
     displayHeaderFooter: true
     headerTemplate: '2222'
     footerTemplate: '<div style="width: 297mm;text-align: center;font-size: 10px;font-family: BYekan;direction:rtl;position: relative; bottom: -15px">
     <span style="position: relative; top:50px"><span class="pageNumber"></span></span>
     <img style="width:100px;float:right;display: inline-block" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACcCAMAAAANmRRNAAAAOVBMVEUAAABYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtolEGJAAAAE3RSTlMAWUhRPmYIESkgNnAwGXiAjqC4Jm454QAABztJREFUeNrs2AGOAyEIBVBAEK1Os/c/7dZtO2M2PUA/4d3gB5EApZRSSimllFJKKaWUUorGKYTJTPhcmCfBm8yC/65cLIvxLcJ0hgUpRiN4UTrDIhTDQ3TGgymFUDlEOR4itMefcqMYJEiPkArFcCv0We1Yj67xpwhSmBmrVs60OaauCEVuvRIYdlocOMITt65SVgRtoBHIm4r8DBFtqPP93c9F3bA+p11/RphOi2B9TrthtYaYiJ1pM4EPisx7LOAg9d7p5MBBSI0u0KuVyRakE67jXumtQB8Xi0VZrcYMMEiWNrbVChqXdyTwIHX0V+MjD5JFxysRo64h/6+lfBC2Y9Qgx0axKMfGMQNMxGuYKPj/u3AJMBFfmwn2anWSQeTwg2QxBV+trs3EsVerExv4anUarviD5Leba9tuGgaCe9fVTsL/fyy0cZCJ0AWc4B7mzZAedxxrZzS76gc8/geK+Am+/B+vFsAtwVdBUGRm+oD8QMze+xAW55wZDEFX+CpAXXyOUUToA/wJ3IE/8JNnzBvPjebtyyyStu8zc24JwW885Xc06fbt8193PPMJGnkkUrdPno4vq9t4bkRRDc6AHbsvefbPL6vAKcDlEJHsUrk6tZGF8RAR2mKugsxwAo4+wMgl5oJz066Ix1zK1jM5v23S3uWZhyEWrIcCTxhl7j9AufCQiqF9xlxfYZCrmbJFMtUOldK1Yqw09gRw6wE6NfCqYeIxJP8Fur3tB6gZAKJ2lYbjrmdybrbtERqgO8Wo6EbVWxlOb5I6bFt8uEOUXf/7tLScP3/afoBlfZCyQUGt46LnD6lgnKgDxomsJ0NJTh9SaZuUqFBgpFJRKWHjoo+JNNaT9o0RJz2+Y5X2iHy6ePwBEu9OEpIFp986hxUVDnAfqqObLhupk4iY2rzGLHuxtxDjdWVkycu+jhOcA/SdAlxhYXIAyzbamBPXDfgI54AFWtCaoy3pdr2IbHO+JTUtYhLgHAi3OdLTkCwicgyS0Ko5jiImBufAY/+/tqqKyGXONydctk98neNKvSRF430xFApFZNA917ywGpwJDK1RZfpYDa3MTZTdk9flo6Ie1vECy9z24o1p62zdXZKRsvEvNJM/2prUIRPVtEyYFL8dPXjsrqAHY72EqgF/AJRhHcgQI/gkY5OS9M8Ot12ueX+pfPTkliWGHlIAMFU3SlKc2h/lXsKiApWYHDmChsk6n8D7bdc8SlJYYQev40NjC2os13r8CBqtDkabJKdqA5OS4v5Kl4kaEnYWTOUwEfAXPx6hltXXJqW9YJGmEr6ADyoh2WEiENbYmUvasCTumxTcX0ae3AV4xXBYTCL9XGvY3OsVUApdk5JCa/F3F1jeUrD0ktONiFBD47OAUi9JkQQFmud9QUwftNo/MK/aZcn3S4+huo5JUarirSYwV77lNUQgrmHiEH1epR1FuWTd3VUvtBYl+CvUQ9HhIrBHSL/PdtWassfa9ZRdyTR62ZbCKc/YBkm5rLF2mWOa2Ze9qV2jWr8nNZyiVUlKJSZRh2/DGyMdKp6HO3ei1TfaPYjDjVe59zuTaLmEmd8jJPq9ybUU5jq/7s1EIKQ4JbScwlZ6WmIiPFLEYxg1V2ylKV/tV/nt76o0V4DRv4lIAaoB6cRPYySo4JIr8daoa/Xm3iynuf5RvlygBulUASZ5PxEItxVmYNdkbc/scWy93z0bc7mG2fjCtw+GqRs51nf3zyJCmrqPCCRsnjJG6dqKtxIp/l1xst3DKTTERPBfCQn/nojXytj39DkkeuaXqnjrvULCvnesSwZMSg8Nn1VHaawVuLyZSFGyUDYfg/1RXKWa5S9efXTzeVgOBgWDk8wlAXGrTLV76hCPdBhvsfxNyMuIzBKDjdT1af5IdardU4d4Sep46/gUni4/2y7ITPHRtaDYOAhVwGqTezOnaM9iwnJIEXspgvORCO/ZuUMZN3DiJczaNUr+SUwEXzI83NkjOX9vyFBpjLU+7Fc/K0VhL6Or78db4Q+IjGwosUXh+/cjfrl/Ia4ifaHZJbtXR0m9eKuQnIfD0XqzEOXRAV/B6rcNp5esX6mIST/eQi3FZwqCk+vNQpYb3huxeTEowGSzb3opxG513ffHtladn5V4pPnCkfnO534PkocAxRRGb3od4pEO9dv+5K9taZgnsp8ZWXZ8SvGacBqmao+dCdLcX95i5HF6NYzje2GULZ8CJHrTnIPr7b2rQhxWyAqTsKGs4zj8HWfoZu56i6SILNG7kUAviTcxUYMXQWWaSE6DNoTVBmH/rdbdlGQUX0bEDXLLMee69+DCZhBI16UUuKqbEvFlIa/HcQDbTqIGKu98putDUN0zH0wLoL6KCPN0HUCCMROrt5mfgsqPArf8UogNNcBLoH6WyJKmBufaSVsxCCR+K8TkrxleAaezkfhcyScZiNEmqEke8cS3BK9A5h5L7pi4eTPQ9WC2foM5fAdxoS47LLn9fAAAAABJRU5ErkJggg==" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACcCAMAAAANmRRNAAAAM1BMVEUAAABYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVtYWVsrbnhhAAAAEXRSTlMAWUhRMz5mCBEpIHB6GY6ftSRD8gQAAAclSURBVHja7NhdjsMwCATgARv/tnv/467Qtitb6gE6iO8peQsieEKQUkoppZRSSimllFJK6d9AECIVMVQRDdKWoZHa0rIt3yfUtLQwbZmR2hJnWmakQ6xJkFJgDTEM6QhhCmKoBTGYIgY1MKmr47PClYoqIkU/lSMTXPqqWrwcq08cSAPxKGfADerTt0/zcoraihAjY5rq/lG1yfl6XWobVl4nAfW3iircqH/lLLA687D3tsFK6nXH25Hr0YX4CDvzcD14x/3Kw8b1/XhZRyHKvPQea1V/PMHLFG+NelVUw0vljZB7rdpse8mtzPcFcYQ4eQ342rwR4rp0wG3iCHFPCfLfdApc38wRcuRho/9JZxogQlyxABHiSg0QIU4W9xby1mUAm37SgSEBIsQtwaDeQo4YaQEmHTAb/BHy2821rikOwlByIQECuu//tHuxDq0osFu7dvf8Gj+rk5SSk5wEb3z4z3VHnoPzP13eVtjV/R+4oBtCNYRQUooxMvsfwJ8gIpDT6Kv+upi6WMrVUvoJWIF+AX/Ce8/MsXwq4AVeWfrLqG9XfGaqXyyNKZUQVDsZ5yegAouhi6UhZwq/LNUdQv7fhwe3RaSI++6Muk8AH622wLiz3v8IiB9eg8NdjvCHHIGy/FGFLOKdS/wBNIMB4uv0xj+11xnaAUAoboioboUT9Bu3Y1lqpcqMHUTKvrPER2PMXkC3sqqPKKLIJxshhLQ2wiZMSSLRqYRXS0zuE9g+RhaH04wFhH9eIydLUDaPEckofgYQvl16v+YsA2vru19M+/c0kNzf2qbqJxhYQ7+mkO40o5Jg3SedJT4WY/by1iMCRSOt19LZEpSL0H2+TEqVGR+hXlBdhfDJEhRHIXqEH4jZXg/Fe6HwkKmfLEFxtBhf5Iq3cTmXqHEDwvTzA8V9BLiOmoU9AeULc9I1jZeWK85WVTlu2+lkvAwzFucCUnENJJ3ujEOqFFL10mUO2Pt8uVrR1lpx7lwJinNaKaQpGRXMJyYAeBicRXInS1Dqdm5zjAK2eBS+xppjuF9xsgRlgea0jTs1qapY4jQhs5xOQVkAtM2Ha1LVIPDPnYOEnPRECUqtQioCKQlqtxZTfjGlzdQRa0ZIObldsLj9OiF1PdxrquWAQ5xIUIqJDP2Qne1X2vwLvuTfOw4nNk5QvEUHNKDm7HYKg6br8OXJ/5ZupRJGCkoQUeeSuR7IdM/5tC2FsEAZHxKTuHlFIwWFF8EFOmaqQVV09lJIFEkTu7Jsn0QbJCgqEkbFmAsZ9x60U0t3NyBN6WsITaDoJCgx+/FAd8yxlqv7KCSBxMqH86I3QT9BISvN6jXgnNxuR2xRqnhCKGw3d7JugpIMnRvWlfAVbZB3pfEBjKe5eStome8pKJhT89kWAHvPcFaJZ7L4awQtlE6CEgS0F/DqNn+LIyi+J2p3ayq18Fok85knDvunetVeR7Shu2llUqj57DbotrC0dSynZvz7XRgQO1InCBF/veVn0iGScFAxM74rwg2FNAqKQrMcT59GkSNbRFAmW88AL1o8MWPnPlHN8fBQKQnCXKMumT5Pi9HSzJ1I2R+qfweY3EHmn3bxktFUKsGWjhXyI8wFX5SnXvocp6oGzNppOh3+2xtV0AoWXANkmDBF0KmAcwc6MuZDpGpNi5x5rkdmdGw/eJyAQnydx6pd1M0gX9Oxje1xlhDk9QGyOCsdpEs+eBpnTK4eXp5BBnPeuwmQOeB++nM8jYB/QSHJaLLFA+Icy/GOBJgQtOzRYrTU8HKvNpf43BFyb0OBEce0FFIMasdu4IfvHUGLb3Qk0kjQaqb/feZBRdYm7ZKOdsTTUNASbMS3+tG+H6EqMfNkrIl1//RbK2h5a8S3uRaPyGaaauyIJvZEAGT4Xj709EghChImqyIVehicbMF478QwEsFXa6nIe8f4wD9QSDScTZRS5nFDyEO46fuAyDF0NIsxIPUFrZjX1JZmSSDm+KrAqs09zBek6kF7cYuesX1By/yKA6fDBObma8NtSUr0tzUgz0rYS7rnoYkF+oIWSrUtTocJEG2bydl42QacdPAV8xVXiEsrTbtPXcihBt3Z3aUG61eFby1iuFYPhpEG/O/8opYOOV+wcuDs7krGX8EU12tAPB8yEdwIBDT3K1oI9ypERbST27ThauVBWc+4zDuSZHbyYQxhl1MNuhO1fkjM8k38Lzoo2pPIWjH+MMVLZaEQsjJKCUJkTwCCfL10zsuwzBd1gO5NYFSrHY8WyC0l60CUNp52xMv7JGHgpuNRQ1HJggslp9B0DEbWjdXa8D5HBJbCYw0Nd0K7NJTcsHkLST1HDtG3k4Bugm65hyLynPRJcadjPxzC9I4mcm8BXyIuQTdu6GAB0x+N0lmZdSSKewvs2525vVUPehTgcYqcpsV4Ce4d+Ja1k1N1aXo+SaXQF9x6+A4+TyvoMJMD8AAAAABJRU5ErkJggg==" style="float:left;width: 100px;display: inline-block" />
     </div>'
---

<div dir="rtl" align="right">

# مجموعه سوال و جواب‌های جاواسکریپتی

> اگه از کتاب خوشتون اومد به گیت‌هابمون مراجعه کنین و بهمون :star: بدین. اگه هم قصد مشارکت داشتید خیلی خوشحال می‌شیم :) <a href="http://github.com/mariotek" class="show-in-print">http://github.com/mariotek</a>

## دانلود کتاب به فرمت‌های PDF/Epub

می‌تونین خیلی راحت نسخه آنلاین کتاب استفاده کنین یا اگه به فایل کتاب می‌خوایین دسترسی داشته باشین، از بخش ریلیزهای گیت‌هاب به فرمت‌های مختلف آخرین نسخه کتاب رو می‌تونین دریافت کنین.


### فهرست

| ردیف | سوال | صفحه |
| ---- | --------- | ------- |
|1  | [روش‌های ایجاد objects توی جاواسکریپت چیا هستن؟](#روشهای-ایجاد-objects-توی-جاواسکریپت-چیا-هستن) |  |
|2  | [زنجیره prototype چیه؟](#زنجیره-prototype-چیه) |  |
|3  | [تفاوت‌های بین Call، Apply و Bind چیا هستن؟](#تفاوتهای-بین-Call،-Apply-و-Bind-چیا-هستن) |  |
|4  | [فرمت JSON چیه و عملیات‌های معمول بر روی آن چیا هستن؟](#فرمت-JSON-چیه-و-عملیاتهای-معمول-بر-روی-آن-چیا-هستن) |  |
|5  | [هدف از متد slice روی آرایه‌ها چیه؟](#هدف-از-متد-slice-روی-آرایهها-چیه) |  |
|6  | [هدف از متد splice روی آرایه‌ها چیه؟](#هدف-از-متد-splice-روی-آرایهها-چیه) |  |
|7  | [تفاوت متدهای slice و splice چیا هستن؟](#تفاوت-متدهای-slice-و-splice-چیا-هستن) |  |
|8  | [تفاوت‌های Object و Map چیا هستن؟](#تفاوتهای-Object-و-Map-چیا-هستن) |  |
|9  | [تفاوت‌های بین عملگرهای == و === چیا هستن؟](#تفاوتهای-بین-عملگرهای-و-چیا-هستن) |  |
|10 | [توابع lambda یا arrow-function چی هستن؟](#توابع-lambda-یا-arrow-function-چی-هستن) |  |
|11 | [یه تابع first-class چجور تابعی‌ـه؟](#یه-تابع-first-class-چجور-تابعیـه) |  |
|12 | [یه تابع first-order چجور تابعی‌ـه؟](#یه-تابع-first-order-چجور-تابعیـه) |  |
|13 | [یه تابع higher-order چجور تابعی‌ـه؟](#یه-تابع-higher-order-چجور-تابعیـه) |  |
|14 | [یه تابع unary چجور تابعی‌ـه؟](#یه-تابع-unary-چجور-تابعیـه) |  |
|15 | [currying توابع یعنی چی؟](#currying-توابع-یعنی-چی) |  |
|16 | [چه توابعی pure هستن؟](#چه-توابعی-pure-هستن) |  |
|17 | [هدف از کلمه کلیدی let چیه؟](#هدف-از-کلمه-کلیدی-let-چیه) |  |
|18 | [تفاوت‌های کلمات کلیدی let و var چیا هستن؟](#تفاوتهای-کلمات-کلیدی-let-و-var-چیا-هستن) |  |
|19 | [دلیل انتخاب کلمه کلیدی let چیه؟](#دلیل-انتخاب-کلمه-کلیدی-let-چیه) |  |
|20 | [چطوری می‌تونیم توی بلوک مربوط به switch بدون دریافت خطا متغیر تعریف کنیم؟](#چطوری-می‌تونیم-توی-بلوک-مربوط-به-switch-بدون-دریافت-خطا-متغیر-تعریف-کنیم) | |
|21 | [Temporal-Dead-Zone چیه؟](#Temporal-Dead-Zone-چیه  ) |  |
|22 | [IIFE(توابع بلافاصله صدا زده شده) چی هستن؟](#IIFEتوابع-بلافاصله-صدا-زده-شده-چی-هستن) |  |
|23 | [مزایای استفاده از moduleها چیه؟](#مزایای-استفاده-از-moduleها-چیه) |  |
|24 | [Memoization چیه؟](#Memoization-چیه) |  |
|25 | [Hoisting چیه؟](#Hoisting-چیه) |  |
|26 | [Classها توی ES6 چی هستن؟](#Classها-توی-ES6-چی-هستن) |  |
|27 | [Closureها چیا هستن؟](#Closureها-چیا-هستن) |  |
|28 | [Moduleها چیا هستن؟](#Moduleها-چیا-هستن) |  |
|29 | [چرا به moduleها نیاز داریم؟](#چرا-به-moduleها-نیاز-داریم) |  |
|30 | [توی جاواسکریپت scope چیه و چیکار می‌کنه؟](#توی-جاواسکریپت-scope-چیه-و-چیکار-می‌کنه) |  |
|31 | [service-worker چیه؟](#service-worker-چیه) |  |
|32 | [توی service-worker چطوری می‌شه DOM رو دستکاری کرد؟](#توی-service-worker-چطوری-می‌شه-DOM-رو-دستکاری-کرد) |  |
|33 | [چطوری می‌تونیم بین ریست شدن‌های service-worker داده‌های مورد نظرمون رو مجدد استفاده کنیم؟](#چطوری-می‌تونیم-بین-ریست-شدنهای-service-worker-دادههای-مورد-نظرمون-رو-مجدد-استفاده-کنیم) | |
|34 | [IndexedDB چیه؟](#IndexedDB-چیه) |  |
|35 | [Web-storage چیه؟](#Web-storage-چیه) |  |
|36 | [Post-message چیه؟](#Post-message-چیه) |  |
|37 | [Cookie چیه؟](#Cookie-چیه) |  |
|38 | [چرا به cookie نیاز داریم؟](#چرا-به-cookie-نیاز-داریم) |  |
|39 | [گزینه‌های قابل تنظیم توی cookie چیا هستن؟](#گزینههای-قابل-تنظیم-توی-cookie-چیا-هستن) |  |
|40 | [چطوری می‌شه یه cookie رو حذف کرد؟](#چطوری-می‌شه-یه-cookie-رو-حذف-کرد) |  |
|41 | [تفاوت‌های بین cookie، local-storage و session-storage چیا هستن؟](#تفاوتهای-بین-cookie،-local-storage-و-session-storage-چیا-هستن) |  |
|42 | [تفاوت‌های بین localStorage و sessionStorage چیا هستن؟](#تفاوتهای-بین-localStorage-و-sessionStorage-چیا-هستن) |  |
|43 | [چطوری به web-storage دسترسی پیدا می‌کنی؟](#چطوری-به-web-storage-دسترسی-پیدا-می‌کنی) |  |
|44 | [چه متد‌هایی روی session-storage قابل استفاده هستن؟](#چه-متدهایی-روی-session-storage-قابل-استفاده-هستن) |  |
|45 | [رخداد storage چیه و چطوری ازش استفاده می‌کنیم؟](#رخداد-storage-چیه-و-چطوری-ازش-استفاده-می‌کنیم) |  |
|46 | [چرا به web-storage نیاز داریم؟](#چرا-به-web-storage-نیاز-داریم) |  |
|47 | [چطوری می‌تونیم پشتیبانی از web-storage توسط مرورگر رو بررسی کنیم؟](#چطوری-می‌تونیم-پشتیبانی-از-web-storage-توسط-مرورگر-رو-بررسی-کنیم) | |
|48 | [چطوری می‌تونیم پشتیبانی از web-worker توسط مرورگر رو بررسی کنیم؟](#چطوری-می‌تونیم-پشتیبانی-از-web-worker-توسط-مرورگر-رو-بررسی-کنیم) | |
|49 | [یه مثال از web-workerها می‌تونی بزنی؟](#یه-مثال-از-web-workerها-میتونی-بزنی) |  |
|50 | [محدودیت‌های web-workerها روی DOM چیا هستن؟](#محدودیتهای-web-workerها-روی-DOM-چیا-هستن) |  |
|51 | [Promise چیه؟](#Promise-چیه  ) |  |
|52 | [چرا به promise نیاز داریم؟](#چرا-به-promise-نیاز-داریم) |  |
|53 | [سه تا وضعیت ممکن برای یه promise چیا هستن؟](#سه-تا-وضعیت-ممکن-برای-یه-promise-چیا-هستن) |  |
|54 | [توابع callback چی هستن؟](#توابع-callback-چی-هستن) |  |
|55 | [چرا به توابع callback نیاز داریم؟](#چرا-به-توابع-callback-نیاز-داریم) |  |
|56 | [Callback-hell یا جهنم توابع callback چیه؟](#Callback-hell-یا-جهنم-توابع-callback-چیه  ) |  |
|57 | [Server-sent-events(SSE) چیه؟](#Server-sent-eventsSSE-چیه  ) |  |
|58 | [چطوری می‌تونیم اعلان‌های server-sent-event رو دریافت کنیم؟](#چطوری-می‌تونیم-اعلانهای-server-sent-event-رو-دریافت-کنیم) |  |
|59 | [چطوری می‌تونیم پشتیبانی مرورگر برای SSE رو بررسی کنیم؟](#چطوری-می‌تونیم-پشتیبانی-مرورگر-برای-SSE-رو-بررسی-کنیم) |  |
|60 | [کدوم توابع روی SSE وجود دارن؟](#کدوم-توابع-روی-SSE-وجود-دارن) |  |
|61 | [اصلی‌ترین قوانین promiseها چیا هستن؟](#اصلیترین-قوانین-promiseها-چیا-هستن) |  |
|62 | [Callback توی callback چطوری رخ میده؟](#Callback-توی-callback-چطوری-رخ-میده            ) |  |
|63 | [زنجیره promiseها چیه؟](#زنجیره-promiseها-چیه) |  |
|64 | [کاربرد متد promise.all چیه؟](#کاربرد-متد-promise.all-چیه) |  |
|65 | [هدف از متد race روی promise چیه؟](#هدف-از-متد-race-روی-promise-چیه) |  |
|66 | [حالت strict توی جاواسکریپت چی کار می‌کنه؟](#حالت-strict-توی-جاواسکریپت-چی-کار-می‌کنه) |  |
|67 | [چرا به حالت strict نیاز داریم؟](#چرا-به-حالت-strict-نیاز-داریم) |  |
|68 | [چطوری می‌تونیم حالت strict رو فعال کنیم؟](#چطوری-می‌تونیم-حالت-strict-رو-فعال-کنیم) |  |
|69 | [هدف از عملگر نقیض دوتایی(!!) چیه؟](#هدف-از-عملگر-نقیض-دوتایی!!-چیه) |  |
|70 | [هدف از عملگر delete چیه؟](#هدف-از-عملگر-delete-چیه) |  |
|71 | [عملگر typeof چیکار می‌کنه؟](#عملگر-typeof-چیکار-می‌کنه) |  |
|72 | [undefined چیه و چه زمانی undefined می‌گیریم؟](#undefined-چیه-و-چه-زمانی-undefined-می‌گیریم      ) |  |
|73 | [null چیه؟](#null-چیه  ) |  |
|74 | [تفاوت‌های بین null و undefined چیا هستن؟](#تفاوتهای-بین-null-و-undefined-چیا-هستن) |  |
|75 | [eval چیه؟](#eval-چیه  ) |  |
|76 | [تفاوت‌های بین window و document چیا هستن؟](#تفاوتهای-بین-window-و-document-چیا-هستن) |  |
|77 | [توی جاواسکریپت چطوری می‌تونیم به history دسترسی داشته باشیم؟](#توی-جاواسکریپت-چطوری-می‌تونیم-به-history-دسترسی-داشته-باشیم) |  |
|78 | [انواع داده‌های جاواسکریپت کدوما هستن؟](#انواع-دادههای-جاواسکریپت-کدوما-هستن) |  |
|79 | [isNaN چیه و چیکار می‌کنه؟](#isNaN-چیه-و-چیکار-می‌کنه                ) |  |
|80 | [تفاوت‌های بین undeclared و undefined چیا هستن؟](#تفاوتهای-بین-undeclared-و-undefined-چیا-هستن) |  |
|81 | [کدوم متغیرها عمومی هستن؟](#کدوم-متغیرها-عمومی-هستن) |  |
|82 | [مشکلات متغیرهای عمومی چیا هستن؟](#مشکلات-متغیرهای-عمومی-چیا-هستن) |  |
|83 | [مقدار NaN چیه؟](#مقدار-NaN-چیه) |  |
|84 | [هدف از تابع isFinite چیه؟](#هدف-از-تابع-isFinite-چیه) |  |
|85 | [یه event-flow چیه؟](#یه-event-flow-چیه) |  |
|86 | [Event-bubbling چیه؟](#Event-bubbling-چیه  ) |  |
|87 | [Event-capturing چیه؟](#Event-capturing-چیه  ) |  |
|88 | [چطوری می‌شه یه فرم رو با استفاده از جاواسکریپت ثبت کرد؟](#چطوری-می‌شه-یه-فرم-رو-با-استفاده-از-جاواسکریپت-ثبت-کرد) |  |
|89 | [چطوری می‌شه به اطلاعات مربوط به سیستم عامل کاربر دسترسی داشت؟](#چطوری-می‌شه-به-اطلاعات-مربوط-به-سیستم-عامل-کاربر-دسترسی-داشت) | |
|90 | [تفاوت‌های بین رخدادهای document-load و DOMContentLoaded چیا هستن؟](#تفاوتهای-بین-رخدادهای-document-load-و-DOMContentLoaded-چیا-هستن) | |
|91 | [تفاوت‌های بین objectهای native، host و user چیا هستن؟](#تفاوتهای-بین-objectهای-native،-host-و-user-چیا-هستن) |  |
|92 | [کدوم ابزار و تکنیک‌ها برای دیباگ کردن برنامه جاواسکریپتی استفاده میشن؟](#کدوم-ابزار-و-تکنیکها-برای-دیباگ-کردن-برنامه-جاواسکریپتی-استفاده-میشن) | |
|93 | [مزایا و معایب استفاده از promiseها به جای callback چیا هستن؟](#مزایا-و-معایب-استفاده-از-promiseها-به-جای-callback-چیا-هستن) |  |
|94 | [تفاوت‌های بین attribute و property روی DOM چیا هستن؟](#تفاوتهای-بین-attribute-و-property-روی-DOM-چیا-هستن) |  |
|95 | [سیاست same-origin چیه؟](#سیاست-same-origin-چیه) |  |
|96 | [هدف استفاده از void 0 چیه؟](#هدف-استفاده-از-void-0-چیه) |  |
|97 | [جاواسکریپت یه زبان تفسیری هست یا کامپایلری؟](#جاواسکریپت-یه-زبان-تفسیری-هست-یا-کامپایلری) |  |
|98 | [آیا جاواسکریپت یه زبان حساس به بزرگی و کوچکی(case-sensitive) حروف است؟](#آیا-جاواسکریپت-یه-زبان-حساس-به-بزرگی-و-کوچکیcase-sensitive-حروف-است) | |
|99 | [ارتباطی بین Java و JavaScript وجود داره؟](#ارتباطی-بین-Java-و-JavaScript-وجود-داره) |  |
|100| [Eventها چی هستن؟](#Eventها-چی-هستن) |  |
|101| [کی جاواسکریپت رو ساخته؟](#کی-جاواسکریپت-رو-ساخته) |  |
|102| [هدف از متد preventDefault چیه؟](#هدف-از-متد-preventDefault-چیه) |  |
|103| [کاربرد متد stopPropagation چیه؟](#کاربرد-متد-stopPropagation-چیه) |  |
|104| [مراحلی که موقع استفاده از return false توی یه event-handler رخ میده چیا هستن؟](#مراحلی-که-موقع-استفاده-از-return-false-توی-یه-event-handler-رخ-میده-چیا-هستن) | |
|105| [BOM چیه؟](#BOM-چیه) |  |
|106| [موارد استفاده از setTimeout کدوما هستن؟](#موارد-استفاده-از-setTimeout-کدوما-هستن) |  |
|107| [موارد استفاده از setInterval کدوما هستن؟](#موارد-استفاده-از-setInterval-کدوما-هستن) |  |
|108| [چرا جاواسکریپت رو به عنوان یه زبان تک thread می‌شناسن؟](#چرا-جاواسکریپت-رو-به-عنوان-یه-زبان-تک-thread-میشناسن) |  |
|109| [Event-delegation چیه؟](#Event-delegation-چیه) |  |
|110| [ECMAScript چیه؟](#ECMAScript-چیه) |  |
|111| [JSON چیه؟](#JSON-چیه) |  |
|112| [قوانین فرمت JSON کدوما هستن؟](#قوانین-فرمت-JSON-کدوما-هستن) |  |
|113| [هدف از متد JSON.stringify چیه؟](#هدف-از-متد-JSON.stringify-چیه) |  |
|114| [چطوری می‌تونیم یه رشته(string) JSON رو تجزیه کنیم؟](#چطوری-می‌تونیم-یه-رشتهstring-JSON-رو-تجزیه-کنیم) |  |
|115| [چرا به JSON نیاز داریم؟](#چرا-به-JSON-نیاز-داریم) |  |
|116| [PWAها چی هستن؟](#PWAها-چی-هستن) |  |
|117| [هدف از متد clearTimeout چیه؟](#هدف-از-متد-clearTimeout-چیه) |  |
|118| [هدف از متد clearInterval چیه؟](#هدف-از-متد-clearInterval-چیه) |  |
|119| [توی جاواسکریپت، چطوری می‌شه به یه صفحه جدید redirect انجام داد؟](#توی-جاواسکریپت،-چطوری-می‌شه-به-یه-صفحه-جدید-redirect-انجام-داد) | |
|120| [چطوری بررسی می‌کنین که یه string شامل یه substring هست یا نه؟](#چطوری-بررسی-می‌کنین-که-یه-string-شامل-یه-substring-هست-یا-نه) | |
|121| [توی جاواسکریپت، چطوری مقدار یه آدرس email رو اعتبارسنجی می‌کنین؟](#توی-جاواسکریپت،-چطوری-مقدار-یه-آدرس-email-رو-اعتبارسنجی-می‌کنین) | |
|122| [چطوری می‌تونیم مقدار آدرس url جاری رو بخونیم؟](#چطوری-می‌تونیم-مقدار-آدرس-url-جاری-رو-بخونیم) |  |
|123| [ویژگی‌های مختلف url روی object مربوط به history کدوما هستن؟](#ویژگیهای-مختلف-url-روی-object-مربوط-به-history-کدوما-هستن) |  |
|124| [توی جاواسکریپت چطوری می‌تونیم مقدار یه query-string رو بخونیم؟](#توی-جاواسکریپت-چطوری-می‌تونیم-مقدار-یه-query-string-رو-بخونیم) | |
|125| [چطوری می‌تونیم بررسی کنیم که آیا یه پراپرتی روی آبجکت وجود داره یا نه؟](#چطوری-می‌تونیم-بررسی-کنیم-که-آیا-یه-پراپرتی-روی-آبجکت-وجود-داره-یا-نه) |  |
|126| [ری روی یه object حلقه میزنی؟](#چطوری-روی-یه-object-حلقه-میزنی) |  |
|127| [چطوری تست می‌کنی که یه object خالیه؟](#چطوری-تست-می‌کنی-که-یه-object-خالیه) |  |
|128| [arguments object چیه؟](#arguments-object-چیه) |  |
|129| [چطوری حرف اول یه رشته رو به حرف بزرگ تبدیل می‌کنی؟](#چطوری-حرف-اول-یه-رشته-رو-به-حرف-بزرگ-تبدیل-می‌کنی) |  |
|130| [مزایا و معایب حلقه for چیا هستن؟](#مزایا-و-معایب-حلقه-for-چیا-هستن) |  |
|131| [چطوری تاریخ جاری رو توی جاواسکریپت نشون میدی؟](#چطوری-تاریخ-جاری-رو-توی-جاواسکریپت-نشون-میدی) |  |
|132| [چطوری دو تا date object رو با هم مقایسه می‌کنی؟](#چطوری-دو-تا-date-object-رو-با-هم-مقایسه-می‌کنی) |  |
|133| [چطوری بررسی می‌کنی که یه رشته با یه رشته دیگه شروع می‌شه؟](#چطوری-بررسی-می‌کنی-که-یه-رشته-با-یه-رشته-دیگه-شروع-می‌شه) |  |
|134| [چطوری یه رشته رو trim می‌کنی؟](#چطوری-یه-رشته-رو-trim-می‌کنی) |  |
|135| [توی جاواسکریپت چطوری می‌تونیم یه زوج مرتب از key یه valueها بسازیم؟](#توی-جاواسکریپت-چطوری-می‌تونیم-یه-زوج-مرتب-از-key-یه-valueها-بسازیم) |  |
|136| [آیا عبارت '!--' عملگر خاصی هست؟](#آیا-عبارت-!---عملگر-خاصی-هست) |  |
|137| [چطوری می‌تونیم به متغیرهامون مقادیر اولیه بدیم؟](#چطوری-می‌تونیم-به-متغیرهامون-مقادیر-اولیه-بدیم) |  |
|138| [چطوری می‌تونیم متن‌های چند خطی درست کنیم؟](#چطوری-می‌تونیم-متنهای-چند-خطی-درست-کنیم) |  |
|139| [مدل app-shell چیه؟](#مدل-app-shell-چیه) |  |
|140| [چطوری می‌تونیم روی یه تابع property اضافه کنیم؟](#چطوری-می‌تونیم-روی-یه-تابع-property-اضافه-کنیم) |  |
|141| [چطوری می‌تونیم تعداد پارامترهای ورودی یه تابع رو به دست بیاریم؟](#چطوری-می‌تونیم-تعداد-پارامترهای-ورودی-یه-تابع-رو-به-دست-بیاریم) |  |
|142| [Polyfill چیه؟](#Polyfill-چیه) |  |
|143| [عبارات Break و continue چی هستن؟](#عبارات-Break-و-continue-چی-هستن) |  |
|144| [توی جاواسکریپت labelها چیکار می‌کنن؟](#توی-جاواسکریپت-labelها-چیکار-میکنن) |  |
|145| [مزایای declare کردن متغیرها در اوایل کد چیه؟](#مزایای-declare-کردن-متغیرها-در-اوایل-کد-چیه) |  |
|146| [مزایای مقداردهی اولیه متغیرها چیه؟](#مزایای-مقداردهی-اولیه-متغیرها-چیه) |  |
|147| [روش توصیه شده برای ایجاد object چیه؟](#روش-توصیه-شده-برای-ایجاد-object-چیه) |  |
|148| [چطوری می‌تونیم آرایه‌ JSON تعریف کنیم؟](#چطوری-می‌تونیم-آرایه-JSON-تعریف-کنیم) |  |
|149| [چطوری می‌تونیم اعداد تصادفی تولید کنیم؟](#چطوری-می‌تونیم-اعداد-تصادفی-تولید-کنیم) |  |
|150| [می‌تونی یه تابع تولید اعداد تصادفی توی یه بازه مشخص بنویسی؟](#میتونی-یه-تابع-تولید-اعداد-تصادفی-توی-یه-بازه-مشخص-بنویسی) |  |
|151| [Tree-shaking چیه؟](#Tree-shaking-چیه) |  |
|152| [دلایل نیاز به tree-shaking کدوما هستن؟](#دلایل-نیاز-به-tree-shaking-کدوما-هستن) |  |
|153| [آیا استفاده از eval توصیه می‌شه؟](#آیا-استفاده-از-eval-توصیه-می‌شه) |  |
|154| [Regular-Expression چیه؟](#Regular-Expression-چیه) |  |
|155| [متدهای رشته که روی Regular-expression مجاز هستن کدوماست؟](#متدهای-رشته-که-روی-Regular-expression-مجاز-هستن-کدوماست) |  |
|156| [توی Regex بخش modifiersها چیکار می‌کنه؟](#توی-Regex-بخش-modifiersها-چیکار-می‌کنه) |  |
|157| [پترن‌های regular-expression چیه؟](#پترنهای-regular-expression-چیه) |  |
|158| [آبجکت RegExp چیه؟](#آبجکت-RegExp-چیه) |  |
|159| [چطوری روی یه رشته دنبال یه پترن RegExp می‌گردی؟](#چطوری-روی-یه-رشته-دنبال-یه-پترن-RegExp-میگردی) |  |
|160| [هدف از متد exec چیه؟](#هدف-از-متد-exec-چیه) |  |
|161| [چطوری استایل‌های یه المنت HTML رو تغییر میدی؟](#چطوری-استایلهای-یه-المنت-HTML-رو-تغییر-میدی) |  |
|162| [نتیجه عبارت 1+2+'3' چی می‌شه؟](#نتیجه-عبارت-1+2+3-چی-می‌شه) |  |
|163| [عبارت debugger چیکار می‌کنه؟](#عبارت-debugger-چیکار-می‌کنه) |  |
|164| [هدف از breakpointها توی debugging چیه؟](#هدف-از-breakpointها-توی-debugging-چیه) |  |
|165| [آیا می‌تونیم از عبارت‌های رزرو شده در تعریف identifierها(اسم متغیر، کلاس و ...) استفاده کنیم؟](#آیا-می‌تونیم-از-عبارتهای-رزرو-شده-در-تعریف-identifierهااسم-متغیر،-کلاس-و--استفاده-کنیم) |  |
|166| [چطوری تشخیص بدیم که یه مرورگر mobile هست یا نه؟](#چطوری-تشخیص-بدیم-که-یه-مرورگر-mobile-هست-یا-نه) |  |
|167| [چطوری بدون Regex تشخیص بدیم که یه مرورگر mobile هست یا نه؟](#چطوری-بدون-Regex-تشخیص-بدیم-که-یه-مرورگر-mobile-هست-یا-نه) |  |
|168| [چطوری طول و عرض یه تصویر رو با جاواسکریپت به دست میاری؟](#چطوری-طول-و-عرض-یه-تصویر-رو-با-جاواسکریپت-به-دست-میاری) |  |
|169| [چطوری درخواست‌های synchronous HTTP بزنیم؟](#چطوری-درخواستهای-synchronous-HTTP-بزنیم) |  |
|170| [چطوری درخواست‌های asynchronous HTTP بزنیم؟](#چطوری-درخواستهای-asynchronous-HTTP-بزنیم) |  |
|171| [چطوری یه تاریخ رو به یه تاریخ در timezone دیگه تبدیل کنیم؟](#چطوری-یه-تاریخ-رو-به-یه-تاریخ-در-timezone-دیگه-تبدیل-کنیم) |  |
|172| [چه propertyهایی برای اندازه‌گیزی سایز window به کار میره؟](#چه-propertyهایی-برای-اندازهگیزی-سایز-window-به-کار-میره) |  |
|173| [عملگر شرطی سه گانه توی جاواسکریپت چیه؟](#عملگر-شرطی-سه-گانه-توی-جاواسکریپت-چیه) |  |
|174| [آیا می‌شه روی عملگر شرطی زنجیره شرط‌ها رو اعمال کرد؟](#آیا-می‌شه-روی-عملگر-شرطی-زنجیره-شرطها-رو-اعمال-کرد) |  |
|175| [روش‌های اجرای جاواسکریپت بعد از لود شدن صفحه کدوما هستن؟](#روشهای-اجرای-جاواسکریپت-بعد-از-لود-شدن-صفحه-کدوما-هستن) |  |
|176| [تفاوت‌های بین proto و prototype کدوما هستن؟](#تفاوتهای-بین-proto-و-prototype-کدوما-هستن) |  |
|177| [میتونی یه مثال از زمانی که واقعا به سمیکولون( ; ) نیاز هست بزنی؟](#میتونی-یه-مثال-از-زمانی-که-واقعا-به-سمیکولون-نیاز-هست-بزنی) |  |
|178| [متد freeze چیکار می‌کنه؟](#متد-freeze-چیکار-می‌کنه) |  |
|179| [هدف از متد freeze چیه؟](#هدف-از-متد-freeze-چیه) |  |
|180| [چرا به متد freeze نیاز داریم؟](#چرا-به-متد-freeze-نیاز-داریم) |  |
|181| [چطوری می‌تونیم زبان ترجیحی یه مرورگر رو تشخیص بدیم؟](#چطوری-می‌تونیم-زبان-ترجیحی-یه-مرورگر-رو-تشخیص-بدیم) |  |
|182| [چطوری می‌تونیم حرف اول همه کلمات یه رشته رو به حرف بزرگ تبدیل کنیم؟](#چطوری-می‌تونیم-حرف-اول-همه-کلمات-یه-رشته-رو-به-حرف-بزرگ-تبدیل-کنیم) |  |
|183| [چطوری می‌شه تشخیص داد که جاواسکریپت یه صفحه وب غیرفعال شده؟](#چطوری-می‌شه-تشخیص-داد-که-جاواسکریپت-یه-صفحه-وب-غیرفعال-شده) |  |
|184| [عملگرهای پشتیبانی شده توسط جاواسکریپت کدوما هستن؟](#عملگرهای-پشتیبانی-شده-توسط-جاواسکریپت-کدوما-هستن) |  |
|185| [پارامتر rest چیکار می‌کنه؟](#پارامتر-rest-چیکار-می‌کنه) |  |
|186| [اگه پارامتر rest رو به عنوان آخرین پارامتر استفاده نکنیم چی می‌شه؟](#اگه-پارامتر-rest-رو-به-عنوان-آخرین-پارامتر-استفاده-نکنیم-چی-می‌شه) |  |
|187| [عملگرهای منطقی باینری توی جاواسکریپت کدوما هستن؟](#عملگرهای-منطقی-باینری-توی-جاواسکریپت-کدوما-هستن) |  |
|188| [عملگر spread چیکار می‌کنه؟](#عملگر-spread-چیکار-می‌کنه) |  |
|189| [چطوری تشخیص میدی که یه آبجکت freeze شده یا نه؟](#چطوری-تشخیص-میدی-که-یه-آبجکت-freeze-شده-یا-نه) |  |
|190| [چطوری بررسی کنیم که دو تا مقدار(شامل آبجکت) با هم برابرن یا نه؟](#چطوری-بررسی-کنیم-که-دو-تا-مقدارشامل-آبجکت-با-هم-برابرن-یا-نه) |  |
|191| [هدف از متد is روی object چیه؟](#هدف-از-متد-is-روی-object-چیه) |  |
|192| [چطوری propertyهای یه object رو به یه object دیگه کپی می‌کنی؟](#چطوری-propertyهای-یه-object-رو-به-یه-object-دیگه-کپی-می‌کنی) |  |
|193| [کاربردهای ممتد assign چیه؟](#کاربردهای-ممتد-assign-چیه) |  |
|194| [آبجکت proxy چیه؟](#آبجکت-proxy-چیه) |  |
|195| [هدف از متد seal چیه؟](#هدف-از-متد-seal-چیه) |  |
|196| [کاربردهای متد seal چیه؟](#کاربردهای-متد-seal-چیه) |  |
|197| [تفاوت‌های بین متدهای freeze و seal چیا هست؟](#تفاوتهای-بین-متدهای-freeze-و-seal-چیا-هست) |  |
|198| [چطوری تشخیص میدی که یه آبجکت seal شده یا نه؟](#چطوری-تشخیص-میدی-که-یه-آبجکت-seal-شده-یا-نه) |  |
|199| [چطوری کلید و مقدارهای enumerable رو به دست میاری؟](#چطوری-کلید-و-مقدارهای-enumerable-رو-به-دست-میاری) |  |
|200| [تفاوت‌های بین متدهای Object.values و Object.entries چیا هست؟](#تفاوتهای-بین-متدهای-Objectvalues-و-Objectentries-چیا-هست) |  |
|201| [چطوری لیست کلیدهای یه object رو بدست میاری؟](#چطوری-لیست-کلیدهای-یه-object-رو-بدست-میاری) |  |
|202| [چطوری یه object با prototype درست می‌کنی؟](#چطوری-یه-object-با-prototype-درست-می‌کنی) |  |
|203| [WeakSet چیه؟](#WeakSet-چیه) |  |
|204| [تفاوت‌های بین WeakSet و Set کدوما هستن؟](#تفاوتهای-بین-WeakSet-و-Set-کدوما-هستن) |  |
|205| [لیست متدهایی که رو WeakSet قابل استفاده هستن رو می‌تونی بگی؟](#لیست-متدهایی-که-رو-WeakSet-قابل-استفاده-هستن-رو-میتونی-بگی) |  |
|206| [WeakMap چیه؟](#WeakMap-چیه) |  |
|207| [تفاوت‌های بین WeakMap و Map کدوما هستن؟](#تفاوتهای-بین-WeakMap-و-Map-کدوما-هستن) |  |
|208| [لیست متدهایی که رو WeakMap قابل استفاده هستن رو می‌تونی بگی؟](#لیست-متدهایی-که-رو-WeakMap-قابل-استفاده-هستن-رو-میتونی-بگی) |  |
|209| [هدف از متد uneval چیه؟](#هدف-از-متد-uneval-چیه) |  |
|210| [چطوری یه URL رو encode می‌کنی؟](#چطوری-یه-URL-رو-encode-می‌کنی) |  |
|211| [چطوری یه URL رو decode می‌کنی؟](#چطوری-یه-URL-رو-decode-می‌کنی) |  |
|212| [چطوری محتوای یه صفحه رو پرینت می‌گیری؟](#چطوری-محتوای-یه-صفحه-رو-پرینت-می‌گیری) |  |
|213| [تفاوت‌های بین uneval و eval چیا هستن؟](#تفاوتهای-بین-uneval-و-eval-چیا-هستن) |  |
|214| [تابع anonymous چیه؟](#تابع-anonymous-چیه) |  |
|215| [تفاوت تقدم بین متغیرهای local و global چطوریه؟](#تفاوت-تقدم-بین-متغیرهای-local-و-global-چطوریه) |  |
|216| [accessorهای جاواسکریپت چیکار می‌کنن؟](#accessorهای-جاواسکریپت-چیکار-میکنن) |  |
|217| [چطوری روی constructor یه Object یه مقدار تعریف می‌کنی؟](#چطوری-روی-constructor-یه-Object-یه-مقدار-تعریف-می‌کنی) |  |
|218| [تفاوت‌های بین get و defineProperty چیا هست؟](#تفاوتهای-بین-get-و-defineProperty-چیا-هست) |  |
|219| [مزایای استفاده از Getter و Setter چیه؟](#مزایای-استفاده-از-Getter-و-Setter-چیه) |  |
|220| [می‌تونیم getter و setter رو با استفاده از متد defineProperty تعریف کنیم؟](#می‌تونیم-getter-و-setter-رو-با-استفاده-از-متد-defineProperty-تعریف-کنیم) |  |
|221| [هدف استفاده از switch-case چیه؟](#هدف-استفاده-از-switch-case-چیه) |  |
|222| [چه قواعدی برای استفاده از swtich-case باید رعایت بشه؟](#چه-قواعدی-برای-استفاده-از-swtich-case-باید-رعایت-بشه) |  |
|223| [نوع داده‌های primitive کدوما هستن؟](#نوع-دادههای-primitive-کدوما-هستن) |  |
|224| [روش‌های مختلف دسترسی به propertyهای object کدوما هستن؟](#روشهای-مختلف-دسترسی-به-propertyهای-object-کدوما-هستن) |  |
|225| [قوانین پارامترهای توابع کدوما هستن؟](#قوانین-پارامترهای-توابع-کدوما-هستن) |  |
|226| [آبجکت error چیه؟](#آبجکت-error-چیه) |  |
|227| [چه موقعی خطای syntax دریافت می‌کنیم؟](#چه-موقعی-خطای-syntax-دریافت-می‌کنیم) |  |
|228| [عنوان خطاهای مختلف که روی error-object برمیگردن کدوما هستن؟](#عنوان-خطاهای-مختلف-که-روی-error-object-برمیگردن-کدوما-هستن) |  |
|229| [عبارات مختلف که در هنگام مدیریت error استفاده میشن کدوما هستن؟](#عبارات-مختلف-که-در-هنگام-مدیریت-error-استفاده-میشن-کدوما-هستن) |  |
|230| [دو نوع مختلف حلفه‌ها در جاواسکریپت کدوما هستن؟](#دو-نوع-مختلف-حلفهها-در-جاواسکریپت-کدوما-هستن) |  |
|231| [nodejs چیه؟](#nodejs-چیه) |  |
|232| [آبجکت Intl چیه؟](#آبجکت-Intl-چیه) |  |
|233| [چطوری تاریخ و زمان رو بر اساس زبان جاری سیستم کاربر نمایش بدیم؟](#چطوری-تاریخ-و-زمان-رو-بر-اساس-زبان-جاری-سیستم-کاربر-نمایش-بدیم) |  |
|234| [Iterator چیه؟](#Iterator-چیه) |  |
|235| [حلفه‌های synchronous(همزمان) چطوری کار می‌کنن؟](#حلفههای-synchronousهمزمان-چطوری-کار-میکنن) |  |
|236| [Event-loop چیه؟](#Event-loop-چیه) |  |
|237| [Call-stack چیه؟](#Call-stack-چیه) |  |
|238| [Event-queue چیه؟](#Event-queue-چیه) |  |
|239| [Decorator چیه؟](#Decorator-چیه) |  |
|240| [مقادیر موجود روی آبجکت Intl کدوما هستن؟](#مقادیر-موجود-روی-آبجکت-Intl-کدوما-هستن) |  |
|241| [عملگر Unary چیه؟](#عملگر-Unary-چیه) |  |
|242| [چطوری المنت‌های موجود تو یه آرایه رو مرتب می‌کنی؟](#چطوری-المنتهای-موجود-تو-یه-آرایه-رو-مرتب-می‌کنی) |  |
|243| [هدف از تابع مرتب‌سازی موقع استفاده از متد sort چیه؟](#هدف-از-تابع-مرتبسازی-موقع-استفاده-از-متد-sort-چیه) |  |
|244| [چطوری آیتم‌های یه آرایه رو معکوس مرتب کنیم؟](#چطوری-آیتمهای-یه-آرایه-رو-معکوس-مرتب-کنیم) |  |
|245| [چطوری حداقل و حداکثر مقدار یه آرایه رو بدست بیاریم؟](#چطوری-حداقل-و-حداکثر-مقدار-یه-آرایه-رو-بدست-بیاریم) |  |
|246| [چطوری حداقل و حداکثر مقدار یه آرایه رو بدون استفاده از متدهای Math بدست بیاریم؟](#چطوری-حداقل-و-حداکثر-مقدار-یه-آرایه-رو-بدون-استفاده-از-متدهای-Math-بدست-بیاریم) |  |
|247| [عبارت خالی چیه و هدف از استفاده ازش چیه؟](#عبارت-خالی-چیه-و-هدف-از-استفاده-ازش-چیه) |  |
|248| [چطوری metadata یه ماژول رو بدست میاری؟ meta data of a module](#چطوری-metadata-یه-ماژول-رو-بدست-میاری-meta-data-of-a-module) |  |
|249| [عملگر comma چیه و چیکار می‌کنه؟](#عملگر-comma-چیه-و-چیکار-می‌کنه) |  |
|250| [مزایای استفاده از عملگر comma چیه؟](#مزایای-استفاده-از-عملگر-comma-چیه) |  |
|251| [Typescript چیه؟](#Typescript-چیه) |  |
|252| [تفاوت‌های بین javascript و typescript کدوما هستن؟](#تفاوتهای-بین-javascript-و-typescript-کدوما-هستن) |  |
|253| [مزایای typescript نسبت به javascript چیاست؟](#مزایای-typescript-نسبت-به-javascript-چیاست) |  |
|254| [object-initializer چیه؟](#object-initializer-چیه) |  |
|255| [متد constructor چیه؟](#متد-constructor-چیه) |  |
|256| [اگه متد constructor رو بیش از یه بار توی کلاس بنویسیم چی می‌شه؟](#اگه-متد-constructor-رو-بیش-از-یه-بار-توی-کلاس-بنویسیم-چی-می‌شه) |  |
|257| [چطوری متد constructor کلاس والد رو صدا بزنیم؟](#چطوری-متد-constructor-کلاس-والد-رو-صدا-بزنیم) |  |
|258| [چطوری prototype یه object رو به دست میاری؟](#چطوری-prototype-یه-object-رو-به-دست-میاری) |  |
|259| [اگه به متد getPrototype رشته پاس بدیم چی می‌شه؟](#اگه-به-متد-getPrototype-رشته-پاس-بدیم-چی-می‌شه) |  |
|260| [چطوری prototype یه object روی یه object دیگه ست کنیم؟](#چطوری-prototype-یه-object-روی-یه-object-دیگه-ست-کنیم) |  |
|261| [چطوری بررسی می‌کنی که یه object قابل extend هست یا نه؟](#چطوری-بررسی-می‌کنی-که-یه-object-قابل-extend-هست-یا-نه) |  |
|262| [چطوری جلوی extend یه object رو بگیریم؟](#چطوری-جلوی-extend-یه-object-رو-بگیریم) |  |
|263| [روش‌های مختلف برای تبدیل یه object به object غیرقابل extend چیه؟](#روشهای-مختلف-برای-تبدیل-یه-object-به-object-غیرقابل-extend-چیه) |  |
|264| [چطوری propertyهای متعددی رو روی یه object تعریف می‌کنی؟](#چطوری-propertyهای-متعددی-رو-روی-یه-object-تعریف-می‌کنی) |  |
|265| [منظور از MEAN توی جاواسکریپت چیه؟ javascript](#منظور-از-MEAN-توی-جاواسکریپت-چیه-javascript) |  |
|266| [Obfuscation توی جاواسکریپت چیه و چیکار می‌کنه؟ javascript](#Obfuscation-توی-جاواسکریپت-چیه-و-چیکار-می‌کنه-javascript) |  |
|267| [چه نیازی به Obfuscate کردن داریم؟](#چه-نیازی-به-Obfuscate-کردن-داریم) |  |
|268| [Minification چیه؟](#Minification-چیه) |  |
|269| [مزایای minification یا کم حجم‌سازی چیه؟](#مزایای-minification-یا-کم-حجمسازی-چیه) |  |
|270| [تفاوت‌های بین Obfuscation و Encryption چیه؟](#تفاوتهای-بین-Obfuscation-و-Encryption-چیه) |  |
|271| [ابزارهای مختلف برای minification کدوما هستن؟](#ابزارهای-مختلف-برای-minification-کدوما-هستن) |  |
|272| [چطوری اعتبارسنجی فرم رو با javascript انجام میدی؟](#چطوری-اعتبارسنجی-فرم-رو-با-javascript-انجام-میدی) |  |
|273| [چطوری اعتبارسنجی فرم رو بدون javascript انجام میدی؟](#چطوری-اعتبارسنجی-فرم-رو-بدون-javascript-انجام-میدی) |  |
|274| [متدهای موجود روی DOM برای اعتبارسنجی کدوما هستن؟](#متدهای-موجود-روی-DOM-برای-اعتبارسنجی-کدوما-هستن) |  |
|275| [مقادیر موجود روی DOM برای اعتبارسنجی کدوما هستن؟](#مقادیر-موجود-روی-DOM-برای-اعتبارسنجی-کدوما-هستن) |  |
|276| [مقادیر موجود روی input برای اعتبارسنجی کدوما هستن؟](#مقادیر-موجود-روی-input-برای-اعتبارسنجی-کدوما-هستن) |  |
|277| [یه مثال از استفاده ویژگی rangeOverflow می‌تونی بزنی؟](#یه-مثال-از-استفاده-ویژگی-rangeOverflow-میتونی-بزنی) |  |
|278| [جاواسکریپت قابلیت استفاده از enum رو پیش‌فرض توی خودش داره؟](#جاواسکریپت-قابلیت-استفاده-از-enum-رو-پیشفرض-توی-خودش-داره) |  |
|279| [enum چیه؟](#enum-چیه) |  |
|280| [چطوری همه propertyهای یه object رو به دست بیاریم؟](#چطوری-همه-propertyهای-یه-object-رو-به-دست-بیاریم) |  |
|281| [چطوری get property descriptors of an object](#چطوری-get-property-descriptors-of-an-object) |  |
|282| [گزینه‌هایی که موقع تعریف ویژگی object با descriptor داریم کدوما هستن؟](#گزینههایی-که-موقع-تعریف-ویژگی-object-با-descriptor-داریم-کدوما-هستن) |  |
|283| [چطوری کلاس‌ها رو extend می‌کنی؟](#چطوری-کلاسها-رو-extend-می‌کنی) |  |
|284| [چطوری آدرس صفحه رو بدون رفرش صفحه عوض کنیم؟](#چطوری-آدرس-صفحه-رو-بدون-رفرش-صفحه-عوض-کنیم) |  |
|285| [چطوری بررسی می‌کنی که یه آرایه یه مقدار مشخص رو داره یا نه؟](#چطوری-بررسی-می‌کنی-که-یه-آرایه-یه-مقدار-مشخص-رو-داره-یا-نه) |  |
|286| [چطوری آرایه‌های scalar رو با هم مقایسه می‌کنی؟](#چطوری-آرایههای-scalar-رو-با-هم-مقایسه-می‌کنی) |  |
|287| [چطوری می‌شه پارامترهای صفحه رو از متد GET گرفت؟](#چطوری-می‌شه-پارامترهای-صفحه-رو-از-متد-GET-گرفت) |  |
|288| [چطوری اعداد رو می‌شه سه رقم سه رقم جدا کرد؟](#چطوری-اعداد-رو-می‌شه-سه-رقم-سه-رقم-جدا-کرد) |  |
|289| [تفاوت‌ بین java و javascript چیه؟](#تفاوت-بین-java-و-javascript-چیه) |  |
|290| [آیا جاواسکریپت namespace رو پشتیبانی می‌کنه؟](#آیا-جاواسکریپت-namespace-رو-پشتیبانی-می‌کنه) |  |
|291| [چطوری namespace تعریف می‌کنی؟](#چطوری-namespace-تعریف-می‌کنی) |  |
|292| [چطوری می‌تونیم تکه کد جاواسکریپت داخل یه iframe رو از صفحه والد صدا بزنیم؟](#چطوری-می‌تونیم-تکه-کد-جاواسکریپت-داخل-یه-iframe-رو-از-صفحه-والد-صدا-بزنیم) |  |
|293| [چطوری می‌شه اختلاف timezone رو از آبجکت date بگیریم؟](#چطوری-می‌شه-اختلاف-timezone-رو-از-آبجکت-date-بگیریم) |  |
|294| [چطوری فایل‌های CSS و JS رو به شکل داینامیک بارگذاری کنیم؟](#چطوری-فایلهای-CSS-و-JS-رو-به-شکل-داینامیک-بارگذاری-کنیم) |  |
|295| [روش‌های مختلف برای پیدا کردن elementها توی DOM کدوما هستن؟](#روشهای-مختلف-برای-پیدا-کردن-elementها-توی-DOM-کدوما-هستن) |  |
|296| [jQuery چیه؟](#jQuery-چیه) |  |
|297| [موتور V8 جاواسکریپت چیه؟](#موتور-V8-جاواسکریپت-چیه) |  |
|298| [چرا ما جاواسکریپت رو به عنوان یه زبان داینامیک می‌شناسیم؟](#چرا-ما-جاواسکریپت-رو-به-عنوان-یه-زبان-داینامیک-میشناسیم) |  |
|299| [عملگر void چیکار می‌کنه؟](#عملگر-void-چیکار-می‌کنه) |  |
|300| [چطوری می‌شه نمایشگر موس صفحه رو به درحال لود تغییر داد؟](#چطوری-می‌شه-نمایشگر-موس-صفحه-رو-به-درحال-لود-تغییر-داد) |  |
|301| [چطوری می‌شه یه حلقه بی‌نهایت درست کرد؟](#چطوری-می‌شه-یه-حلقه-بینهایت-درست-کرد) |  |
|302| [چرا باید در استفاده از عبارت with تجدیدنظر کرد؟](#چرا-باید-در-استفاده-از-عبارت-with-تجدیدنظر-کرد) |  |
|303| [خروجی این حلقه‌ها چی می‌شه؟](#خروجی-این-حلقهها-چی-می‌شه) |  |
|304| [می‌تونی یه سری از ویژگی‌های ES6 رو اسم ببری؟](#میتونی-یه-سری-از-ویژگیهای-ES6-رو-اسم-ببری) |  |
|305| [ES6 چیه؟](#ES6-چیه) |  |
|306| [آیا می‌تونیم متغیرهای تعریف شده با let و const رو مجددا declare کنیم؟](#آیا-می‌تونیم-متغیرهای-تعریف-شده-با-let-و-const-رو-مجددا-declare-کنیم) |  |
|307| [آیا استفاده از const برای تعریف متغیر اونا رو immutable می‌کنه؟](#آیا-استفاده-از-const-برای-تعریف-متغیر-اونا-رو-immutable-می‌کنه) |  |
|308| [parameterهای پیش‌فرض چی هستن؟](#parameterهای-پیشفرض-چی-هستن) |  |
|309| [template-literalها چی هستن؟](#template-literalها-چی-هستن) |  |
|310| [چطوری رشته‌های چند خطی رو توی template-literalها می‌نویسیم؟](#چطوری-رشتههای-چند-خطی-رو-توی-template-literalها-مینویسیم) |  |
|311| [template-literal‌های تودرتو چی هستن؟](#template-literalهای-تودرتو-چی-هستن) |  |
|312| [tagged-templateها چی هستن؟](#tagged-templateها-چی-هستن) |  |
|313| [رشته‌های خام چی هستن؟](#رشتههای-خام-چی-هستن) |  |
|314| [assign کردن با destructuring چیه و چطوری انجام می‌شه؟](#assign-کردن-با-destructuring-چیه-و-چطوری-انجام-می‌شه) |  |
|315| [موقع assign کردن با destructuring چطوری می‌شه مقدار اولیه تعریف کرد؟](#موقع-assign-کردن-با-destructuring-چطوری-می‌شه-مقدار-اولیه-تعریف-کرد) |  |
|316| [چطوری می‌تونیم مقدار یه آرایه رو با استفاده از destructuring-assignment تعویض کنیم؟](#چطوری-می‌تونیم-مقدار-یه-آرایه-رو-با-استفاده-از-destructuring-assignment-تعویض-کنیم) |  |
|317| [Enhanced-object-literalها چی هستن؟](#Enhanced-object-literalها-چی-هستن) |  |
|318| [importهای داینامیک چی هستن؟](#importهای-داینامیک-چی-هستن) |  |
|319| [کاربرد importهای داینامیک چیه؟](#کاربرد-importهای-داینامیک-چیه) |  |
|320| [آرایه‌های نوع‌دار(typed-arrays) چیه؟](#آرایههای-نوعدارtyped-arrays-چیه) |  |
|321| [مزایای لودر ماژول‌ها چیه؟](#مزایای-لودر-ماژولها-چیه) |  |
|322| [collation چیه؟](#collation-چیه) |  |
|323| [عبارت for...of چیه؟](#عبارت-forof-چیه) |  |
|324| [خروجی عملگر spread روی آرایه زیر چیه؟](#خروجی-عملگر-spread-روی-آرایه-زیر-چیه) |  |
|325| [آیا PostMessage امنه؟](#آیا-PostMessage-امنه) |  |
|326| [مشکلات استفاده از postmessage با origin روی wildcard چیه؟](#مشکلات-استفاده-از-postmessage-با-origin-روی-wildcard-چیه) |  |
|327| [چطوری از دریافت postMessageهای ناخواسته و ناامن از طرف هکرها جلوگیری کنیم؟](#چطوری-از-دریافت-postMessageهای-ناخواسته-و-ناامن-از-طرف-هکرها-جلوگیری-کنیم) |  |
|328| [می‌تونیم کلا postMessageها رو غیرفعال کنیم؟](#می‌تونیم-کلا-postMessageها-رو-غیرفعال-کنیم) |  |
|329| [آیا postMessageها به صورت synchronous و همزمان کار می‌کنن؟](#آیا-postMessageها-به-صورت-synchronous-و-همزمان-کار-میکنن) |  |
|330| [پارادیم زبان جاواسکریپت چیه؟](#پارادیم-زبان-جاواسکریپت-چیه) |  |
|331| [تفاوت‌های بین جاواسکریپت داخلی و خارجی چیه؟](#تفاوتهای-بین-جاواسکریپت-داخلی-و-خارجی-چیه) |  |
|332| [آیا جاواسکریپت سریعتر از اسکریپت‌های سمت سرور است؟](#آیا-جاواسکریپت-سریعتر-از-اسکریپتهای-سمت-سرور-است) |  |
|333| [چطوری وضعیت چک بودن یه checkbox رو بدست بیاریم؟](#چطوری-وضعیت-چک-بودن-یه-checkbox-رو-بدست-بیاریم) |  |
|334| [هدف از عملگر double-tilde چیه؟](#هدف-از-عملگر-double-tilde-چیه) |  |
|335| [چطوری یه کاراکتر رو به کد ASCII تبدیل کنیم؟](#چطوری-یه-کاراکتر-رو-به-کد-ASCII-تبدیل-کنیم) |  |
|336| [ArrayBuffer چیه؟](#ArrayBuffer-چیه) |  |
|337| [خروجی کد زیر چی خواهد بود؟](#خروجی-کد-زیر-چی-خواهد-بود) |  |
|338| [هدف از Error-object چیه؟](#هدف-از-Error-object-چیه) |  |
|339| [هدف از EvalError-object چیه؟](#هدف-از-EvalError-object-چیه) |  |
|340| [خطاهایی که در حالت strict-mode رخ میدن ولی در غیر اون وجود ندارن کدوما هستن؟](#خطاهایی-که-در-حالت-strict-mode-رخ-میدن-ولی-در-غیر-اون-وجود-ندارن-کدوما-هستن) |  |
|341| [آیا همه objectها دارای prototype هستن؟](#آیا-همه-objectها-دارای-prototype-هستن) |  |
|342| [تفاوت‌های بین parameter و argument چیه؟](#تفاوتهای-بین-parameter-و-argument-چیه) |  |
|343| [هدف از متد some روی آرایه‌ها چیه؟](#هدف-از-متد-some-روی-آرایهها-چیه) |  |
|344| [چطوری دو یا تعداد بیشتری از آرایه‌ها رو با هم ترکیب کنیم؟](#چطوری-دو-یا-تعداد-بیشتری-از-آرایهها-رو-با-هم-ترکیب-کنیم) |  |
|345| [تفاوت‌های بین Shallow و Deep کپی چیه؟](#تفاوتهای-بین-Shallow-و-Deep-کپی-چیه) |  |
|346| [چطوری می‌تونیم به یه تعداد مشخص از یه رشته کپی کنیم؟](#چطوری-می‌تونیم-به-یه-تعداد-مشخص-از-یه-رشته-کپی-کنیم) |  |
|347| [چطوری همه stringهای match شده با یه regular-expression رو برگردونیم؟](#چطوری-همه-stringهای-match-شده-با-یه-regular-expression-رو-برگردونیم) |  |
|348| [چطوری یه رشته رو از اول یا از آخر trim کنیم؟](#چطوری-یه-رشته-رو-از-اول-یا-از-آخر-trim-کنیم) |  |
|349| [خروجی کنسول زیر با عملگر unary چی می‌شه؟](#خروجی-کنسول-زیر-با-عملگر-unary-چی-می‌شه) |  |
|350| [آیا جاواسکریپت از mixinها استفاده می‌کنه؟](#آیا-جاواسکریپت-از-mixinها-استفاده-می‌کنه) |  |
|351| [تابع thunk چیه و چیکار می‌کنه؟](#تابع-thunk-چیه-و-چیکار-می‌کنه) |  |
|352| [thunkهای asynchronous چیکار می‌کنن؟](#thunkهای-asynchronous-چیکار-میکنن) |  |
|353| [خروجی فراخوانی‌های توابع زیر چی می‌شه؟](#خروجی-فراخوانیهای-توابع-زیر-چی-می‌شه) |  |
|354| [چطوری همه خطوط جدید رو از یه رشته حذف کرد؟](#چطوری-همه-خطوط-جدید-رو-از-یه-رشته-حذف-کرد) |  |
|355| [تفاوت‌ بین reflow و repaint چیه؟](#تفاوت-بین-reflow-و-repaint-چیه) |  |
|356| [اگه قبل از یه آرایه عملگر نفی «!» بزاریم چی می‌شه؟](#اگه-قبل-از-یه-آرایه-عملگر-نفی-«!»-بزاریم-چی-می‌شه) |  |
|357| [اگه دو تا آرایه رو با هم جمع ببندیم چی می‌شه؟](#اگه-دو-تا-آرایه-رو-با-هم-جمع-ببندیم-چی-می‌شه) |  |
|358| [اگه عملگر جمع «+» روی قبل از مقادیر falsy قرار بدیم چی می‌شه؟](#اگه-عملگر-جمع-«+»-روی-قبل-از-مقادیر-falsy-قرار-بدیم-چی-می‌شه)   ||
|359| [چطوری با استفاده از آرایه‌ها و عملگرهای منطقی می‌تونیم رشته self رو تولید کنیم؟](#چطوری-با-استفاده-از-آرایهها-و-عملگرهای-منطقی-می‌تونیم-رشته-self-رو-تولید-کنیم) |  |
|360| [چطوری می‌تونیم مقادیر falsy رو از آرایه حذف کنیم؟](#چطوری-می‌تونیم-مقادیر-falsy-رو-از-آرایه-حذف-کنیم) |  |
|361| [چطوری مقادیر تکراری رو از یه آرایه حذف کنیم؟](#چطوری-مقادیر-تکراری-رو-از-یه-آرایه-حذف-کنیم) |  |
|362| [aliaseهای همزمان با destructuring چطوری کار می‌کنن؟](#aliaseهای-همزمان-با-destructuring-چطوری-کار-میکنن) |  |
|363| [چطوری آیتم‌های یه آرایه رو بدون استفاده از متد map پیمایش کنیم؟](#چطوری-آیتمهای-یه-آرایه-رو-بدون-استفاده-از-متد-map-پیمایش-کنیم) |  |
|364| [چطوری یه آرایه رو خالی کنیم؟](#چطوری-یه-آرایه-رو-خالی-کنیم) |  |
|365| [چطوری اعداد رو با تعداد رقم اعشار مشخص رند می‌کنی؟](#چطوری-اعداد-رو-با-تعداد-رقم-اعشار-مشخص-رند-می‌کنی) |  |
|366| [ساده‌ترین روش برای تبدیل آرایه به object چیه؟](#سادهترین-روش-برای-تبدیل-آرایه-به-object-چیه) |  |
|367| [چطوری یه آرایه با یه سری داده درست کنیم؟](#چطوری-یه-آرایه-با-یه-سری-داده-درست-کنیم) |  |
|368| [متغیرهای موجود روی آبجکت console کدوما هستن؟](#متغیرهای-موجود-روی-آبجکت-console-کدوما-هستن) |  |
|369| [می‌شه پیام‌های کنسول رو استایل‌دهی کرد؟](#می‌شه-پیامهای-کنسول-رو-استایلدهی-کرد) |  |
|370| [هدف از متد dir روی آبجکت console چیه؟](#هدف-از-متد-dir-روی-آبجکت-console-چیه) |  |
|371| [آیا می‌شه المنت‌های HTML رو توی console دیباگ کرد؟](#آیا-می‌شه-المنتهای-HTML-رو-توی-console-دیباگ-کرد) |  |
|372| [چطوری می‌شه داده‌ها رو به شکل جدولی توی console نمایش بدیم؟](#چطوری-می‌شه-دادهها-رو-به-شکل-جدولی-توی-console-نمایش-بدیم) |  |
|373| [چطوری می‌شه بررسی کرد که یه پارامتر Number هست یا نه؟](#چطوری-می‌شه-بررسی-کرد-که-یه-پارامتر-Number-هست-یا-نه) |  |
|374| [چطوری یه متن رو می‌تونیم به clipboard کپی کنیم؟](#چطوری-یه-متن-رو-می‌تونیم-به-clipboard-کپی-کنیم) |  |
|375| [چطوری می‌شه timestamp رو بدست آورد؟](#چطوری-می‌شه-timestamp-رو-بدست-آورد) |  |
|376| [چطوری یه آرایه چندسطحی رو تک سطحی کنیم؟](#چطوری-یه-آرایه-چندسطحی-رو-تک-سطحی-کنیم) |  |
|377| [ساده‌ترین روش برای بررسی چندشرطی چیه؟](#سادهترین-روش-برای-بررسی-چندشرطی-چیه) |  |
|378| [چطوری کلیک روی دکمه برگشت مرورگر رو متوجه بشیم؟](#چطوری-کلیک-روی-دکمه-برگشت-مرورگر-رو-متوجه-بشیم) |  |
|379| [چطوری می‌تونیم کلیک راست رو غیرفعال کنیم؟](#چطوری-می‌تونیم-کلیک-راست-رو-غیرفعال-کنیم) |  |
|380| [object-wrapperها چی هستن؟](#object-wrapperها-چی-هستن) |  |
|381| [AJAX چیه؟](#AJAX-چیه) |  |
|382| [روش‌های مختلف مدیریت یه کد Asynchronous چیه؟](#روشهای-مختلف-مدیریت-یه-کد-Asynchronous-چیه) |  |
|383| [چطوری یه درخواست fetch رو کنسل کنیم؟](#چطوری-یه-درخواست-fetch-رو-کنسل-کنیم) |  |
|384| [Speech-API چیه؟](#Speech-API-چیه) |  |
|385| [حداقل timeout توی throttling چقدره؟](#حداقل-timeout-توی-throttling-چقدره) |  |
|386| [چطوری می‌شه یه timeout صفر توی مرورگر اجرا کرد؟](#چطوری-می‌شه-یه-timeout-صفر-توی-مرورگر-اجرا-کرد) |  |
|387| [taskها توی event-loop چی هستن؟](#taskها-توی-event-loop-چی-هستن) |  |
|388| [microtaskها چی هستن؟](#microtaskها-چی-هستن) |  |
|389| [event-loopهای مختلف کدوما هستن؟](#event-loopهای-مختلف-کدوما-هستن) |  |
|390| [هدف از queueMicrotask چیه؟](#هدف-از-queueMicrotask-چیه) |  |
|391| [چطوری می‌شه از کتابخونه‌های جاواسکریپت توی فایل typescript استفاده کرد؟](#چطوری-می‌شه-از-کتابخونههای-جاواسکریپت-توی-فایل-typescript-استفاده-کرد) |  |
|392| [تفاوت‌های بین promiseها و observableها کدوما هستن؟](#تفاوتهای-بین-promiseها-و-observableها-کدوما-هستن) |  |
|393| [heap چیه؟](#heap-چیه) |  |
|394| [event-table چیه؟](#event-table-چیه) |  |
|395| [صف microTask چیه؟](#صف-microTask-چیه) |  |
|396| [تفاوت بین shim و polyfill چیه؟](#تفاوت-بین-shim-و-polyfill-چیه) |  |
|397| [چطوری متوجه primitive یا غیر primitive بودن یه نوع داده میشیم؟](#چطوری-متوجه-primitive-یا-غیر-primitive-بودن-یه-نوع-داده-میشیم) |  |
|398| [babel چیه؟](#babel-چیه) |  |
|399| [آیا Node.js به شکل کامل تک thread کار می‌کنه؟](#آیا-Nodejs-به-شکل-کامل-تک-thread-کار-می‌کنه) |  |
|400| [کاربردهای مرسوم observableها کدوما هستن؟](#کاربردهای-مرسوم-observableها-کدوما-هستن) |  |
|401| [RxJS چیه؟](#RxJS-چیه) |  |
|402| [تفاوت بین Function-constructor و function-declaration چیه؟](#تفاوت-بین-Function-constructor-و-function-declaration-چیه) |  |
|403| [شرط Short-circuit یا اتصال کوتاه چیه؟](#شرط-Short-circuit-یا-اتصال-کوتاه-چیه) |  |
|404| [ساده‌ترین روش برای تغییر سایز یه آرایه چیه؟](#سادهترین-روش-برای-تغییر-سایز-یه-آرایه-چیه) |  |
|405| [observable چیه؟](#observable-چیه) |  |
|406| [تفاوت‌های بین توابع و کلاس‌ها چیه؟](#تفاوتهای-بین-توابع-و-کلاسها-چیه) |  |
|407| [تابع async چیه؟](#تابع-async-چیه) |  |
|408| [چطوری خطاهای ایجاد شده هنگام استفاده از promiseها رو کنترل کنیم؟](#چطوری-خطاهای-ایجاد-شده-هنگام-استفاده-از-promiseها-رو-کنترل-کنیم) |  |
|409| [Deno چیه؟](#Deno-چیه) |  |
|410| [توی جاواسکریپت چطوری یه object قابل پیمایش درست کنیم؟](#توی-جاواسکریپت-چطوری-یه-object-قابل-پیمایش-درست-کنیم) |  |
|411| [روش مناسب برای فراخوانی توابع بازگشتی چیه؟](#روش-مناسب-برای-فراخوانی-توابع-بازگشتی-چیه) |  |
|412| [چطوری بررسی کنیم که یه آبجکت promise هست یا نه؟](#چطوری-بررسی-کنیم-که-یه-آبجکت-promise-هست-یا-نه) |  |
|413| [چطوری متوجه بشیم که یا تابع با تابع constructor صدا زده شده یا نه؟](#چطوری-متوجه-بشیم-که-یا-تابع-با-تابع-constructor-صدا-زده-شده-یا-نه) |  |
|414| [تفاوت‌های بین آبجکت argument و پارامتر rest چیه؟](#تفاوتهای-بین-آبجکت-argument-و-پارامتر-rest-چیه) |  |
|415| [تفاوت‌های بین عملگر spread و پارامتر rest چیه؟](#تفاوتهای-بین-عملگر-spread-و-پارامتر-rest-چیه) |  |
|416| [نوع‌های مختلف generatorها کدوما هستن؟](#نوعهای-مختلف-generatorها-کدوما-هستن) |  |
|417| [iterableهای built-in کدوما هستن؟](#iterableهای-built-in-کدوما-هستن) |  |
|418| [تفاوت‌های بین حلقه for...of و for...in چیه؟](#تفاوتهای-بین-حلقه-forof-و-forin-چیه) |  |
|419| [چطوری propertyهای instance و غیر instanceای تعریف می‌کنی؟](#چطوری-propertyهای-instance-و-غیر-instanceای-تعریف-می‌کنی) |  |
|420| [تفاوت‌های بین isNaN و Number.isNaN کدوما هستن؟](#تفاوتهای-بین-isNaN-و-NumberisNaN-کدوما-هستن) |  |

{Pishgoftar}

<div dir="rtl" align="right">

1. ### روش‌های ایجاد objects توی جاواسکریپت چیا هستن؟


     1. **سازنده آبجکت:**

     ساده‌ترین راه برای ایجاد یه آبجکت خالی استفاده از سازنده آبجکت هستش. در حال حاضر این روش توصیه نمی‌شه

     <span dir="ltr" align="left">

     ```javascript
     var object = new Object();
     ```

     </span>

     2. **متد ایجاد آبجکت:**

     متد ایجاد آبجکت با انتقال نمونه اولیه آبجکت به عنوان یه پارامتر، یه آبجکت جدید ایجاد می‌کنه

     <span dir="ltr" align="left">

     ```javascript
     var object = Object.create(null);
     ```

     </span>


     3. **Object literal syntax:**

     The object literal syntax is equivalent to create method when it passes null as parameter

     <span dir="ltr" align="left">

     ```javascript
     var object = {};
     ```

     </span>


     4. **سازنده تابع:**

     هر تابعی که بخوایم رو ایجاد می‌کنیم و از طریق عملگر new یه نمونه آبجکت جدید می‌سازیم.

     <span dir="ltr" align="left">

     ```javascript
     function Person(name){
      var object = {};
      object.name=name;
      object.age=21;
      return object;
     }
     var object = new Person("Sudheer");
     ```

     </span>


     5. **سازنده تابع با نمونه اولیه؛**

     شبیه سازنده تابع هستش اما از نمونه اولیه برای متد‌ها و خصوصیاتشون استفاده می‌کنه

     <span dir="ltr" align="left">

     ```javascript
     function Person(){}
     Person.prototype.name = "Sudheer";
     var object = new Person();
     ```

     </span>

     این معادل نمونه‌ای هستش که با متد ایجاد آبجکت با نمونه اولیه تابع ایجاد شده و تابع رو با یه نمونه و پارامتر‌هاش به عنوان آرگومان فراخوانی می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     function func {};

     new func(x, y, z);
     ```

     </span>


     **(یا)**

     <span dir="ltr" align="left">

     ```javascript
     // Create a new instance using function prototype.
     var newInstance = Object.create(func.prototype)

     // Call the function
     var result = func.call(newInstance, x, y, z),

     // If the result is a non-null object then use it otherwise just use the new instance.
     console.log(result && typeof result === 'object' ? result : newInstance);
     ```

     </span>


     6. **ES6 Class syntax:**

     ES6 ویژگی‌های کلاس رو برای ایجاد آبجکت‌ها معرفی می‌کنه

     <span dir="ltr" align="left">

     ```javascript
     class Person {
          constructor(name) {
          this.name = name;
          }
     }

     var object = new Person("Sudheer");
     ```

     </span>


     7. **الگوی Singleton:**

     Singleton آبجکت‌ای‌ـه که فقط یه بار قابل نمونه‌گیری هستش. فراخوانی‌های پی در پی با سازنده‌ش همون نمونه رو برمی‌گردونه و اینطوری می‌شه مطمئن شد که به طور تصادفی نمونه‌های مختلف ایجاد نمی‌شه.

     <span dir="ltr" align="left">

     ```javascript
     var object = new function(){
          this.name = "Sudheer";
     }
     ```

     </span>


      **[فهرست](#فهرست)**

2. ### زنجیره prototype چیه؟

     **زنجیره prototype** برای ساخت انواع جدیدی از آبجکت‌ها بر‌اساس موارد موجود استفاده می‌شه. این کار شبیه ارث بری توی یه زبان مبتنی بر کلاس هستش. prototype روی نمونه آبجکت از طریق ویژگی **Object.getPrototypeOf(object)** یا **__proto__** در دسترسه در حالی که نمونه اولیه توی عملکرد سازنده‌ها از طریق object.prototype در دسترسه.

     ![Screenshot](images/prototype_chain.png)

     **[فهرست](#فهرست)**

3. ### تفاوت‌های بین Call، Apply و Bind چیا هستن؟


     **Call:** متد call یه تابع با یه مقدار `this` و آرگومان‌های ارائه شده رو دونه دونه فراخوانی می‌کنه

     <span dir="ltr" align="left">

     ```javascript
     var employee1 = {firstName: 'John', lastName: 'Rodson'};
     var employee2 = {firstName: 'Jimmy', lastName: 'Baily'};

     function invite(greeting1, greeting2) {
        console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName+ ', '+ greeting2);
     }

     invite.call(employee1, 'Hello', 'How are you?'); // Hello John Rodson, How are you?
     invite.call(employee2, 'Hello', 'How are you?'); // Hello Jimmy Baily, How are you?
     ```

     </span>


     **Apply:** تابع رو فراخوانی می‌کنه و بهمون اجازه میده تا آرگومان‌ها رو به عنوان یه آرایه منتقل کنیم


     <span dir="ltr" align="left">

     ```javascript
     var employee1 = {firstName: 'John', lastName: 'Rodson'};
     var employee2 = {firstName: 'Jimmy', lastName: 'Baily'};

     function invite(greeting1, greeting2) {
        console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName+ ', '+ greeting2);
     }

     invite.apply(employee1, ['Hello', 'How are you?']); // Hello John Rodson, How are you?
     invite.apply(employee2, ['Hello', 'How are you?']); // Hello Jimmy Baily, How are you?
     ```

     </span>


     **bind:** یه تابع جدید برمی‌گردونه، در حالی که بهمون اجازه میده هر تعداد آرگومانی که می خوایم رو توی یه آرایه منتقل کنیم

     <span dir="ltr" align="left">

     ```javascript
     var employee1 = {firstName: 'John', lastName: 'Rodson'};
     var employee2 = {firstName: 'Jimmy', lastName: 'Baily'};

     function invite(greeting1, greeting2) {
        console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName+ ', '+ greeting2);
     }

     var inviteEmployee1 = invite.bind(employee1);
     var inviteEmployee2 = invite.bind(employee2);
     inviteEmployee1('Hello', 'How are you?'); // Hello John Rodson, How are you?
     inviteEmployee2('Hello', 'How are you?'); // Hello Jimmy Baily, How are you?
     ```

     </span>


     `Call` و `Apply` تقریباً قابل تعویض هستن. هر دو بلافاصله تابع فعلی رو اجرا می‌کنن. شما باید تصمیم بگیرید که ارسال آرایه در آرایه آسون تره یا فهرستی از آرگومان‌های جدا شده با کاما. می‌تونین به خاطر داشته باشیم که Call برای کاما (فهرست جدا شده) و Apply برای Array اس. در حالی که Bind یه تابع جدید ایجاد می‌کنه که «this» روی اولین پارامتر ارسال شده به «bind» تنظیم می‌شه.

     **[فهرست](#فهرست)**

4. ### فرمت JSON چیه و عملیات‌های معمول بر روی آن چیا هستن؟

     **JSON** یه قالب داده مبتنی برمتن هستش که از نحو آبجکت جاوا‌اسکریپت (javascript objext syntax) پیروی می‌کنه و توسط ‍‍`Douglas Crockford` رایج شد. کاربردش زمانیه که بخوایم داده‌ها رو از طریق شبکه انتقال بدیم و اساسا یه فایل متنی با پسوند .json و نوع MIME از application/json
     **تجزیه (Parsing):** تبدیل یه رشته به یه آبجکت محلی (native Object)

     <span dir="ltr" align="left">

     ```javascript
     JSON.parse(text)
     ```

     </span>


     **رشته‌سازی:** تبدیل یه آبجکت محلی به یه رشته تا بتونه از طریق شبکه منتقل بشه


     <span dir="ltr" align="left">

     ```javascript
     JSON.stringify(object)
     ```

     </span>


     **[فهرست](#فهرست)**

4. ### هدف از متد slice روی آرایه‌ها چیه؟

     متد **slice** عناصر انتخاب شده توی یه آرایه رو به عنوان یه آبجکت آرایه جدید برمی‌گردونه. این عناصر رو از اولین آرگومان داده شده انتخاب می‌کنه و با آرگومان پایانی و اختیاری داده شده بدون در نظر گرفتن آخرین عنصر به پایان می‌رسونه. اگه آرگومان دوم رو حذف کنیم تا آخر آرایه همه عناصر رو انتخاب می‌کنه. چند تا مثال در مورد این متد اینجا نوشته شده

     <span dir="ltr" align="left">

     ```javascript
     let arrayIntegers = [1, 2, 3, 4, 5];
     let arrayIntegers1 = arrayIntegers.slice(0,2); // returns [1,2]
     let arrayIntegers2 = arrayIntegers.slice(2,3); // returns [3]
     let arrayIntegers3 = arrayIntegers.slice(4); //returns [5]
     ```

     </span>


     **نکته:** متد Slice‌ آرایه اصلی رو تغییر نمیده ولی یه زیر‌مجموعه به عنوان یه آرایه جدید برمی‌گردونه

     **[فهرست](#فهرست)**

5. ### هدف از متد splice روی آرایه‌ها چیه؟

     متد**splice** برای اضافه کردن به آرایه یا حذف از اون استفاده می‌شه و مورد حذف شده رو برمی‌گردونه. آرگومان اول موقعیت آرایه رو برای درج یا حذف مشخص می‌کنه در حالی که آرگومان اختیاری دوم تعداد عناصر حذف شده رو مشخص می‌کنه. هر آرگومان اضافه‌ای به آرایه اضافه می‌شه. چند تا مثال در این مورد اینجا نوشته شده.


     <span dir="ltr" align="left">

     ```javascript
     let arrayIntegersOriginal1 = [1, 2, 3, 4, 5];
     let arrayIntegersOriginal2 = [1, 2, 3, 4, 5];
     let arrayIntegersOriginal3 = [1, 2, 3, 4, 5];

     let arrayIntegers1 = arrayIntegersOriginal1.splice(0,2); // returns [1, 2]; original array: [3, 4, 5]
     let arrayIntegers2 = arrayIntegersOriginal2.splice(3); // returns [4, 5]; original array: [1, 2, 3]
     let arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, "a", "b", "c"); //returns [4]; original array: [1, 2, 3, "a", "b", "c", 5]
     ```

     </span>


     **نکته:** متد Splice آرایه اصلی رو اصلاح می‌کنه و آرایه حذف شده رو برمی‌گردونه.

     **[فهرست](#فهرست)**

6. ### تفاوت متدهای slice و splice چیا هستن؟


     | Slice | Splice |
     |---- | --------- |
     | آرایه اصلی رو تغییر نمیده (تغییرناپذیر)  | آرایه اصلی رو تغییر میده (تغییر پذیر) |
     | زیر مجموعه آرایه اصلی رو برمی‌گردونه | عناصر حذف شده رو به عنوان آرایه برمی گردونه  |
     | برای انتخاب عناصر از آرایه استفاده می‌شه | برای درج عناصر به آرایه یا حذف از اون استفاده می‌شه|

     **[فهرست](#فهرست)**

7. ### تفاوت‌های Object و Map چیا هستن؟

     **آبجکت‌ها** شبیه به **نقشه‌ها (Maps)** هستن از این جهت که هردو بهمون این امکتن رو میدن که کلید‌ها رو روی مقادیر تنظیم کنیم، مقادیر رو بازیابی کنیم، کلید‌ها رو حذف کنیم و ببینیم چیزی توی یه کلید ذخیره شده یا نه. به همین دلیل از آبجکت‌ها به عنوان نقشه‌ها (Maps) در طول تاریخ استفاده شده. اما تفاوت‌های مهمی وجود داره که استفاده از نقشه (map) رو توی موارد خاص ترجبح میده.

     1. کلید‌های یه آبجکت رشته‌ها و نماد‌ها هستن، در حالی که برای نقشه مقادیر مختلفی میتونه وجود داشته باشه که شامل توابع، آبجکت‌ها و هر نوع اولیه دیگه‌ای می‌شه.
     2. کلید‌های نقشه (map) مرتب میشن در حالی که کلید‌های اضافه شده به آبجکت اینطوری نیستن. بنابراین موقع تکرار روی اون، object map کلیدها رو به ترتیب اضافه شدنشون برمی‌گردونه.
     3. اندازه map رو می‌تونیم به راحتی با ویژگی سایز بدست بیاریم، در حالی که تعداد خصوصیات یه آبجکت باید به صورت دستی حساب بشه.
     4. نقشه قابل تکراره و میتونه مستقیما تکرار بشه، در حالی که تکرار روی یه آبجکت مستلزم بدست آوردن کلیدهای اون به روشی خاص و تکرار روی اونهاست.
     5. آبجکت یه نمونه اولیه (prototype) داره، بنابراین کلید‌های پیش‌فرض توی map وجود داره که که اگه دقت نکنیم ممکنه با کلید‌هامون برخورد کنه. از زمان ES5 می‌تونیم با استفاده از map = Object.create(null)، این قضیه رو دور بزنیم ولی به‌ندرت این کار انجام می‌شه.
     6. نقشه ممکنه توی سناریوهای شامل جمع و حذف مکرر جفت کلیدها عملکرد بهتری داشته باشه

     **[فهرست](#فهرست)**

8. ### تفاوت‌های بین عملگرهای == و === چیا هستن؟

     جاواسکریپت مقایسه برابری سخت (===، !==) و تبدیل نوع (==، !=) رو فراهم می‌کنه. عملگرهای سختگیرانه نوع متغیر رو در نظر می‌گیرند، در حالی که عملگرهای غیر دقیق، اصلاح/تبدیل نوع رو بر اساس مقادیر متغیرها انجام می دهند. اپراتورهای سختگیر از شرایط زیر برای انواع مختلف پیروی می‌کنن.
     1. دو رشته زمانی کاملاً برابر هستن که توالی کاراکترهای یکسان، طول یکسان و کاراکترهای مشابه در موقعیت‌های متناظر داشته باشن.
     2. دو عدد زمانی که از نظر عددی مساوی باشن کاملاً برابر هستند. یعنی داشتن مقدار عددی یکسان.
      دو مورد خاص در این مورد وجود داره،
     1. NaN با هیچ چیز از جمله NaN برابر نیست.
     2. صفرهای مثبت و منفی با هم برابرند.
     3. اگه هر دو درست یا نادرست باشن، دو عملوند بولین کاملاً برابر هستند.
     4. اگه دو شیء به یه شیء اشاره کنن کاملاً برابر هستند.
     5. انواع Null و Undefined با === برابر نیستن، بلکه با == برابر هستند. یعنی
     null===undefined --> false اما null==undefined --> true

     بعضی از مثال‌هایی که موارد بالا رو پوشش میده،

     <span dir="ltr" align="left">

     ```javascript
     0 == false   // true
     0 === false  // false
     1 == "1"     // true
     1 === "1"    // false
     null == undefined // true
     null === undefined // false
     '0' == false // true
     '0' === false // false
     []==[] or []===[] //false, refer different objects in memory
     {}=={} or {}==={} //false, refer different objects in memory
     ```

     </span>


     **[فهرست](#فهرست)**

9. ### توابع lambda یا arrow-function چی هستن؟

     arrow function ‌ها به صورت ساده‌تر و کوتاه‌تر تعریف میشن و **this، argumants، super یا new.target** ندارن. این توابع بدون متد هستند و به عنوان سازنده یا constructor استفاده نمیشن.

     **[فهرست](#فهرست)**

10. ### یه تابع first-class چجور تابعی‌ـه؟

     توی جاوااسکریپت، توابع آبجکت‌های کلاس اول یا first class هستن. توابع کلاس اول زمانی معنی میدن که توابع توی اون زبان باهاشون مثل بقیه متغیر‌ها رفتار بشه.

     برای مثال، توی چنین زبانی، یه تابع میتونه به عنوان آرگومان به یه تابع دیگه انتقال داده بشه، میتونه به عنوان مقدار نهایی یه تابع دیگه برگشت داده بشه و میتونه به یه متغیر دیگه به عنوان مقدار اختصاص داده بشه. برای مثال توی کد زیر، توابع نگهدارنه یا handler به یه شنونده یا listener اختصاص داده شده.

     <span dir="ltr" align="left">

     ```javascript
     const handler = () => console.log ('This is a click handler function');
     document.addEventListener ('click', handler);
     ```

     </span>

     **[فهرست](#فهرست)**

11. ### یه تابع first-order چجور تابعی‌ـه؟

     تابع مرتبه اول یا first-order تابعیه که هیچ تابع دیگه‌ای رو به عنوان آرگومان قبول نمی‌کنه و هیچ تابعی رو هم به عنوان مقدار برگشتی یا return value برنمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     const firstOrder = () => console.log ('I am a first order function!');
     ```

     </span>


     **[فهرست](#فهرست)**

12. ### یه تابع higher-order چجور تابعی‌ـه؟

     توابع مرتبه بالا توابعی هستن که یه تابع رو به عنوان پارامتر ورودی دریافت و یا به عنوان خروجی ارسال میکنن.


     <span dir="ltr" align="left">

     ```javascript
     const firstOrderFunc = () => console.log ('Hello I am a First order function');
     const higherOrder = ReturnFirstOrderFunc => ReturnFirstOrderFunc ();
     higherOrder (firstOrderFunc);
     ```

     </span>


     **[فهرست](#فهرست)**

13. ### یه تابع unary چجور تابعی‌ـه؟

     تابع unary تابعیه که فقط یه آرگومان ورودی دریافت می‌کنه. بیاین یه مثال از توابع unary بزنیم.

     <span dir="ltr" align="left">

     ```javascript
     // Add 10 to the given argument and display the value
     const unaryFunction = a => {
          console.log (a + 10); 
     };
     ```

     </span>


     **[فهرست](#فهرست)**

14. ### currying توابع یعنی چی؟

     به فرایندی که در اون یه تابع با چندین آرگومان رو به مجموعه‌ای از توابع که فقط یه آرگومان دریافت میکنن، تبدیل کنیم currying می‌گیم. Currying از نام یه ریاضی‌دان به اسم Haskell Curry گرفته شده. با استفاده از Currying در واقع یه تابع رو به یه تابع unary تبدیل می‌کنیم. بیاین یه مثال از یه تابع با چندین آرگومان و تبدیلش به تابع currying بزنیم.


     <span dir="ltr" align="left">

     ```javascript
     const multiArgFunction = (a, b, c) => a + b + c;
     const curryUnaryFunction = a => b => c => a + b + c;
     curryUnaryFunction (1); // returns a function: b => c =>  1 + b + c
     curryUnaryFunction (1) (2); // returns a function: c => 3 + c
     curryUnaryFunction (1) (2) (3); // returns the number 6
     ```

     </span>


     توابع Curried برای بهبود قابلیت استفاده مجدد کد و ترکیب عملکردی عالی هستن.

     **[فهرست](#فهرست)**

15. ### چه توابعی pure هستن؟

     **تابع خالص** تابعیه که مقدار برگشتیش فقط توسط آرگومان‌هاش تعیین می‌شه بدون هیج side effect یا عوارض جانبی. برای مثال اگه ما یه تابع رو n بار در n جای مختلف برنامه فراخوانی کنیم همی‌شه یه مقدار مشخص برگشت داده می‌شه. بیاین یه مثال از تفاوت بین توابع خالص و توابع ناخالص بزنیم.


     <span dir="ltr" align="left">

     ```javascript
     //Impure
     let numberArray = [];
     const impureAddNumber = number => numberArray.push (number);
     //Pure
     const pureAddNumber = number => argNumberArray =>
          argNumberArray.concat ([number]);

     //Display the results
     console.log (impureAddNumber (6)); // returns 1
     console.log (numberArray); // returns [6]
     console.log (pureAddNumber (7) (numberArray)); // returns [6, 7]
     console.log (numberArray); // returns [6]
     ```

     </span>

     بر اساس تکه کدهای بالا، تابع push با تغییر روی آرایه و برگردوندن شماره ایندکس push که مستقل از مقدار پارامتر هستش، یه تابع ناخالص به حساب میاد. در حالی که از یه طرف متد concat آرایه رو می‌گیره و اونو با یه آرایه دیگه ترکیب می‌کنه و یه آرایه کاملا جدید و بدون هیچ عوارض جانبی تولید می‌کنه. همچنین مقدار برگشتی با آرایه قبلی ترکیب شده هستش.
     به یاد داشته باشیم که توابع خالص مهم هستند چون اونا تست واحد رو بدون هیچ گونه عوارض جانبی و بدون نیاز به تزریق وابستگی ساده می‌کنن. اونا همچنین از اتصال محکم جلوگیری می‌کنن و با نداشتن عوارض جانبی، شکستن برنامه شما رو سخت تر می‌کنن. این اصول در کنار هم قرار می‌گیرند **تغییرناپذیری** مفهوم ES6 با ارجحیت به **const** نسبت به استفاده **let**.

     **[فهرست](#فهرست)**

16. ### هدف از کلمه کلیدی let چیه؟

     دستور `let` یه **متغیر محلی block scope** تعریف می‌کنه. از این رو متغیر‌هایی که با کلمه کلیدی let تعریف میشن محدود به همون اسکوپی که توش تعریف شدن، دستورها و عبارت‌های توی همون اسکوپ میشن. درحالی که متغیر‌های تعریف شده با کلمه کلیدی var برای تعریف یه متغیر توی سطح global یا محلی برای استفاده در کل توابع بدون در نظر گرفتن اسکوپی که توش تعریف شده، استفاده می‌شه. بیاین برای نشون دادن کاربردش یه مثال بزنیم.

     <span dir="ltr" align="left">

     ```javascript
     let counter = 30;
     if (counter === 30) {
          let counter = 31;
          console.log(counter); // 31
     }
     console.log(counter); // 30 (because if block variable won't exist here)
     ```

     </span>


     **[فهرست](#فهرست)**

17. ### تفاوت‌های کلمات کلیدی let و var چیا هستن؟

     تفاوت‌ها رو توی جدول زیر می‌بینیم

     var :
     1. از ابتدای جاوااسکریپت در دسترس هستش
     2. دامنه تابع داره
     3. متغیر‌ها Hoist میشن

     let:
     1. به عنوان بخشی از ES6 معرفی شده
     2. محدود به scope یا دامنه هستش
     3. Hoist شده ولی مقدارههی اولیه نمی‌شه

     بیاین با یه مثال تفاوتش رو بهتر ببینیم

     <span dir="ltr" align="left">

     ```javascript
     function userDetails(username) {
          if(username) {
          console.log(salary); // undefined(due to hoisting)
          console.log(age); // error: age is not defined
          let age = 30;
          var salary = 10000;
          }
          console.log(salary); //10000 (accessible to due function scope)
          console.log(age); //error: age is not defined(due to block scope)
     }
     ```

     </span>


     **[فهرست](#فهرست)**

18. ### دلیل انتخاب کلمه کلیدی let چیه؟

     Let یه عنوان ریاضی هستش که توسط زبان‌های برنامه‌نویسی اولیه مثل Scheme و Basic پذیرفته شده. این زبان از ده‌ها زبان دیگه گرفته شده که از let به عنوان یه کلمه کلیدی سنتی تا حد ممکن نزدیک به var استفاده می‌کنه.

     **[فهرست](#فهرست)**

19. ### چطوری می‌تونیم توی بلوک مربوط به switch بدون دریافت خطا متغیر تعریف کنیم؟

     اگه بخوایم متغیر‌ها رو مجددا توی یه `بلاک switch` تعریف کنیم، این کار باعث خطا می‌شه چون در واقع فقط یه بلاک وجود داره. برای مثال توی کد زیر یه خطای نحوی ایجاد می‌شه


     <span dir="ltr" align="left">

     ```javascript
     let counter = 1;
     switch(x) {
          case 0:
          let name;
          break;

          case 1:
          let name; // SyntaxError for redeclaration.
          break;
     }
     ```

     </span>

     برای جلوگیری از این خطا، می‌تونیم یه بلاک تو در تو داخل case ایجاد کنیم و یه محیط واژگانی دارای محدوده بلاک جدید ایجاد کنیم.

     <span dir="ltr" align="left">

     ```javascript
     let counter = 1;
          switch(x) {
          case 0: {
               let name;
               break;
          }
          case 1: {
               let name; // No SyntaxError for redeclaration.
               break;
          }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

20. ### Temporal-Dead-Zone چیه؟
     Temporal Dead Zone رفتاری توی جاوااسکریپته که موقع تعریف متغیر با کلمات کلیدی let و const رخ میده، نه با کلمه کلیدی var. توی اکما‌اسکریپت ۶، دستیابی به متغیر let و const قبل از تعریفش (توی scope خودش) باعث خطای refrence می‌شه. فاصله زمانی ایجاد اون، بین ایجاد اتصال متغیر و تعریف اون، منطقه Temporal Dead هستش. بیاین با یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     function somemethod() {
          console.log(counter1); // undefined
          console.log(counter2); // ReferenceError
          var counter1 = 1;
          let counter2 = 2;
     }
     ```

     </span>


    **[فهرست](#فهرست)**

21. ### IIFE(توابع بلافاصله صدا زده شده) چی هستن؟

     IIFE (فراخوانی عملکرد بلافاصله) یه تابع جاوا‌اسکریپته که به محض تعریف اجرا می‌شه.
     امضای اون به این صورته،

     <span dir="ltr" align="left">

     ```javascript
     (function ()
          {
          // logic here
          }
     )
     ();
     ```

     </span>


     دلیل اصلی استفاده از IIFE بدست آوردن حریم خصوصی داده‌هاست، چون محیط خارجی به متغیر‌هایی که توی IIFE تعریف شده دسترسی نداره. برای مثال، اگه سعی کنیم با IIFE به متغیر‌ها دسترسی پیدا کنیم این خطا رو می‌گیریم،

     <span dir="ltr" align="left">

     ```javascript
     (function ()
          {
          var message = "IIFE";
          console.log(message);
          }
     )();

     console.log(message); //Error: message is not defined
     ```

     </span>


     **[فهرست](#فهرست)**

22. ### مزایای استفاده از moduleها چیه؟

     استفاده از ماژول‌ها مزایای زیادی داره،
     1. قابلیت نگهداری
     2. قابلیت استفاده مجدد
     3. نامگذاری

     **[فهرست](#فهرست)**

23. ### Memoization چیه؟

     Memoization یه روش برنامه‌نوسی هست که سعی داره با ذخیره نتایج قبلی یه تابع عملکرد اون تابع رو افزایش بده. هر بار که یه تابع Memoize شده فراخوانی می‌شه، پارامتر‌های اون cache می‌شه یعنی توی حافظه پنهان ذخیره می‌شه. اگه داده وجود داشته باشه، بدون اجرای کل تابع می‌شه اونو برگردوند در غیر این صورت تابع اجرا می‌شه و بعدش نتیجه توی حافظه پنهان ذخیره می‌شه.
     بیاین یه مثال از نوشتن یه تابع با Memoization بزنیم،

     <span dir="ltr" align="left">

     ```javascript
     const memoizAddition = () => {
          let cache = {};
          return (value) => {
               if (value in cache) {
               console.log('Fetching from cache');
               return cache[value]; // Here, cache.value cannot be used as property name starts with the number which is not a valid JavaScript  identifier. Hence, can only be accessed using the square bracket notation.
               }
               else {
               console.log('Calculating result');
               let result = value + 20;
               cache[value] = result;
               return result;
               }
          }
     }

     // returned function from memoizAddition
     const addition = memoizAddition();
     console.log(addition(20)); //output: 40 calculated
     console.log(addition(20)); //output: 40 cached
     ```

     </span>


     **[فهرست](#فهرست)**

24. ### Hoisting چیه؟
     Hoisting یه مکانیسم جاوا‌اسکریپته که متغیر‌ها و تعاریف توابع رو به بالای scope یا دامنه خودشون انتقال میده. یادمون باشه که جاوا‌اسکریپت فقط تعریف متغیر‌ها و توابع رو Hoist می‌کنه، نه مقدارههی اولیه اونا رو.
     بیاین یه مثال ساده از hoist کردن متغیر‌ها بزنیم،

     <span dir="ltr" align="left">

     ```javascript
     console.log(message); //output : undefined
     var message = 'The variable Has been hoisted';
     ```

     </span>


    ،ترجمه کد بالا اینطوری می‌شه

     <span dir="ltr" align="left">

     ```javascript
     var message;
     console.log(message);
     message = 'The variable Has been hoisted';
     ```

     </span>


     **[فهرست](#فهرست)**

25. ### Classها توی ES6 چی هستن؟
     در ES6، کلاس‌های جاواسکریپت عمدتاً قند نحوی بر وراثت مبتنی بر نمونه اولیه جاواسکریپت‌ـه.
      برای مثال، وراثت مبتنی بر نمونه اولیه که در عبارت تابع به صورت زیر نوشته شده.

     <span dir="ltr" align="left">

     ```javascript
     function Bike(model,color) {
          this.model = model;
          this.color = color;
     }

     Bike.prototype.getDetails = function() {
          return this.model + ' bike has' + this.color + ' color';
     };
     ```

     </span>

     درحالیکه کلاس‌های ES6 به جای اونا و به شکل ساده‌تری تعریف یشن:

     <span dir="ltr" align="left">

     ```javascript
     class Bike{
          constructor(color, model) {
          this.color= color;
          this.model= model;
          }

          getDetails() {
          return this.model + ' bike has' + this.color + ' color';
          }
     }
     ```

     </span>


     **[فهرست](#فهرست)**

26. ### Closureها چیا هستن؟
     کلاژور ترکیبی از یه تابع و محیط واژگانی هستش که تابع در اون تعریف شده. برای مثال این یه تابع داخلیه که به متغیر‌های تابع خارجی دسترسی داره. کلاژور دارای سه زنجیره دامنه هستش
     ۱. دامنه رو جایی تعریف می‌کنیم که متغیر‌ها بین کرلی براکت‌های اون تعریف شده باشه
     ۲. متغیر‌های تابع بیرونی
     ۳. متغیر‌های محلی
     بیاین یه مثال راجع به مفهوم کلاژور بزنیم

     <span dir="ltr" align="left">

     ```javascript
     function Welcome(name){
          var greetingInfo = function(message){
          console.log(message+' '+name);
          }
     return greetingInfo;
     }
     var myFunction = Welcome('John');
     myFunction('Welcome '); //Output: Welcome John
     myFunction('Hello Mr.'); //output: Hello Mr.John
     ```

     </span>


     مطابق کد بالا، تابع داخلی (greetingInfo) حتی بعد از بازگشت تابع خارجی به متغیر‌های محدوده تابع خارجی (welcome) دسترسی داره.

     **[فهرست](#فهرست)**

27. ### Moduleها چیا هستن؟

     ماژول‌ها به واحد‌های کوچیکی از کد مستقل و قابل استفاده مجدد اشاره می‌کنن و همچنین به عنوان پایه بسیاری از الگو‌های طراحی javascript عمل می‌کنن. خروجی ماژول‌های javascript یه شی، یه تابع یا constructor هستش.

     **[فهرست](#فهرست)**

28. ###  چرا به moduleها نیاز داریم؟

     لیستی از مزایای استفاده از ماژول‌ها در اکوسیستم جاوااسکریپت اینجا گفته شده
     1. قابلیت نگهداری
     2. قابلیت استفاده مجدد
     3. نامگذاری

     **[فهرست](#فهرست)**

29. ### توی جاواسکریپت scope چیه و چیکار می‌کنه؟

     scope یا محدوده، دسترسی متغیر‌ها، توابع و اشیاء در بعضی از قسمت‌های کدمون در زمان اجرا هستش. به عبارت دیگه، دامنه قابلیت دیده شدن متغیر‌ها و بقیه منابع رو تو قسمت‌هایی از کدمون تعیین می‌کنه.

     **[فهرست](#فهرست)**

30. ### service-worker چیه؟

     service worker اساسا یه اسکریپت هستش که جدا از یه صفحه وب توی پس‌زمینه اجرا می‌شه و ویژگی‌هایی رو فراهم می‌کنه که نیازی به صفحه وب یا تعامل کاربر نداره. بعضی از ویژگی‌های عمده service worker‌ها عبارتند از: تجارب غنی آفلاین (اولین برنامه آفلاین وب)، همگام‌سازی دوره‌ای پس‌زمینه، push notification, رهگیری و رسیدگی به درخواست‌های شبکه و مدیریت برنامه‌ای cache response‌ها.

     **[فهرست](#فهرست)**

31. ### توی service-worker چطوری می‌شه DOM رو دستکاری کرد؟

     service worker مستقیما نمیتونه به DOM دسترسی پیدا کنه، اما میتونه با پاسخ به پیام‌های ارسالی از طریق رابط `postMessage` با صفحاتی که کنترل می‌کنه ارتباط برقرار کنه و این صفحات میتونن DOM رو دستکاری کنن.

     **[فهرست](#فهرست)**

32. ### چطوری می‌تونیم بین ریست شدن‌های service-worker داده‌های مورد نظرمون رو مجدد استفاده کنیم؟

     مشکلی که توی service worker وجود داره اینه که در صورت عدم استفاده خاتمه پیدا می‌کنه و در صورت نیاز بعدی دوباره راه‌اندازی می‌شه، بنابراین نمی‌تونیم به state‌های سراسری توی نگهدارنه‌های `onfetch` و `onmessage` یه service worker اعتماد کنیم. تو این حالت service worker برای تداوم کار و استفاده مجدد موقع شروع مجدد، به indexedDB API دسترسی خواهد داشت.

     **[فهرست](#فهرست)**

33. ### IndexedDB چیه؟

     IndexedDB یه API سطح پایین برای ذخیره client-side یا سمت کاربر توی مقادیر بیشتری از داده ساخت‌ یافته شامل فایل‌ها و حباب‌ها هستش. این API از index‌ها برای فعال کردن جستجو‌های با کارایی بالا توی این داده‌ها استفاده می‌کنه.

     **[فهرست](#فهرست)**

34. ### Web-storage چیه؟

     web storage یه API هستش که مکانیسمی رو فراهم می‌کنه که مرورگر‌ها میتونن مقدار و کلید رو ب    صورت محلی توی مرورگر کاربر ذخیره کنن، ب    روشی کاملا قابل درک نسبت به استفاده ا      کوکی‌ها. فضای ذخیره‌سازی وب دو مکانیزم ر برای ذخیره اطلاعات روی مشتری فراهم می‌کنه.
     1. **Local storage:** داده‌ها رو برای مبدا فعلی و بدون تاریخ انقضا ذخیره می‌کنه.
     2. **Session storage:** داده‌ها رو برای یه جلسه ذخیره می‌کنه و با بسته شدن تب مرورگر داده‌ها از بین میرن.

     **[فهرست](#فهرست)**

35. ### Post-message چیه؟

     Post message روشی هست که امکان ایجاد ارتباط متقابل بین آبجکت‌های window رو فراهم می‌کنه     (برای مثال، بین یه صفحه و یه پنجره باز‌شو که باعث ایجاد اون شده، یا بین یه صفح     و یه iframe جاسازی شده در اون) به طور کل    اسکریپت‌های موجود در صفحات مختلف مجاز ب    دسترسی به همدیگه هستن، تنها در صورتی که     صفحات از خط‌ مشی‌ یکسانی تبعیت کنن. (یعنی صفحات از پروتکل، شماره پورت و میزبان یکسانی   برخوردار هستن)

     **[فهرست](#فهرست)**

36. ### Cookie چیه؟

     کوکی قطعه‌ای از داده هستش که توی کامپیوترمون ذخیره می‌شه تا مرورگر به اون دسترسی داشته باشه. کوکی‌ها به عنوان جفت‌های کلید و مقدار ذخیره میشن.
     برای مثال می‌تونیم یه کوکی با نام کاربری مثل زیر ایجاد کنیم،

     <span dir="ltr" align="left">

     ```javascript
     document.cookie = "username=John";
     ```

     </span>


     ![Screenshot](images/cookie.png)

     **[فهرست](#فهرست)**

37. ### چرا به cookie نیاز داریم؟

     از کوکی‌ها برای به خاطر سپردن اطلاعات مربوط به مشخصات کاربر (مانند نام کاربری) استفاده می‌شه. در اصل شامل دو مرحله هستش،
     ۱. وقتی که کاربر از یه صفحه وب بازدید می‌کنه، مشخصات کاربر میتونه توی یه کوکی ذخیره بشه.
     ۲. دفعه بعد که کاربر از صفحه بازدید کرد، کوکی مشخصات کاربر رو به خاطر میاره.

     **[فهرست](#فهرست)**

38. ### گزینه‌های قابل تنظیم توی cookie چیا هستن؟

     گزینه‌های زیر برای کوکی موجوده،
     ۱. به طور پیش فرض، کوکی موقع بسته شدن مرورگر حذف می‌شه اما با تنظیم تاریخ انقضا (به وقت UTC) می‌تونیم این رفتار رو تغییر بدیم.


     <span dir="ltr" align="left">

     ```javascript
     document.cookie = "username=John; expires=Sat, 8 Jun 2019 12:00:00 UTC";
     ```

     </span>

     ۱. به طور پیش فرض، کوکی به صفحه فعلی تعلق داره. اما با استفاده از پارامتر path می‌تونیم به مرورگر بگیم که کوکی متعلق به چه مسیری هستش.

     <span dir="ltr" align="left">

     ```javascript
     document.cookie = "username=John; path=/services";
     ```

     </span>


     **[فهرست](#فهرست)**

39. ### چطوری می‌شه یه cookie رو حذف کرد؟

     با تنظیم تاریخ انقضا به عنوان تاریخ گذشته می‌تونیم کوکی رو حذف کنیم. تو این حالت نیازی به تعیین مقدار کوکی نیست.
     برای مثال، می‌تونیم کوکی نام کاربری رو توی صفحه فعلی به صورت زیر حذف کنیم.

     <span dir="ltr" align="left">

     ```javascript
     document.cookie = "username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;";
     ```

     </span>


     **نکته** برای اطمینان از نحوه درست پاک کردن کوکی باید گزینه مسیر کوکی رو تعیین کنیم. بعضی از مرورگرها تا زمانی که پارامتر مسیر رو تعیین نکنیم اجازه حذف کوکی رو نمیدن.

     **[فهرست](#فهرست)**

40. ### تفاوت‌های بین cookie، local-storage و session-storage چیا هستن؟

     تفاوت‌های بین کوکی، لوکال استوریج و سشن استوریج اینا هستن:

    | ویژگی | Cookie | Local storage | Session storage |
    | ---- | :---------: | :-----: | :-----: |
    | قابل دسترسی از طرف سرویس گیرنده یا سرور | هردو سرویس دهنده و سرویس گیرنده | فقط سرویس گیرنده | فقط سرویس‌ گیرنده |
    | طول عمر | پیکربندی‌شده با استفاده از گزینه اکسپایر | تا وقتی که حذف بشه | تا وقتی که تب بسته‌نشده |
    | پشتیبانی از SSL | پشتیبانی می‌شه | پشتیبانی نمی‌شه | پشتیبانی نمی‌شه |
    | حداکثر اندازه داده | 4KB | 5MB | 5MB |


     **[فهرست](#فهرست)**

41. ### تفاوت‌های بین localStorage و sessionStorage چیا هستن؟

     لوکال استوریج همون سشن استوریج هستش اما داده‌ها با بستن و دوباره باز کردن مرورگر همچنان حفظ می‌شه (تاریخ انقضا نداره) در حالی که سشن استوریج داده‌ها رو با بستن پنجره مرورگر پاک می‌کنه.

     **[فهرست](#فهرست)**

42. ### چطوری به web-storage دسترسی پیدا می‌کنی؟

     شی window به ترتیب ویژگی‌های `WindowLocalStorage` و `WindowSessionStorage` رو که دارای ویژگی‌های `localStorage`(window.localStorage) و `sessionStorage`(window.sessionStorage) هستن رو پشتیبانی می‌کنه. این خصوصیات نمونه ای از شی Storage رو ایجاد می‌کنه که از طریق اون می‌شه موارد داده رو برای یه دامنه خاص و نوع ذخیره سازی (session یا محلی) تنظیم، بازیابی و حذف کرد.
     برای مثال، می‌تونیم روی اشیای ذخیره سازی محلی مثل زیر بخونیم و بنویسیم

     <span dir="ltr" align="left">

     ```javascript
     localStorage.setItem('logo', document.getElementById('logo').value);
     localStorage.getItem('logo');
     ```

     </span>


     **[فهرست](#فهرست)**

43. ### چه متد‌هایی روی session-storage قابل استفاده هستن؟

     session storage متد‌هایی رو برای خواندن، نوشتن و پاکسازی داده‌های session ارائه میده.

     <span dir="ltr" align="left">

     ```javascript
     // Save data to sessionStorage
     sessionStorage.setItem('key', 'value');

     // Get saved data from sessionStorage
     let data = sessionStorage.getItem('key');

     // Remove saved data from sessionStorage
     sessionStorage.removeItem('key');

     // Remove all saved data from sessionStorage
     sessionStorage.clear();
     ```

     </span>


     **[فهرست](#فهرست)**

44. ### رخداد storage چیه و چطوری ازش استفاده می‌کنیم؟

     storageEvent رویدادی هستش که با تغییر مکان ذخیره‌سازی در متن سند دیگه‌ای فعال می‌شه. در حالی که خاصیت ذخیره‌سازی یه EventHandler برای پردازش رویدادهای ذخیره‌سازی‌ـه.

     <span dir="ltr" align="left">

     ```javascript
     window.onstorage = functionRef;
     ```

     </span>


     بیاین برای مثال  استفاده از رویداد onstorage رو ببینیم که کلید ذخیره و مقادیر اونو ثبت می‌کنه

     <span dir="ltr" align="left">

     ```javascript
     window.onstorage = function(e) {
          console.log('The ' + e.key +
          ' key has been changed from ' + e.oldValue +
          ' to ' + e.newValue + '.');
     };
     ```

     </span>

     **[فهرست](#فهرست)**

45. ### چرا به web-storage نیاز داریم؟

     فضای ذخیره سازی وب از امنیت بیشتری برخورداره و مقدار زیادی داده میتونن به صورت محلی ذخیره بشن، بدون اینکه روی عملکرد وب سایت تأثیر بذارن. همچنین، اطلاعات هرگز به سرور منتقل نمیشن. به همین دلیل این روش نسبت به کوکی‌ها بیشتر توصیه می‌شه.

     **[فهرست](#فهرست)**

46. ### چطوری می‌تونیم پشتیبانی از web-storage توسط مرورگر رو بررسی کنیم؟

     قبل از استفاده از فضای ذخیره‌سازی وب، باید پشتیبانی مرورگر رو برای localStorage و sessionStorage بررسی کنیم.

     <span dir="ltr" align="left">

     ```javascript
     if (typeof(Storage) !== "undefined") {
          // Code for localStorage/sessionStorage.
     } else {
          // Sorry! No Web Storage support..
     }
     ```

     </span>


     **[فهرست](#فهرست)**

47. ### چطوری می‌تونیم پشتیبانی از web-worker توسط مرورگر رو بررسی کنیم؟

     قبل از استفاده، باید پشتیبانی مرورگر رو برای web worker‌ها بررسی کنیم

     <span dir="ltr" align="left">

     ```javascript
     if (typeof(Worker) !== "undefined") {
          // code for Web worker support.
     } else {
          // Sorry! No Web Worker support..
     }
     ```

     </span>


     **[فهرست](#فهرست)**

48. ### یه مثال از web-workerها می‌تونی بزنی؟

     برای شروع استفاده از web worker‌ها برای مثال شمارنده باید مراحل زیر رو دنبال کنیم
     ۱. ساخت یه فایل Web Worker: برای افزایش مقدار شمارش، باید یه اسکریپت بنویسیم. بیاین اسمشو counter.js بذاریم

     <span dir="ltr" align="left">

     ```javascript
     let i = 0;

     function timedCount() {
          i = i + 1;
          postMessage(i);
          setTimeout("timedCount()",500);
     }

     timedCount();
     ```

     </span>

     اینجا از روش postMessage برای ارسال پیام به صفحه HTML استفاده می‌شه
     ۱. ایجاد شی Web Worker: با بررسی پشتیبانی مرورگر می‌تونیم یه شی Web Worker ایجاد کنیم. بیاین اسم این فایل رو web_worker_example.js بذاریم.

     <span dir="ltr" align="left">

     ```javascript
     if (typeof(w) == "undefined") {
          w = new Worker("counter.js");
     }
     ```

     </span>


     و ما می‌تونیم پیام‌ها رو از web worker دریافت کنیم

     <span dir="ltr" align="left">

     ```javascript
     w.onmessage = function(event){
          document.getElementById("message").innerHTML = event.data;
     };
     ```

     </span>


     ۱. به پایان رسوندن یه web Worker
     Web Worker‌ها تا زمان خاتمه یافتن پیام‌ها (حتی بعد از اتمام یه اسکریپت خارجی) به گوش دادن ادامه میدن. برای خاتمه دادن به گوش دادن به پیام‌ها می‌تونیم از دستور terminate استفاده کنیم.

     <span dir="ltr" align="left">

     ```javascript
     w.terminate();
     ```

     </span>


     ۱. استفاده مجدد از web worker : اگه متغیر worker رو undefined یا تعریف نشده تنظیم کنیم، می‌تونیم از کد استفاده مجدد کنیم.

     <span dir="ltr" align="left">

     ```javascript
     w = undefined;
     ```

     </span>


     **[فهرست](#فهرست)**

49. ### محدودیت‌های web-workerها روی DOM چیا هستن؟

     WebWorker‌ها به اشیا جاوااسکریپت دسترسی ندارن چون توی یه فایل خارجی تعریف شدن.
     1. Window object
     2. Document object
     3. Parent object

     **[فهرست](#فهرست)**

50. ### Promise چیه؟

     یه promise آبجکت‌ای‌ـه که ممکنه در آینده یه مقدار واحد رو با یه مقدار حل شده یا به دلیل حل نشدنش (مثلاً خطای شبکه) تولید کنه. تو یهی از 3 حالت ممکن خواهد بود: انجام شده، رد شده، یا در انتظار.

     برای ساختن Promise‌ها از سینتکس زیر استفاده می‌شه

     <span dir="ltr" align="left">

     ```javascript
     const promise = new Promise(function(resolve, reject) {
          // promise description
     })
     ```

     </span>


     استفاده از پرامیس‌ها رو هم باهم ببینیم

     <span dir="ltr" align="left">

     ```javascript
     const promise = new Promise(resolve => {
          setTimeout(() => {
          resolve("I'm a Promise!");
          }, 5000);
     }, reject => {

     });

     promise.then(value => console.log(value));
     ```

     </span>


     جریان عمل یه پرامیس هم به این شکل انجام میشه:

     ![Screenshot](images/promises.png)

     **[فهرست](#فهرست)**

51. ### چرا به promise نیاز داریم؟

     Promises برای رسیدگی به عملیات ناهمزمان استفاده می‌شه. اونا با کاهش جهنم callback و نوشتن کد پاک‌کننده، یه رویکرد جایگزین برای callbackها ارائه می‌کنن.

     **[فهرست](#فهرست)**

52. ### سه تا وضعیت ممکن برای یه promise چیا هستن؟

     پرامیس‌ها‌ها سه حالت دارن:
     1. **Pending:** این حالت اولیه Promise قبل از شروع عملیاته
     2. **Fulfilled:** این حالت نشون میده که عملیات مشخص شده تکمیل شده.
     3. **Rejected:** این حالت نشون میده که عملیات کامل نشده. تو این حالت یه مقدار خطا داده خواهد شد.

     **[فهرست](#فهرست)**

53. ### توابع callback چی هستن؟

     تابع callback تابعیه که به عنوان آرگومان به تابع دیگری منتقل می‌شه. این تابع در داخل تابع خارجی برای تکمیل یه عمل فراخوانی می‌شه.
      بیاین یه مثال ساده از نحوه استفاده از تابع callback بزنیم

     <span dir="ltr" align="left">

     ```javascript
     function callbackFunction(name) {
          console.log('Hello ' + name);
     }

     function outerFunction(callback) {
          let name = prompt('Please enter your name.');
          callback(name);
     }

     outerFunction(callbackFunction);
     ```

     </span>


     **[فهرست](#فهرست)**

54. ### چرا به توابع callback نیاز داریم؟

     callback‌ها مورد نیاز هستن چون جاواسکریپت یه زبان ایونت محوره. این به این معنیه که به جای منتظر موندن برای جواب جاواسکریپت در حین گوش دادن به ایونت‌های دیگه اجرا می‌شه.
      بیاین مثالی رو با اولین تابع callbackی یه API (شبیه‌سازی شده توسط setTimeout) و تابع بعدی که پیام رو ثبت می‌کنه، بیاریم.

     <span dir="ltr" align="left">

     ```javascript
     function firstFunction(){
          // Simulate a code delay
          setTimeout( function(){
          console.log('First function called');
          }, 1000 );
     }
     function secondFunction(){
          console.log('Second function called');
     }
     firstFunction();
     secondFunction();

     // Output :
     // Second function called
     // First function called
     ```

     </span>

     همونطور که از خروجی می‌شه فهمید، جاواسکریپت منتظر جواب اولین تابع نبود و بلوک کد باقی مونده اجرا شد. بنابراین از callback‌ها به گونه ای استفاده می‌شه تا مطمئن شیم که کد خاصی تا موقعی که اجرای کد دیگه تموم نشده ,اجرا نمی‌شه.

     **[فهرست](#فهرست)**

55. ### Callback-hell یا جهنم توابع callback چیه؟

     Callback Hell یه ضد الگو با چندین تماس تو در توعه که خوندن کد و دیباگ رو در موقع برخورد با منطق async سخت می‌کنه. جهنم callback شبیه کد زیره

     <span dir="ltr" align="left">

     ```javascript
     async1(function(){
          async2(function(){
               async3(function(){
                    async4(function(){
                    ....
                    });
               });
          });
     });
     ```

     </span>


     **[فهرست](#فهرست)**

56. ### Server-sent-events(SSE) چیه؟

     event‌های ارسال شده توسط سرور (SSE) یه فناوری فشار سروره که به مرورگر امکان میده به‌روزرسانی‌های خودکار رو از طریق اتصال HTTP بدون استفاده از نظرسنجی دریافت کنه. اینا یه کانال ارتباطی یه طرفه هستن - event‌ها فقط از سروری به مشتری دیگر منتقل میشن این در به‌روزرسانی‌های فیس‌بوک/تویتر، به‌روزرسانی قیمت سهام، فیدهای خبری و غیره استفاده شده.

     **[فهرست](#فهرست)**

57. ### چطوری می‌تونیم اعلان‌های server-sent-event رو دریافت کنیم؟

     شی EventSource برای دریافت اعلان‌های event ارسال شده از سرور استفاده می‌شه. برای مثال، می‌تونین پیام‌هایی رو از سرور مثل مثال زیر دریافت کنین.

     <span dir="ltr" align="left">

     ```javascript
     if(typeof(EventSource) !== "undefined") {
          var source = new EventSource("sse_generator.js");
          source.onmessage = function(event) {
          document.getElementById("output").innerHTML += event.data + "<br>";
          };
     }
     ```

     </span>

     **[فهرست](#فهرست)**

58. ### چطوری می‌تونیم پشتیبانی مرورگر برای SSE رو بررسی کنیم؟

     می‌تونین قبل از استفاده از eventهای ارسال شده توسط مرورگر مانند زیر، پشتیبانی مرورگر رو انجام بدین.

     <span dir="ltr" align="left">

     ```javascript
     if(typeof(EventSource) !== "undefined") {
          // Server-sent events supported. Let's have some code here!
     } else {
          // No server-sent events supported
     }
     ```

     </span>

     **[فهرست](#فهرست)**

59. ### کدوم توابع روی SSE وجود دارن؟

     در زیر لیستی از eventهای موجود برای eventهای ارسال شده توسط سرور آمده است

     | Event | Description |
     |---- | --------- |
     | onopen  | موقعی که اتصال به سرور باز می‌شه استفاده می‌شه |
     | onmessage | این event زمانی استفاده می‌شه که پیامی دریافت شه  |
     | onerror | زمانی اتفاق میوفته که خطایی رخ بده|

     **[فهرست](#فهرست)**

60. ### اصلی‌ترین قوانین promiseها چیا هستن؟

     1. پرامیس آبجکت‌ای‌ـه که متد «.then» سازگار با استانداره رو ارائه می‌کنه
     2. یه پرامیس معلق ممکنه به حالت تحقق یافته یا رد شده تبدیل شه
     3. پرامیس تمام شده یا رد شده حل و فصل می‌شه و نباید به حالت دیگری تبدیل شه.
     4. پس از اتمام قول، ارزش اون نباید تغییر کنه.

     **[فهرست](#فهرست)**

61. ### Callback توی callback چطوری رخ میده؟

    می‌تونین یه پاسخ تماس رو در داخل یه تماس دیگر قرار بدین تا اقدامات رو به صورت متوالی یکی یکی انجام بدین. این به عنوان callback در callbacks شناخته می‌شه.

    <span dir="ltr" align="left">

    ```javascript
    loadScript('/script1.js', function(script) {
          console.log('first script is loaded');

          loadScript('/script2.js', function(script) {

               console.log('second script is loaded');

               loadScript('/script3.js', function(script) {

                    console.log('third script is loaded');
                    // after all scripts are loaded
               });
          })
     });
     ```

     </span>

     **[فهرست](#فهرست)**

62. ### زنجیره promiseها چیه؟

     فرآیند اجرای دنباله ای از وظایف ناهمزمان یکی پس از دیگری با استفاده از پرامیس‌ها به عنوان Promise chaining شناخته می‌شه. بیاین برای محاسبه نتیجه نهایی مثالی از زنجیره قولی بزنیم.

     <span dir="ltr" align="left">

     ```javascript
     new Promise(function(resolve, reject) {

          setTimeout(() => resolve(1), 1000);

     }).then(function(result) {

          console.log(result); // 1
          return result * 2;

     }).then(function(result) {

          console.log(result); // 2
          return result * 3;

     }).then(function(result) {

          console.log(result); // 6
          return result * 4;

     });
     ```

     </span>

     در دسته‌های بالا، نتیجه به زنجیره‌های .then handler با جریان کار زیر منتقل می‌شه.
     1. پرامیس اولیه در 1 ثانیه حل می‌شه،
     2. پس از اون، handler «.then» با ثبت نتیجه (1) فراخوانی می‌شه و سپس یه پرامیس با مقدار نتیجه * 2 برمی‌گردونه.
     3. پس از اون مقدار به بعدی منتقل شد. سپس با ثبت نتیجه (2) و برگردوندن یه پرامیس با نتیجه *3.
     4. در نهایت مقدار به آخرین . سپس با ثبت نتیجه (6) و یه پرامیس با نتیجه * 4، handler`.

     **[فهرست](#فهرست)**

63. ### کاربرد متد promise.all چیه؟

     Promise.all یه پرامیسه که آرایه ای از پرامیس‌ها رو به عنوان ورودی می‌گیره (یک تکرار) و زمانی حل می‌شه که همه پرامیس‌ها حل شن یا یکی از اونها رد شه. برای مثال، نحو متد `premt.all` در زیر اومده.

     <span dir="ltr" align="left">

     ```javascript
     Promise.all([Promise1, Promise2, Promise3]) .then(result) => {   console.log(result) }) .catch(error => console.log(`Error in promises ${error}`))
     ```

     </span>

     **نکته:** ترتیب پرامیس‌ها (خروجی نتیجه) طبق ترتیب ورودی حفظ می‌شه.

     **[فهرست](#فهرست)**

64. ### هدف از متد race روی promise چیه؟

     متد Promise.race نمونه ای از پرامیس رو که اول حل یا رد شده رو برمی‌گردونه. بیاین مثالی از متد race رو در نظر بگیریم که تو اون پرامیس2 اول حل می‌شه

     <span dir="ltr" align="left">

     ```javascript
     var promise1 = new Promise(function(resolve, reject) {
          setTimeout(resolve, 500, 'one');
     });
     var promise2 = new Promise(function(resolve, reject) {
          setTimeout(resolve, 100, 'two');
     });

     Promise.race([promise1, promise2]).then(function(value) {
          console.log(value); // "two" // Both promises will resolve, but promise2 is faster
     });
     ```

     </span>

     **[فهرست](#فهرست)**

65. ### حالت strict توی جاواسکریپت چی کار می‌کنه؟

     Strict Mode یه ویژگی جدید در ECMAScript 5 اس که به شما امکان میده یه برنامه یا یه تابع رو تو یه زمینه عملیاتی "سخت" قرار بدین. به این ترتیب از انجام بعضی اقدامات جلوگیری می‌کنه و استثناهای بیشتری رو ایجاد می‌کنه. عبارت تحت اللفظی "استفاده از سخت"؛ به مرورگر دستور میده تا از کد جاواسکریپت در حالت Strict استفاده کنه.

     **[فهرست](#فهرست)**

66. ### چرا به حالت strict نیاز داریم؟

     حالت سخت گیرانه برای نوشتن جاواسکریپت "امن" با اطلاع رسانی "بد نحوی" به خطاهای واقعی مفید است. برای مثال، ایجاد تصادفی یه متغیر گلوبال رو با پرتاب یه خطا حذف می‌کنه و همچنین یه خطا برای انتساب به یه ویژگی غیرقابل نوشتن، یه ویژگی فقط گیرنده، یه ویژگی غیرموجود، یه متغیر غیرموجود یا یه ویژگی غیر قابل نوشتن پرتاب می‌کنه. شی موجود

     **[فهرست](#فهرست)**

67. ### چطوری می‌تونیم حالت strict رو فعال کنیم؟

     حالت سخت با اضافه کردن `use strict` اعلام می‌شه. به ابتدای یه اسکریپت یا یه تابع.
      اگه در ابتدای یه اسکریپت اعلام شه، دامنه گلوبال داره.

     <span dir="ltr" align="left">

     ```javascript
     "use strict";
     x = 3.14; // This will cause an error because x is not declared
     ```

     </span>

     و اگه در داخل یه تابع اعلام کنین محدوده محلی داره

     <span dir="ltr" align="left">

     ```javascript
     x = 3.14;       // This will not cause an error.
     myFunction();

     function myFunction() {
          "use strict";
          y = 3.14;   // This will cause an error
     }
     ```

     </span>

    **[فهرست](#فهرست)**

68. ### هدف از عملگر نقیض دوتایی(!!) چیه؟

     علامت تعجب دوتایی یا نفی (!!) تضمین می‌کنه که نوع حاصل یه بولینه. اگه نادرست بود (برای مثال  0، تهی، تعریف نشده، و غیره)، نادرسته، در غیر این صورت، درسته.
      برای مثال، می‌تونین نسخه IE رو با استفاده از عبارت زیر آزمایش کنین.

     <span dir="ltr" align="left">

     ```javascript
     let isIE8 = false;
     isIE8 = !! navigator.userAgent.match(/MSIE 8.0/);
     console.log(isIE8); // returns true or false
     ```

     </span>

     اگه از این عبارت استفاده نکنین مقدار اصلی رو برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     console.log(navigator.userAgent.match(/MSIE 8.0/));  // returns either an Array or null
     ```

     </span>

     **نکته:** بیان !! یه اپراتور نیست و فقط دوتا اپراتور ! هست .

     **[فهرست](#فهرست)**

69. ### هدف از عملگر delete چیه؟

     کلمه کلیدی delete برای حذف ویژگی و همچنین مقدار اون استفاده می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     var user= {name: "John", age:20};
     delete user.age;

     console.log(user); // {name: "John"}
     ```

     </span>

     **[فهرست](#فهرست)**

70. ### عملگر typeof چیکار می‌کنه؟

     برای یافتن نوع متغیر جاواسکریپت می‌تونین از عملگر typeof JavaScript استفاده کنین. نوع یه متغیر یا یه عبارت رو برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     typeof "John Abraham"     // Returns "string"
     typeof (1 + 2)        // Returns "number"
     ```

     </span>

     **[فهرست](#فهرست)**

71. ### undefined چیه و چه زمانی undefined می‌گیریم؟

     ویژگی تعریف نشده نشون میده که به یه متغیر مقداری اختصاص داده نشده یا اصلاً اعلام نشده است. نوع مقدار تعریف نشده هم تعریف نشده.

     <span dir="ltr" align="left">

     ```javascript
     var user;    // Value is undefined, type is undefined
     console.log(typeof(user)) //undefined
     ```

     </span>

     هر متغیری رو می‌شه با تنظیم مقدار روی undefined خالی کرد.

     <span dir="ltr" align="left">

     ```javascript
     user = undefined
     ```

     </span>

     **[فهرست](#فهرست)**

72. ### null چیه؟

     مقدار null عدم وجود عمدی هر مقدار شی رو نشون میده. این یکی از مقادیر اولیه جاواسکریپت‌ـه. نوع مقدار null آبجکته.
      با قرار دادن مقدار null می‌تونین متغیر رو خالی کنین.

     <span dir="ltr" align="left">

     ```javascript
     var user = null;
     console.log(typeof(user)) //object
     ```

     </span>

     **[فهرست](#فهرست)**

73. ### تفاوت‌های بین null و undefined چیا هستن؟

     تفاوت‌های اصلی بین null و undefined 

     | Null | Undefined |
     |---- | -----------|
     | این یه مقدار انتسابه که نشون میده متغیر به هیچ شیئی اشاره نمی‌کنه. | این یه مقدار انتساب نیست که تو اون متغیری اعلام شده باشه اما هنوز مقداری به اون اختصاص داده نشده. |
     | تایپ null آبجکته | تایپ undefined undefined عه|
     | مقدار null یه مقدار اولیه اس که نشون دهنده مرجع تهی، خالی یا غیر موجوده. | مقدار تعریف نشده یه مقدار اولیه اس used زمانی که به یه متغیر مقداری اختصاص داده نشده باشه.|
     | عدم وجود مقدار برای یه متغیر رو نشون میده| عدم وجود خود متغیر رو نشون میده |
     | در حین انجام عملیات اولیه به صفر (0) تبدیل شد | در حین انجام عملیات اولیه به NaN تبدیل می‌شه |

     **[فهرست](#فهرست)**

74. ### eval چیه؟

     تابع eval کد جاواسکریپت رو که به صورت رشته نمایش داده شده رو ارزیابی می‌کنه. رشته میتونه یه عبارت جاواسکریپت، متغیر، دستور یا دنباله ای از عبارات باشه.

     <span dir="ltr" align="left">

     ```javascript
     console.log(eval('1 + 2')); //  3
     ```

     </span>

     **[فهرست](#فهرست)**

75. ### تفاوت‌های بین window و document چیا هستن؟

     | Window | Document |
     |---- | --------- |
     | این عنصر سطح ریشه در هر صفحه وبه| این فرزند مستقیم شی پنجره است. این همچنین به عنوان مدل شیء document (DOM) | شناخته می‌شه
      | به طور پیش فرض شی پنجره به طور ضمنی در صفحه | هست شما می‌تونین از طریق window.document یا document به اون دسترسی داشته باشیم. |
      | دارای متدهایی مانند alert، confirm و ویژگی‌هایی مانند document، location | متدهایی مانند getElementById، getElementByTagName، createElement و غیره رو فراهم می‌کنه |

     **[فهرست](#فهرست)**

76. ### توی جاواسکریپت چطوری می‌تونیم به history دسترسی داشته باشیم؟

     شی window.history حاوی تاریخچه مرورگر است. با استفاده از متدهای `back` و ‍`next` می‌تونین URL‌های قبلی و بعدی رو در تاریخچه بارگذاری کنین.

     <span dir="ltr" align="left">

     ```javascript
     function goBack() {
          window.history.back()
     }
     function goForward() {
          window.history.forward()
     }
     ```

     </span>

     **نکته:** همچنین می‌تونین بدون پیشوند پنجره به تاریخچه دسترسی داشته باشیم.

     **[فهرست](#فهرست)**

77. ### انواع داده‌های جاواسکریپت کدوما هستن؟

     در زیر لیستی از انواع داده‌های جاواسکریپت موجود رو می‌بینیم
     1. Number
     2. String
     3. Boolean
     4. Object
     5. Undefined

     **[فهرست](#فهرست)**

78. ### isNaN چیه و چیکار می‌کنه؟

     تابع`isNaN` برای تعیین اینکه آیا یه مقدار یه عدد غیرقانونی (Not-a-Number) هست یا نه استفاده می‌شه. یعنی اگه مقدار برابر با NaN باشه، این تابع true برمی‌گردونه. در غیر این صورت false برمیگرده.

     <span dir="ltr" align="left">

     ```javascript
     isNaN('Hello') //true
     isNaN('100') //false
     ```

     </span>

     **[فهرست](#فهرست)**

79. ### تفاوت‌های بین undeclared و undefined چیا هستن؟

     در زیر تفاوت عمده بین متغیرهای اعلام نشده و تعریف نشده آورده شده است.

     | undeclared | undefined |
     |---- | --------- |
     | این متغیرها تو یه برنامه وجود ندارن و | تعریف نمی‌شن این متغیرها در برنامه اعلام شده اما هیچ مقدار | اختصاص نداده اند
      | اگه سعی کنین مقدار یه متغیر اعلام نشده رو بخوانید، با خطای زمان اجرا مواجه می شوید | اگه سعی کنین مقدار یه متغیر تعریف نشده رو بخوانید، یه مقدار تعریف نشده برگردانده می‌شه. |

     **[فهرست](#فهرست)**

80. ### کدوم متغیرها عمومی هستن؟

     متغیرهای عمومی اونایی ان که در طول کد بدون هیچ محدوده ای در دسترسن. کلمه کلیدی var برای اعلام یه متغیر محلی استفاده می‌شه اما اگه اونو حذف کنین تبدیل به متغجهانی می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     msg = "Hello" // var is missing, it becomes global variable
     ```

     </span>

     **[فهرست](#فهرست)**

81. ### مشکلات متغیرهای عمومی چیا هستن؟

     مشکل متغیرهای سراسری تضاد نام متغیرها با دامنه محلی و گلوباله. دیباگ و آزمایش کدی که به متغیرهای سراسری متکیه سخته.

     **[فهرست](#فهرست)**

82. ### مقدار NaN چیه؟

     ویژگی NaN یه ویژگی گلوباله که مقدار "Not-a-Number" رو نشون میده. یعنی نشون میده که یه مقدار یه عدد قانونی نیست. استفاده از NaN تو یه برنامه بسیار نادر است، اما می‌شه از اون به عنوان مقدار بازگشتی برای موارد کمی استفاده کرد

     <span dir="ltr" align="left">

     ```javascript
     Math.sqrt(-1)
     parseInt("Hello")
     ```

     </span>

     **[فهرست](#فهرست)**

83. ### هدف از تابع isFinite چیه؟

     تابع`isFinite`برای تعیین اینکه آیا یه عدد یه عدد محدود و قانونیه استفاده می‌شه. اگه مقدار +infinity، -infinity یا NaN (Not-a-Number) باشه false برمی‌گردونه، در غیر این صورت true رو برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     isFinite(Infinity);  // false
     isFinite(NaN);       // false
     isFinite(-Infinity); // false

     isFinite(100);         // true
     ```

     </span>

     **[فهرست](#فهرست)**

84. ### یه event-flow چیه؟

     `event-flow` ترتیبیه که `event` در صفحه وب دریافت می‌شه. وقتی روی عنصری کلیک می‌کنیم که در عنصر‌های مختلف دیگه تودرتوعه. قبل از اینکه کلیکمون واقعاً به مقصد یا عنصر هدف برسه، باید `event` کلیک رو برای هر یه از عنصرهای والد خود ابتدا راه‌اندازی کنه و از بالا با شی پنجره گلوبال شروع شه.
      دو راه برای جریان event وجود داره
     1. از بالا به پایین(Event Capturing) 
     2. از پایین به بالا (Event Capturing)

     **[فهرست](#فهرست)**

85. ### Event-bubbling چیه؟

     `Event-bubbling` نوعی انتشار event هس که تو اون event ابتدا روی درونی‌ترین عنصر هدف راه‌اندازی می‌شه و سپس به‌طور متوالی روی اجداد (والد) عنصر هدف در همون سلسله مراتب تودرتو راه‌اندازی می‌شه تا زمانی که به بیرونی‌ترین عنصر DOM برسه.

     **[فهرست](#فهرست)**

86. ### Event-capturing چیه؟

     Event-capturing نوعی انتشار event که تو اون event اول با بیرونی ترین عنصر ثبت می‌شه و سپس به طور متوالی بر روی children (children) عنصر هدف در همون سلسله مراتب تودرتو راه اندازی می‌شه تا زمانی که به درونی ترین عنصر DOM برسه.

     **[فهرست](#فهرست)**

87. ### چطوری می‌شه یه فرم رو با استفاده از جاواسکریپت ثبت کرد؟

     می‌تونین با استفاده از جاواسکریپت فرمی رو ارسال کنین use document.form[0].submit. تمام اطلاعات ورودی فرم با استفاده از onsubmit event handler ارسال می‌شه

     <span dir="ltr" align="left">

     ```javascript
     function submit() {
          document.form[0].submit();
     }
     ```

     </span>

     **[فهرست](#فهرست)**

88. ### چطوری می‌شه به اطلاعات مربوط به سیستم عامل کاربر دسترسی داشت؟

     شی window.navigator حاوی اطلاعاتی درباره جزئیات سیستم عامل مرورگر بازدیدکننده است. بعضی از ویژگی‌های سیستم عامل تحت ویژگی پلتفرم در دسترس هستن،

     <span dir="ltr" align="left">

     ```javascript
     console.log(navigator.platform);
     ```

     </span>

     **[فهرست](#فهرست)**

89. ### تفاوت‌های بین رخدادهای document-load و DOMContentLoaded چیا هستن؟

     رویداد `DOMContentLoade` زمانی فعال می‌شه که سند اولیه HTML به‌طور کامل بارگیری و تجزیه شده باشه، بدون اینکه منتظر بمانید تا دارایی‌ها (سبک‌ها، تصاویر و فریم‌های فرعی) بارگیری تمام شه. در حالی که رویداد بارگیری زمانی فعال می‌شه که کل صفحه بارگیری شه، از جمله تمام منابع وابسته (شیوه‌ها، تصاویر).

     **[فهرست](#فهرست)**

90. ### تفاوت‌های بین objectهای native، host و user چیا هستن؟

     `Native objects` آبجکت‌هایی هستن که بخشی از زبان جاواسکریپت تعریف شده توسط مشخصات ECMAScript هستن. برای مثال، اشیاء اصلی رشته، ریاضی، RegExp، Object، Function و غیره که در مشخصات `ECMAScript` تعریف شدن.
     `Host objects` آبجکت‌هایی هستن که توسط مرورگر یا محیط زمان اجرا (Node) ارائه می‌شن. برای مثال، پنجره، `XmlHttpRequest،` گره‌های DOM و غیره به عنوان اشیاء میزبان در نظر گرفته میشن
     `User objects` آبجکت‌هایی هستن که در کد جاواسکریپت تعریف شدن. برای مثال، اشیاء کاربر ایجاد شده برای اطلاعات پروفایل.

     **[فهرست](#فهرست)**

91. ### کدوم ابزار و تکنیک‌ها برای دیباگ کردن برنامه جاواسکریپتی استفاده میشن؟

     می‌تونین از ابزارها یا تکنیک‌های زیر برای اشکال زدایی جاواسکریپت استفاده کنین
     1. Chrome Devtools
     2. debugger statement
     3. console.log statement

     **[فهرست](#فهرست)**

92. ### مزایا و معایب استفاده از promiseها به جای callback چیا هستن؟

     مزایا و معایب Promise به جای callback

     **مزایا:**
     1. از جهنم callback که قابل خواندن نیست جلوگیری می‌کنه
     2. نوشتن کدهای ناهمزمان متوالی با .then آسان است.
     3. نوشتن کد ناهمزمان موازی آسان با Promise.all
     4. بعضی از مشکلات رایج callbackهای برگشتی رو حل می‌کنه (بسیار دیر، خیلی زود، بارها callback و خطاها/ استثناها رو بپذیرید)

     **معایب:**
     1. کد کمی پیچیده می سازد
     2. اگه ES6 پشتیبانی نمی‌شه، باید یه polyfill بارگذاری کنین

     **[فهرست](#فهرست)**

93. ### تفاوت‌های بین attribute و property روی DOM چیا هستن؟

     ویژگی‌ها در نشونه گذاری HTML تعریف می‌شن در حالی که ویژگی‌ها در DOM تعریف میشن برای مثال، عنصر HTML زیر دارای 2 ویژگی نوع و مقدار هستش

     <span dir="ltr" align="left">

     ```javascript
     <input type="text" value="Name:">
     ```

     </span>

     می‌تونین مقدار ویژگی رو به صورت زیر بازیابی کنین

     <span dir="ltr" align="left">

     ```javascript
     const input = document.querySelector('input');
     console.log(input.getAttribute('value')); // Good morning
     console.log(input.value); // Good morning
     ```

     </span>

     و بعد از اینکه مقدار فیلد متن رو به "Good evening" تغییر دادید مانند می‌شه

     <span dir="ltr" align="left">

     ```javascript
     console.log(input.getAttribute('value')); // Good morning
     console.log(input.value); // Good evening
     ```

     </span>

     **[فهرست](#فهرست)**

94. ### سیاست same-origin چیه؟

     خط مشی همون مبدا خط مشیه که از درخواست جاواسکریپت در سراسر مرزهای دامنه جلوگیری می‌کنه. مبدا به عنوان ترکیبی از طرح URI، نام میزبان و شماره پورت تعریف می‌شه. اگه این خط‌مشی رو فعال کنین از دسترسی یه اسکریپت مخرب تو یه صفحه به داده‌های حساس در صفحه وب دیگر با استفاده از Document Object Model (DOM) جلوگیری می‌کنه.

     **[فهرست](#فهرست)**

95. ### هدف استفاده از void 0 چیه؟

     Void(0) برای جلوگیری از به روز رسانی صفحه استفاده می‌شه. این برای از بین بردن عارضه جانبی ناخواسته مفید خواهد بود، چون مقدار اولیه تعریف نشده رو برمی‌گردونه. معمولاً برای اسناد HTML استفاده می‌شه که از href="JavaScript:Void(0);" استفاده می‌کنن. تو یه عنصر ```<a>```. یعنی وقتی روی یه پیوند کلیک می‌کنین مرورگر یه صفحه جدید رو بارگیری می‌کنه یا همون صفحه رو تازه می‌کنه. اما با استفاده از این عبارت از این رفتار جلوگیری می‌شه.
      برای مثال، پیوند زیر پیام رو بدون بارگیری مجدد صفحه مطلع می‌کنه

     <span dir="ltr" align="left">

     ```html
     <a href="JavaScript:void(0);" onclick="alert('Well done!')">Click Me!</a>
     ```

     </span>

     **[فهرست](#فهرست)**

96. ### جاواسکریپت یه زبان تفسیری هست یا کامپایلری؟

     جاواسکریپت یه زبان تفسیری‌ـه، نه یه زبان کامپایل شده. یه مفسر در مرورگر کد جاواسکریپت رو می خواند، هر خط رو تفسیر می‌کنه و اونو اجرا می‌کنه. امروزه مرورگرهای مدرن از فناوری موسوم به کامپایل Just-In-Time(JIT) استفاده می‌کنن که جاواسکریپت رو در زمانی که در شرف اجراست به بایت کد اجرایی کامپایل می‌کنه.

     **[فهرست](#فهرست)**

97. ### آیا جاواسکریپت یه زبان حساس به بزرگی و کوچکی(case-sensitive) حروف است؟

     بله، جاواسکریپت یه زبان حساس به حروف کوچک و بزرگه. کلمات کلیدی زبان، متغیرها، نام تابع و اشیا، و هر شناسه دیگر باید همی‌شه با حروف بزرگ تایپ شن.

     **[فهرست](#فهرست)**

98. ### ارتباطی بین Java و JavaScript وجود داره؟

     نه، اونا کاملاً دو زبان برنامه نویسی متفاوت هستن و هیچ ارتباطی با یکدیگر ندارن. اما هر دوی اونا زبان‌های برنامه نویسی شی گرا هستن و مانند بسیاری از زبان‌های دیگر، از نحو مشابهی برای ویژگی‌های اساسی (اگر، غیره، برای، سوئیچ، شکستن، ادامه و غیره) پیروی می‌کنن.

     **[فهرست](#فهرست)**

99. ### Eventها چی هستن؟

     رویدادها «چیزهایی» هستن که برای عناصر HTML اتفاق می‌افتند. موقعی که جاواسکریپت در صفحات HTML استفاده می‌شه، جاواسکریپت میتونه به این رویدادها واکنش نشون بده. بعضی از نمونه‌های رویدادهای HTML عبارتند از:

     1.  بارگیری صفحه وب به پایان رسید
     2.  فیلد ورودی تغییر کرد
     3.  دکمه کلیک شد

     بیاین رفتار رویداد کلیک رو برای عنصر دکمه شرح بدیم،

     <span dir="ltr" align="left">

     ```html
     <!doctype html>
     <html>
      <head>
        <script>
          function greeting() {
            alert('Hello! Good morning');
          }
        </script>
      </head>
      <body>
        <button type="button" onclick="greeting()">Click me</button>
      </body>
     </html>
     ```

     </span>

     **[فهرست](#فهرست)**

100. ### کی جاواسکریپت رو ساخته؟

     جاواسکریپت توسط برندان ایچ در سال 1995 و در زمان او در نت اسکیپ ارتباطات ایجاد شد. در ابتدا با نام `Mocha` توسعه یافت، اما بعداً زمانی که برای اولین بار در نسخه‌های بتا نت اسکیپ عرضه شد، این زبان به طور رسمی `LiveScript` نامیده شد.


     **[فهرست](#فهرست)**


101. ### هدف از متد preventDefault چیه؟

     متد `preventDefault` اگه رویداد قابل لغو باشه، اونو لغو می‌کنه، به این معنی که عمل یا رفتار پیش‌فرض متعلق به رویداد رخ نمیده. برای مثال، جلوگیری از ارسال فرم موقع کلیک بر روی دکمه ارسال و جلوگیری از باز شدن `URL` صفحه موقع کلیک کردن بر روی لینک از موارد رایج استفاده‌‌‌‌ـشه.

     <span dir="ltr" align="left">

     ```javascript
     document.getElementById("link").addEventListener("click", function(event){
      event.preventDefault();
     });
     ```

     </span>

     **نکته:** Remember that not all events are cancelable.

     **[فهرست](#فهرست)**

102. ### کاربرد متد stopPropagation چیه؟

     روش `stopPropagation` برای جلوگیری از حبابی شدن رویداد در زنجیره رویداد استفاده می‌شه. برای مثال، div‌های تودرتو زیر با متد `stopPropagation` از انتشار پیش فرض رویداد موقع کلیک بر روی div (Div1) جلوگیری می‌کنه.

     <span dir="ltr" align="left">

     ```html
     <p>Click DIV1 Element</p>
     <div onclick="secondFunc()">DIV 2
       <div onclick="firstFunc(event)">DIV 1</div>
     </div>

     <script>
     function firstFunc(event) {
       alert("DIV 1");
       event.stopPropagation();
     }

     function secondFunc() {
       alert("DIV 2");
     }
     </script>
     ```

     </span>

     **[فهرست](#فهرست)**

103. ### مراحلی که موقع استفاده از return false توی یه event-handler رخ میده چیا هستن؟

     عبارت ‍‍‍‍`return false` در کنترل کننده رویداد مراحل زیر رو انجام میده:

     1. ابتدا عملکرد یا رفتار پیش فرض مرورگر رو متوقف می‌کنه.
     2. این رویداد از انتشار `DOM` جلوگیری می‌کنه
     3. اجرای ‍‍`callback` رو متوقف می‌کنه و بلافاصله پس از فراخوانی برمی گرده.

     **[فهرست](#فهرست)**

104. ### BOM چیه؟

     مدل شیء مرورگر (BOM) به جاواسکریپت اجازه میده تا با مرورگر "صحبت کنه". این شامل ناوبر اشیاء، تاریخچه، صفحه، مکان و سنده که فرزندان پنجره هستن. مدل شیء مرورگر استانداره نیست و می‌تونه بر اساس مرورگرهای مختلف تغییر کنه.

     ![Screenshot](images/bom.png)

     **[فهرست](#فهرست)**

105. ### موارد استفاده از setTimeout کدوما هستن؟

     متد he `setTimeout` برای فراخوانی یه تابع یا ارزیابی یه عبارت پس از تعداد مشخصی از میلی ثانیه استفاده می‌شه. برای مثال، بیاین یه پیام رو پس از 2 ثانیه با استفاده از روش `setTimeout` ثبت کنیم.

     <span dir="ltr" align="left">

     ```javascript
     setTimeout(function(){ console.log("Good morning"); }, 2000);
     ```

     </span>

     **[فهرست](#فهرست)**

106. ### موارد استفاده از setInterval کدوما هستن؟

     متد `setInterval` برای فراخوانی یه تابع یا ارزیابی یه عبارت در بازه‌های زمانی مشخص (بر حسب میلی ثانیه) استفاده می‌شه. برای مثال، اجازه بدین یه پیام رو پس از 2 ثانیه با استفاده از روش `setInterval` ثبت کنیم.

     <span dir="ltr" align="left">

     ```javascript
     setInterval(function(){ console.log("Good morning"); }, 2000);
     ```

     </span>

     **[فهرست](#فهرست)**

107. ### چرا جاواسکریپت رو به عنوان یه زبان تک thread می‌شناسن؟

     جاواسکریپت یه زبان تک Threadـه. چون مشخصات زبان به برنامه نویس اجازه نمیده تا کدی بنویسه که مفسر بتونه بخش‌هایی از اونو به صورت موازی در چندین Thread یا پردازش اجرا کنه. در حالی که زبان‌هایی مانند java، go، C++ میتونن برنامه‌های چند رشته‌ای و چند فرآیندی بسازند.

     **[فهرست](#فهرست)**

108. ### Event-delegation چیه؟

     تفویض رویداد تکنیکی برای گوش دادن به رویدادهاس که تو اون یه عنصر والد رو به عنوان شنونده برای همه رویدادهایی که در داخلش اتفاق می‌افتد، تفویض می‌کنین.

     برای مثال، اگه می‌خواین تغییرات فیلد رو تو یه فرم خاص تشخیص بدین، می‌تونین از تکنیک انتقال رویداد استفاده کنین.

     <span dir="ltr" align="left">

     ```javascript
     var form = document.querySelector('#registration-form');

     // Listen for changes to fields inside the form
     form.addEventListener('input', function (event) {

     // Log the field that was changed
     console.log(event.target);

     }, false);
     ```

     </span>

     **[فهرست](#فهرست)**

109. ### ECMAScript چیه؟

     `ECMAScript` زبان برنامه نویسیه که اساس جاواسکریپت رو تشکیل میده. `ECMAScript` توسط سازمان استانداره بین المللی `ECMA` در مشخصات `ECMA-262` و `ECMA-402` استانداره شده است. اولین نسخه `ECMAScript` در سال 1997 منتشر شد.

     **[فهرست](#فهرست)**

110. ### JSON چیه؟

     `JSON (JavaScript Object Notation)` یه فرمت سبک وزن هس که برای تبادل داده‌ها استفاده می‌شه. این بر اساس زیرمجموعه ای از زبان جاواسکریپت‌ـه که اشیا در جاواسکریپت ساخته میشن.

     **[فهرست](#فهرست)**

111. ### قوانین فرمت JSON کدوما هستن؟

     در زیر لیستی از قوانین نحوی `JSON` آمده است
     1. داده‌ها به صورت جفت نام/مقدار هستن
     2. داده‌ها با کاما از هم جدا میشن
     3. براکت‌ها اجسام رو نگه می دارن
     4. براکت‌های مربعی آرایه‌ها رو نگه می دارن

     **[فهرست](#فهرست)**

112. ### هدف از متد JSON.stringify چیه؟

    موقع ارسال داده‌ها به وب سرور، داده‌ها باید در قالب رشته‌ای باشن. شما می‌تونین با تبدیل شی `JSON` به رشته با استفاده از متد `stringify` به این هدف دست یابید.

     <span dir="ltr" align="left">

     ```javascript
     var userJSON = {'name': 'John', age: 31}
     var userString = JSON.stringify(user);
     console.log(userString); //"{"name":"John","age":31}"
     ```

     </span>

     **[فهرست](#فهرست)**

113. ### چطوری می‌تونیم یه رشته(string) JSON رو تجزیه کنیم؟

     موقع دریافت داده‌ها از یه وب سرور، داده‌ها همی‌شه در قالب رشته‌ای هستن. اما می‌تونین این مقدار رشته رو با استفاده از متد `parse` به یه شی جاواسکریپت تبدیل کنین.

     <span dir="ltr" align="left">

     ```javascript
     var userString = '{"name":"John","age":31}';
     var userJSON = JSON.parse(userString);
     console.log(userJSON);// {name: "John", age: 31}
     ```

     </span>

     **[فهرست](#فهرست)**

114. ### چرا به JSON نیاز داریم؟
     موقع تبادل داده بین مرورگر و سرور، داده‌ها فقط میتونن متنی باشن. از اونجایی که `JSON` فقط متنی است، می‌توان اونو به راحتی به سرور ارسال کرد و از اون به عنوان قالب داده توسط هر زبان برنامه‌نویسی استفاده کرد.

     **[فهرست](#فهرست)**

115. ### PWAها چی هستن؟

     `Progressive web applications (PWAs)` نوعی از برنامه‌های تلفن همراه هستن که از طریق وب ارائه میشن، و با استفاده از فناوری‌های رایج وب از جمله `HTML،` `CSS` و جاواسکریپت ساخته میشن،. این `PWA`‌ها در سرورها مستقر میشن، از طریق `URL`‌ها قابل دسترسی هستن و توسط موتورهای جستجو فهرست بندی میشن.

     **[فهرست](#فهرست)**

116. ### هدف از متد clearTimeout چیه؟

     تابع `clearTimeout` در جاواسکریپت برای پاک کردن بازه زمانی استفاده می‌شه که قبل از اون توسط تابع `setTimeout` تنظیم شده است. یعنی مقدار بازگشتی تابع `setTimeout` تو یه متغیر ذخیره می‌شه و برای پاک کردن تایمر به تابع `clearTimeout` منتقل می‌شه.

     برای مثال، از روش `setTimeout` زیر برای نمایش پیام پس از 3 ثانیه استفاده می‌شه. این مهلت زمانی رو می‌شه با روش `clearTimeout` پاک کرد.

     <span dir="ltr" align="left">

     ```html
     <script>
     var msg;
     function greeting() {
        alert('Good morning');
     }
     function start() {
       msg =setTimeout(greeting, 3000);

     }

     function stop() {
         clearTimeout(msg);
     }
     </script>
     ```

     </span>

     **[فهرست](#فهرست)**

117. ### هدف از متد clearInterval چیه؟

     تابع `clearInterval` تو جاواسکریپت برای پاک کردن فاصله ای که توسط تابع `setInterval` تنظیم شده استفاده می‌شه. برای مثال، مقدار بازگشتی که توسط تابع `setInterval` برمی گرده تو یه متغیر ذخیره می‌شه و برای پاک کردن فاصله به تابع `clearInterval` ارسال می‌شه.

     برای مثال، از روش `setInterval` زیر برای نمایش پیام در هر 3 ثانیه استفاده می‌شه. این بازه رو می‌شه با روش `clearInterval` پاک کرد.

     <span dir="ltr" align="left">

     ```html
     <script>
     var msg;
     function greeting() {
        alert('Good morning');
     }
     function start() {
       msg = setInterval(greeting, 3000);

     }

     function stop() {
         clearInterval(msg);
     }
     </script>
     ```

     </span>

     **[فهرست](#فهرست)**

118. ### توی جاواسکریپت، چطوری می‌شه به یه صفحه جدید redirect انجام داد؟

     در `vanila` جاواسکریپت، می‌تونین با استفاده از ویژگی `location` شی پنجره به صفحه جدیدی هدایت بشین.

     <span dir="ltr" align="left">

     ```javascript
     function redirect() {
        window.location.href = 'newPage.html';
     }
     ```

     </span>

     **[فهرست](#فهرست)**

119. ### چطوری بررسی می‌کنین که یه string شامل یه substring هست یا نه؟

     3 روش ممکن برای بررسی اینکه آیا یه رشته دارای یه رشته فرعیه یا نه وجود داره.
     1. **includes استفاده از متد:**  ES6 روش `String.prototype.includes‍` رو برای آزمایش یه رشته حاوی یه رشته فرعی ارائه کرد.

     <span dir="ltr" align="left">

     ```javascript
     var mainString = "hello", subString = "hell";
     mainString.includes(subString)
     ```

     </span>

     1. **استفاده از متد indexOf:** تو یه محیط ES5 یا قدیمی‌تر، می‌تونین از «String.   prototype.indexOf» استفاده کنین که ایندکس یه رشته فرعی رو برمی‌گردونه. اگه مقدار شاخص برابر با 1 نباشه، به این معنیه که رشته فرعی در رشته اصلی وجود داره.

     <span dir="ltr" align="left">

     ```javascript
     var mainString = "hello", subString = "hell";
     mainString.indexOf(subString) !== -1
     ```

     </span>

     1. **استفاده از Regex:** راه حل پیشرفته از روش    آزمون عبارت `Regular ('RegExp.test')    `‍‍استفاده می‌کنه، که امکان آزمایش در برابر    عبارات منظم رو فراهم می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     var mainString = "hello", regex = "/hell/";
     regex.test(mainString)
     ```

     </span>

     **[فهرست](#فهرست)**

120. ### توی جاواسکریپت، چطوری مقدار یه آدرس email رو اعتبارسنجی می‌کنین؟

     می‌تونین با استفاده از `Regex` ایمیل رو در جاواسکریپت تأیید کنین. توصیه می‌شه به جای سمت کلاینت، اعتبارسنجی در سمت سرور انجام شه. چون جاواسکریپت رو می‌شه در سمت کلاینت غیرفعال کرد.

     <span dir="ltr" align="left">

     ```javascript
     function validateEmail(email) {
         var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
         return re.test(String(email).toLowerCase());
     }
     ```

     </span>

     **[فهرست](#فهرست)**

     `Regex` بالا کاراکترهای یونیکد رو می پذیرد.

121. ### چطوری می‌تونیم مقدار آدرس url جاری رو بخونیم؟

     می‌تونین از عبارت `window.location.href` برای دریافت مسیر آدرس فعلی استفاده کنین و می‌تونین از همون عبارت برای به‌روزرسانی URL هم استفاده کنین. همچنین می‌تونین از `document.URL` برای اهداف فقط خواندنی استفاده کنین اما این راه‌حل مشکلاتی در FF داره.

     <span dir="ltr" align="left">

     ```javascript
     console.log('location.href', window.location.href); // Returns full URL
     ```

     </span>

     **[فهرست](#فهرست)**

122. ### ویژگی‌های مختلف url روی object مربوط به history کدوما هستن؟

     برای دسترسی به اجزای URL صفحه می‌توان از ویژگی‌های شی `location` زیر استفاده کرد.
     1. href - ورودی URL
     2. protocol - پروتکل استفاده شده URL
     3. host -‌هاست و پورت URL
     4. hostname -‌هاست URL
     5. port - شماره پورت  URL
     6. pathname - مسیر  URL
     7. search - قسمت جستجو URL
     8. hash - محل جای‌گیری URL

     **[فهرست](#فهرست)**

123. ### توی جاواسکریپت چطوری می‌تونیم مقدار یه query-string رو بخونیم؟

     می‌تونین از `URLSearchParams` برای دریافت مقادیر رشته پرس و جو در جاواسکریپت استفاده کنین. بیاین مثالی برای دریافت مقدار کد مشتری از رشته پرس و جو `URL` ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     const urlParams = new URLSearchParams(window.location.search);
     const clientCode = urlParams.get('clientCode');
     ```

     </span>

     **[فهرست](#فهرست)**

124. ### چطوری می‌تونیم بررسی کنیم که آیا یه پراپرتی روی آبجکت وجود داره یا نه؟


     1. **استفاده از عملگر‌ها:** شما می‌تونیم از عملگر in استفاده کنین که آیا کلیدی تو یه شی       وجود داره یا نه

     <span dir="ltr" align="left">

     ```javascript
     "key" in obj
     ```

     </span>

     و اگه می‌خواین بررسی کنین که آیا کلید وجود نداره، به یاد داشته باشیم که از پرانتز استفاده کنین

     <span dir="ltr" align="left">

     ```javascript
     !("key" in obj)
     ```

     </span>

     2. **استفاده از متد hasOwnProperty:**    می‌تونین از `hasOwnProperty` برای آزمایش ویژگی‌های نمونه شی (و نه ویژگی‌های ارثی)       استفاده کنین.

     <span dir="ltr" align="left">

     ```javascript
     obj.hasOwnProperty("key") // true
     ```

     </span>

     3. **استفاده از مقایسه undifiend:** اگر از یه شی به یه ویژگی غیر موجود دسترسی پیدا کنید، نتیجه undifiend است. بیاین ویژگی‌ها را با undefined مقایسه کنیم تا وجود ویژگی را مشخص کنیم.

     <span dir="ltr" align="left">

     ```javascript
     const user = {
       name: 'John'
     };

     console.log(user.name !== undefined);     // true
     console.log(user.nickName !== undefined); // false
     ```

     </span>

     **[فهرست](#فهرست)**

126. ### چطوری روی یه object حلقه میزنی؟

     می‌تونین از حلقه `for-in` برای حلقه زدن شی جاواسکریپت استفاده کنین. همچنین می‌تونین مطمئن شین که کلیدی که دریافت می‌کنین یه ویژگی واقعی یه آبجکته و با استفاده از روش `hasOwnProperty` از نمونه اولیه نیست.

     <span dir="ltr" align="left">

     ```javascript
     var object = {
         "k1": "value1",
         "k2": "value2",
         "k3": "value3"
     };

     for (var key in object) {
         if (object.hasOwnProperty(key)) {
             console.log(key + " -> " + object[key]); // k1 -> value1 ...
         }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

127. ### چطوری تست می‌کنی که یه object خالیه؟

     راه حل‌های مختلفی بر اساس نسخه‌های `ECMAScript` وجود داره
  1. **استفاده Object entries(ECMA 7+):** 
  می‌تونیم از ‍‍`object entries` استقاده کنیم و `length` اونا رو چک کنیم

     <span dir="ltr" align="left">

     ```javascript
     Object.entries(obj).length === 0 && obj.constructor === Object // Since date object length is 0, you need to check constructor check as well
     ```

     </span>

     1. **استفاده از Object keys(ECMA 5+):** 
     می‌تونیم از`object keys‍` استفاده کنیم و    `length‍` اونو چک کنیم

     <span dir="ltr" align="left">

     ```javascript
     Object.keys(obj).length === 0 && obj.constructor === Object // Since date object length is 0, you need to check constructor check as well
     ```

     </span>

     1. **استفاده از for-in با متد hasOwnProperty   (Pre-ECMA 5):** می‌تونیم از حلفه    `for-in`استفاده کنیم و هر پارامتر رو با    `hasOwnProperty‍` چک کنیم

     <span dir="ltr" align="left">

     ```javascript
     function isEmpty(obj) {
       for(var prop in obj) {
         if(obj.hasOwnProperty(prop)) {
           return false;
         }
       }

       return JSON.stringify(obj) === JSON.stringify({});
     }
     ```

     </span>

     **[فهرست](#فهرست)**

128. ### arguments object چیه؟

     شیء آرگومان‌ها یه شیء آرایه ماننده که در داخل توابع قابل دسترسیه و حاوی مقادیر آرگومان‌های ارسال شده به اون تابعه. برای مثال، بیاین ببینیم چگونه از شیء آرگومان‌ها در تابع sum استفاده کنیم

     <span dir="ltr" align="left">

     ```javascript
     function sum() {
         var total = 0;
         for (var i = 0, len = arguments.length; i < len; ++i) {
             total += arguments[i];
         }
         return total;
     }

     sum(1, 2, 3) // returns 6
     ```

     </span>

     **نکته:** شما نمی‌تونین از متد‌های ارایه برای این شی ارگومان‌ها استفاده کنین اما می‌تونین به ارایه تبدیلش کنین 

     <span dir="ltr" align="left">

     ```javascript
     var argsArray = Array.prototype.slice.call(arguments);
     ```

     </span>

     **[فهرست](#فهرست)**

129. ### چطوری حرف اول یه رشته رو به حرف بزرگ تبدیل می‌کنی؟

     می‌تونیم با درست کردن یه تابع که با استفاده از زنجیره ای از متد‌های استرینگ‌ها مثلا `charAt` و `toUpperCase` و `slice` یه استرنیگ با حرف اول بزرگ ایجاد کرد

     <span dir="ltr" align="left">

     ```javascript
     function capitalizeFirstLetter(string) {
         return string.charAt(0).toUpperCase() + string.slice(1);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

130. ### مزایا و معایب حلقه for چیا هستن؟

     حلقه `for` یه سینتکس تکراری رایج در جاواسکریپت‌ـه که هم مزایا و هم معایب داره
     
     #### مزایا
     1. توی همه‌ی محیط‌ها `env` کار می‌کنه
     2. می‌تونیم از `break` و `‍continue‍` برای کنرل    جریان داده استفاده کرد

     #### معایب
     1. پر هزینه
     2. ضروریت
     3. ممکنه با خطاهای یه به یه روبرو شین

     **[فهرست](#فهرست)**

131. ### چطوری تاریخ جاری رو توی جاواسکریپت نشون میدی؟

     شما می‌تونین از کلاس `new Date` استفاده کنین که یه آبجکت از زمان و تاریخ بهمون میده بریم یه مثال ازش ببینیم

     <span dir="ltr" align="left">

     ```javascript
     var today = new Date();
     var dd = String(today.getDate()).padStart(2, '0');
     var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!
     var yyyy = today.getFullYear();

     today = mm + '/' + dd + '/' + yyyy;
     document.write(today);
     ```

     </span>

     **[فهرست](#فهرست)**

132. ### چطوری دو تا date object رو با هم مقایسه می‌کنی؟

     برای این کار باید از متد getTime که برا روی date قرار داره استفاده کرد و نباید از اپراتور‌ها استفاده کنیم

     <span dir="ltr" align="left">

     ```javascript
     var d1 = new Date();
     var d2 = new Date(d1);
     console.log(d1.getTime() === d2.getTime()); //True
     console.log(d1 === d2); // False
     ```

     </span>

     **[فهرست](#فهرست)**

133. ### چطوری بررسی می‌کنی که یه رشته با یه رشته دیگه شروع می‌شه؟

     ما می‌تونیم از متد startWith که بر روی پرتوتایپ رشته‌ها وجود داره استفاده کرد که یه رشته رو می‌گیره و چک می‌کنه که با اون شروع می‌شه رشته مورد نظر یا نه بریم یه مثال ببینیم در موردش

     <span dir="ltr" align="left">

     ```javascript
     "Good morning".startsWith("Good"); // true
     "Good morning".startsWith("morning"); // false
     ```

     </span>

     **[فهرست](#فهرست)**

134. ### چطوری یه رشته رو trim می‌کنی؟

     جاواسکریپت یه متد به ما میده به اسم `trim` که روی استرینگ‌ها قرار داره با استفاده از این متد همه ی فضای خالی بین اون استرینگ برداشته می‌شه

     <span dir="ltr" align="left">

     ```javascript
     "  Hello World   ".trim(); //Hello World
     ```

     </span>

     If your browser(<IE9) doesn't support this method then you can use below polyfill.

     <span dir="ltr" align="left">

     ```javascript
     if (!String.prototype.trim) {
         (function() {
             // Make sure we trim BOM and NBSP
             var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
             String.prototype.trim = function() {
                 return this.replace(rtrim, '');
             };
         })();
     }
     ```

     </span>

     **[فهرست](#فهرست)**

135. ### توی جاواسکریپت چطوری می‌تونیم یه زوج مرتب از key یه valueها بسازیم؟

     برای اضافه کردن key جدید به ابجک‌ها دو روش وجود دارن

     <span dir="ltr" align="left">

     ```javascript
     var object = {
         key1: value1,
         key2: value2
     };
     ```

     </span>

     1. **Using dot notation:** این روش زمانی موثر    هستش که اسم پراپرتی رو میدونیم

     <span dir="ltr" align="left">

     ```javascript
     object.key3 = "value3";
     ```

     </span>

     1. **Using square bracket notation:** این روش    وقتی موثره که اسم پراپرتی داینامیک باشه

     <span dir="ltr" align="left">

     ```javascript
     obj["key3"] = "value3";
     ```

     </span>

     **[فهرست](#فهرست)**

136. ### آیا عبارت '!--' عملگر خاصی هست؟

     نه! اون یه اپراتور خاص نیست اما ترکیب شده دو تا اپراتور استانداره هستش یکی بعد اون یکی
     1. اپراتور نقییض (!)
     2. کاهش کننده(--)

     اول یه شماره از مقدار متغیر به مثال کم می‌شه بعد تست می‌شه که مساوی صفر هستش یا نه که مشخص‌کننده درست یا غلط بودن شرط هستش

     **[فهرست](#فهرست)**

137. ### چطوری می‌تونیم به متغیرهامون مقادیر اولیه بدیم؟

     می‌تونیم از عملگر یا اپراتور ‍`||` استفاده تعریف یه مقدار پیش‌فرض استفاده کرد مانند مثال زیر

     <span dir="ltr" align="left">

     ```javascript
     var a = b || c;
     ```

     </span>

     مثال تعریف شده بالا مقدار متغیر a زمانی برابر مقدار متغیر c خواهد شد که b خالی false یا undifined باشه 

     **[فهرست](#فهرست)**

138. ### چطوری می‌تونیم متن‌های چند خطی درست کنیم؟

     ما می‌تونیم از `/` برای تعریف کردن رشته‌های چند لایه استفاده کنیم برای مثال 

     <span dir="ltr" align="left">

     ```javascript
     var str = "This is a \
     very lengthy \
     sentence!";
     ```

     </span>

     اما اگه یه فاصله بعد ‍‍‍`/` داشته باشیم,کد دقیقا به همون حالتی که هست نشون داده می‌شه اما یه ارور خطای نوشتاری کد قراره داشته باشیم

     **[فهرست](#فهرست)**

139. ### مدل app-shell چیه؟

     application shell (shell) یکی از راه‌های ساخت یه PWA هس که به طور قابل اعتماد و فوری بر روی صفحه نمایش کاربران شما بارگیری می‌شه، مشابه اونجه در برنامه‌های کاربردی بومی مشاهده می‌کنین. برای رسوندن سریع HTML اولیه به صفحه بدون شبکه مفیده.

     **[فهرست](#فهرست)**

140. ### چطوری می‌تونیم روی یه تابع property اضافه کنیم؟

     بله ما می‌تونیم برای توابع پراپرتی تعیین کنیم چون توابع اصولا آبجکت هستن.

     <span dir="ltr" align="left">

     ```javascript
     fn = function(x) {
        //Function code goes here
     }

     fn.name = "John";

     fn.profile = function(y) {
       //Profile code goes here
     }
     ```

     </span>

     **[فهرست](#فهرست)**

141. ### چطوری می‌تونیم تعداد پارامترهای ورودی یه تابع رو به دست بیاریم؟

     با استفاده کردن از `function.length` ما می‌تونیم به تعداد پارامتر‌هایی که یه تابع انتظار داره بگیره دسترسی داشته باشیم بریم یه مثال درموردش ببینیم

     <span dir="ltr" align="left">

     ```javascript
     function sum(num1, num2, num3, num4){
         return num1 + num2 + num3 + num4;
     }
     sum.length // 4 is the number of parameters expected.
     ```

     </span>

     **[فهرست](#فهرست)**

142. ### Polyfill چیه؟

     یه `plyfill` یه قسمت از کد جاوااسکریپته که با استفاده از اون ما می‌تونیم توابع پیشرفته رو روی مروگر‌هایی که به طور طبیعی پشتیبانی نمیکنن,استفاده کنیم. پلاگین `Silverlight` که برای تقلید کردن توابع بر روی `canvas` یا مروگر `IE7` استفاده کرد

     **[فهرست](#فهرست)**

143. ### عبارات Break و continue چی هستن؟

     دستور `break` برای "پرش به بیرون" از یه حلقه استفاده می‌شه. یعنی حلقه رو می شکنه و اجرای کد رو بعد از حلقه ادامه میده.

     <span dir="ltr" align="left">

     ```javascript
     for (i = 0; i < 10; i++) {
       if (i === 5) { break; }
       text += "Number: " + i + "<br>";
     }
     ```

     </span>

     دستور `continue` برای "پرش از روی" یه تکرار در حلقه استفاده می‌شه. یعنی یه تکرار (در حلقه) رو می شکنه، اگه شرایط مشخصی رخ بده، و با تکرار بعدی در حلقه ادامه می ده.

     <span dir="ltr" align="left">

     ```javascript
     for (i = 0; i < 10; i++) {
         if (i === 5) { continue; }
         text += "Number: " + i + "<br>";
     }
     ```

     </span>

     **[فهرست](#فهرست)**

144. ### توی جاواسکریپت labelها چیکار می‌کنن؟

     دستور `label` به ما اجازه می ده تا حلقه‌ها و بلوک‌ها رو در جاواسکریپت نام گذاری کنیم. سپس می‌تونیم از این برچسب‌ها برای مراجعه به کد بعداً استفاده کنیم. برای مثال، کد زیر با برچسب‌ها از چاپ اعداد در صورت یکسان بودن اونا جلوگیری می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     var i, j;

     loop1:
     for (i = 0; i < 3; i++) {
        loop2:
        for (j = 0; j < 3; j++) {
           if (i === j) {
              continue loop1;
           }
           console.log('i = ' + i + ', j = ' + j);
        }
     }

     // Output is:
     //   "i = 1, j = 0"
     //   "i = 2, j = 0"
     //   "i = 2, j = 1"
     ```

     </span>

     **[فهرست](#فهرست)**

145. ### مزایای declare کردن متغیرها در اوایل کد چیه؟

     توصیه می‌شه تمام اعلان‌ها رو بالای هر اسکریپت یا تابع نگه دارین. مزیت این کار 
     1. کد ما تمیز تر می‌شه
     2. این یه مکان واحد برای جستجوی متغیرهای محلی    فراهم می کنه
     3. می‌شه راحت از استفاده متفیر‌های ناخواسته    جلوگیری کرد 
     4. این کار محاسبات ناخواسته رو کمتر می‌کنه

     **[فهرست](#فهرست)**

146. ### مزایای مقداردهی اولیه متغیرها چیه؟

     توضیه می‌شه که مقدار اولیه برای متغیرها تعیین بشه که دلایلشو چک می‌کنیم 
     1. خروجیمون کد تمیز تری می‌شه
     2. این کار باعث می‌شه یه جا برای این متغییر    رزرو بشه
     3. از برگشتن خطای `undefind`جلوگیری می‌شه

     **[فهرست](#فهرست)**

147. ### روش توصیه شده برای ایجاد object چیه؟

     برای ساخت یه `object` با مقادیر پیشفرش مثال‌های زیر روش‌های ساخت مقادیر پیشفرض رو بررسی می‌کنیم
     1. استفاده از {} به جای `new Object`
     2. استفاده از "" به جای `new String`
     3. استفاده از 0 به جای `new Number`
     4. استفاده از false به جای  `new Boolean`
     5. استفاده از [] به جای `new Array`
     6. استفاده از /()/ به جای `new RegExp`
     7. استفاده از (){} به جای`new Function`

     بریم یه چن تا مثال ببینیم

     <span dir="ltr" align="left">

     ```javascript
     var v1 = {};
     var v2 = "";
     var v3 = 0;
     var v4 = false;
     var v5 = [];
     var v6 = /()/;
     var v7 = function(){};
     ```

     </span>

     **[فهرست](#فهرست)**

148. ### چطوری می‌تونیم آرایه‌ JSON تعریف کنیم؟

     آرایه‌های JSON نوشته شده در داخل براکت‌ها و ارایه‌هایی که دارای object هستن بریم یه مثال درموردش ببینیم

     <span dir="ltr" align="left">

     ```javascript
     "users":[
       {"firstName":"John", "lastName":"Abrahm"},
       {"firstName":"Anna", "lastName":"Smith"},
       {"firstName":"Shane", "lastName":"Warn"}
     ]
     ```

     </span>

     **[فهرست](#فهرست)**

149. ### چطوری می‌تونیم اعداد تصادفی تولید کنیم؟

     ما می‌تونیم از متد Math.random برای ساخت یه عدد رندوم بین ۰ تا یه و از متد Math.floor برای رند کردن اون عدد استفاده کنیم حالا حاصل عدد به دست اومده رو ضربدر ده کنیم عددی بین یه تا ده خواهیم داشت

     <span dir="ltr" align="left">

     ```javascript
     Math.floor(Math.random() * 10) + 1;     // returns a random integer from 1 to 10
     Math.floor(Math.random() * 100) + 1;     // returns a random integer from 1 to 100
     ```

     </span>

     **نکته:** Math.random یه عدد تصادفی بین 0 (شامل) و 1 (انحصاری) برمی‌گردونه.

     **[فهرست](#فهرست)**

150. ### می‌تونی یه تابع تولید اعداد تصادفی توی یه بازه مشخص بنویسی؟

     بله ما می‌تونیم این تابع رو داشته باشیم که مقادیر حداکثر و حداقل رو بگیره و برای ما عدد رندوم ایجاد کنه 

     <span dir="ltr" align="left">

     ```javascript
     function randomInteger(min, max) {
       return Math.floor(Math.random() * (max - min + 1) ) + min;
     }
     randomInteger(1, 100); // returns a random integer from 1 to 100
     randomInteger(1, 1000); // returns a random integer from 1 to 1000
     ```

     </span>

     **[فهرست](#فهرست)**

151. ### Tree-shaking چیه؟

     Tree Shaking نوعی حذف کد مرده هستش. این بد این معنیه که ماژول‌های استفاده نشده در طول فرآیند ساخت در بسته گنجونده نمی‌شن و برای اون بر ساختار استاتیک ماژول ES2015 متکیه (یعنی import و export). در ابتدا این باندلر ماژول ES2015 'rollup' رایج شد.

     **[فهرست](#فهرست)**

152. ### دلایل نیاز به tree-shaking کدوما هستن؟

     Tree Shaking می‌تونه اندازه کد رو در هر برنامه ای به میزان قابل توجهی کاهش بده. یعنی هرچی کد کمتری از طریق سیم بفرستیم برنامه کاربردی تره. به عنوان مثال، اگر فقط بخواهیم یه برنامه Hello World با استفاده از چارچوب‌های SPA ایجاد کنیم، حدود چند مگابایت طول می کشد، اما با tree-shaking می‌تونه اندازه رو به چند صد کیلوبایت کاهش بده. tree-shaking در باندلرهای Rollup و Webpack پیاده سازی شده.

     **[فهرست](#فهرست)**

153. ### آیا استفاده از eval توصیه می‌شه؟

     خیر، اجازه اجرای کد دلخواه رو میده که باعث ایجاد مشکل امنیتی می‌شه. همونطور که میدونیم از تابع `eval` برای اجرای متن به عنوان کد استفاده می‌شه. در بیشتر موارد استفاده از اون ضروری نیست.

     **[فهرست](#فهرست)**

154. ### Regular-Expression چیه؟

     regular expression یا همون Regex یه توالیه که یه ساختار جستجو ایجاد می‌کنه با استفاده از این ساختاذ ما می‌تونیم دیتامون رو بر اساس یه ساختار که مینویسم جستجو کنیم و به قولی دیتامون رو اعتبارسنجی کنیم

     <span dir="ltr" align="left">

     ```javascript
     /pattern/modifiers;
     ```

     </span>

     برای مثال Regex حساس به حروف کوچک و بزرگ زبان انگلیسی به صورت ریر نوشته می‌شه

     <span dir="ltr" align="left">

     ```javascript
     /John/i
     ```

     </span>

     **[فهرست](#فهرست)**

155. ### متدهای رشته که روی Regular-expression مجاز هستن کدوماست؟

     Regular Expressions دو تا متد برای رشته‌ّها داره :‌ search و replace. متد search یه عبارت رو می‌گیره اونو جسنجو می‌کنه و محل اون عبارت رو برمی‌گردونه

     <span dir="ltr" align="left">

     ```javascript
     var msg = "Hello John";
     var n = msg.search(/John/i); // 6
     ```

     </span>

     متد replace برای برگردوندن رشته اصلاح شده در جایی که الگو جایگزین می‌شه استفاده می‌شه

     <span dir="ltr" align="left">

     ```javascript
     var msg = "Hello John";
     var n = msg.replace(/John/i, "Buttler"); // Hello Buttler
     ```

     </span>

     **[فهرست](#فهرست)**

156. ### توی Regex بخش modifiersها چیکار می‌کنه؟

     Modifier میتونن زمانی استفاده بشن که به جستجو‌های بدون حروف کوچک و بزرگ سراسری نیاز داریم بیاین یه مثال درموردشون ببینیم

     | اصلاح کننده | توضیح |
     |:----: | :---------:
     | i  | تظبیق حساس به حروف |
     | g | تطبیق کلی به جای توقف در اولین تشابه  |
     | m | تطبیق چندخطی|

     بریم یه مثال از modifier  گلوبال ببینیم

     <span dir="ltr" align="left">

      ```javascript
      var text = "Learn JS one by one";
      var pattern = /one/g;
      var result = text.match(pattern); // one,one
      ```

      </span>

     **[فهرست](#فهرست)**

157. ### پترن‌های regular-expression چیه؟

     Regex یه گروهی از ساختار‌ها برامون اماده کرده که با اونا کاراکتر‌ها رو چک کنیم اونا تو سه مدل طبفه بندی میشن
     1. **براکت‌ها:** این‌ها استفاده میشن تا یه        رنجی از کاراکتر رو پیدا کنن 
     برای مثال پایین چن تا مورد اصتفاده لیست شدن
     1. [abc]: استفاده می‌شه تا هر کاراکتری بین    این سه کاراکتر پیدا بشه 
     2. [0-9]: استفاده می‌شه تا ارقام بین این دو   عدد پیدا بشه
     3. (a|b): برای پیدا کردن هر یه از گزینه‌های جدا شده با | استفاده می‌شه
     2. **کاراکتر برابر با:** این عبارت‌ها کاراکتر‌هایی با معنی خاص هستن
     برای مثال پایین دو تا مورد که استفاده می‌شه ازشون رو ببینیم
     1. \\d: استفاده برای پیدا کردن اعداد
     2. \\s: استفاده برای ‍پیدا کردن فاصله‌ها
     3. \\b: استفاده برای پیدا کردن کاراکتر‌های همخوانی داشته با شروع شدن یا پایانشون
     3. **کمیت کننده‌ها:** این‌ها برای  تعریف کمیت‌ها موثر هستن
     برای مثال پایین دو تا مورد استفاده براشون اوردیم
     1. n+: برای پیدا کردن رشته همخوانی داشته با حداقل یه کاراکتر
     2. n*: برای پیدا کردن همخوانی هر رشته شامل صفر یا بیشتر
     3. n?: برای پیدا کردن هر رشته که شامل صفر یا یه کاراکنر می‌شه
     
     **[فهرست](#فهرست)**

158. ### آبجکت RegExp چیه؟

     `object`‌های `Regex` یه عبارت معمولی با پراپرتی‌ها و متد‌های تعریف شده از قبل هس. بریم یه مثال از نحوه استفادشون ببینیم.

     <span dir="ltr" align="left">

     ```javascript
     var regexp = new RegExp('\\w+');
     console.log(regexp);
     // expected output: /\w+/
     ```

     </span>

     **[فهرست](#فهرست)**

159. ### چطوری روی یه رشته دنبال یه پترن RegExp می‌گردی؟

     می‌تونین از متد test عبارت منظم برای جستجوی یه رشته برای الگو استفاده کنین و بسته به نتیجه، true یا false رو برگردونین.

     <span dir="ltr" align="left">

     ```javascript
     var pattern = /you/;
     console.log(pattern.test("How are you?")); //true
     ```

     </span>

     **[فهرست](#فهرست)**

160. ### هدف از متد exec چیه؟

     هدف متد exec شبیه به روش تست است، اما جستجوی یه تطابق تو یه رشته مشخص رو انجام میده و یه آرایه نتیجه یا null رو به جای برگردوندن true/false برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     var pattern = /you/;
     console.log(pattern.exec("How are you?")); //["you", index: 8, input: "How are you?", groups: undefined]
     ```

     </span>

     **[فهرست](#فهرست)**

161. ### چطوری استایل‌های یه المنت HTML رو تغییر میدی؟

     شما می‌تونین سبک درون خطی یا اسم کلاس یه عنصر HTML رو با استفاده از جاواسکریپت تغییر بدین

     1. **استفاده از پراپرتی استایل:** با استفاده از ویژگی style می‌تونین استایل درون خطی رو تغییر بدین

     <span dir="ltr" align="left">

     ```javascript
     document.getElementById("title").style.fontSize = "30px";
     ```

     </span>

     2. **استفاده از پراپرتی className:** تغییر کلاس عنصر با استفاده از ویژگی className آسان است

     <span dir="ltr" align="left">

     ```javascript
      document.getElementById("title").style.className = "custom-title";
     ```

     </span>

     **[فهرست](#فهرست)**

162. ### نتیجه عبارت 1+2+'3' چی می‌شه؟

     خروجی '33' می‌شه. از اونجایی که «1» و «2» مقادیر عددی هستن، نتیجه دو رقم اول یه مقدار عددی «3» خواهد بود. رقم بعدی یه مقدار نوع رشته اس چون افزودن مقدار عددی «3» و مقدار رشته «3» فقط یه مقدار الحاقی «33» می‌شه.

     **[فهرست](#فهرست)**

163. ### عبارت debugger چیکار می‌کنه؟

     دستور debugger هر گونه عملکرد اشکال زدایی موجود رو فراخوانی می‌کنه، مانند تعیین breakpoint. اگه هیچ عملکرد اشکال زدایی در دسترس نباشه، این عبارت تاثیری نداره.
     برای مثال، در تابع زیر یه دستور debugger درج شده. بنابراین
     اجرا در دستور debugger مانند یه breakpoint در منبع اسکریپت متوقف می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     function getProfile() {
     // code goes here
     debugger;
     // code goes here
     }
     ```

     </span>

     **[فهرست](#فهرست)**

164. ### هدف از breakpointها توی debugging چیه؟

     پس از اجرای دستور debugger و باز شدن پنجره دیباگر، می‌تونین breakpointها رو در کد جاواسکریپت تنظیم کنین. در هر breakpoint، جاواسکریپت اجرا نمی‌شه و به شما اجازه میده مقادیر جاواسکریپت رو بررسی کنین. پس از بررسی مقادیر، می‌تونین با استفاده از دکمه پخش، اجرای کد رو از سر بگیرید.

     **[فهرست](#فهرست)**

165. ### آیا می‌تونیم از عبارت‌های رزرو شده در تعریف identifierها(اسم متغیر، کلاس و ...) استفاده کنیم؟

     نه، شما نمی‌تونین از کلمات رزرو شده به عنوان متغیر، برچسب، اسم آبجکت یا تابع استفاده کنین. بیاین یه مثال ساده رو ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     var else = "hello"; // Uncaught SyntaxError: Unexpected token else
     ```

     </span>

     **[فهرست](#فهرست)**

166. ### چطوری تشخیص بدیم که یه مرورگر mobile هست یا نه؟

     ما می‌تونیم با استفاده از Regex که یه boolean به ما برمی‌گردونه بفهمیم که مرورگری که کاربر داره ازش استفاده می‌کنه چیه.

     <span dir="ltr" align="left">

     ```javascript
     window.mobilecheck = function() {
       var mobileCheck = false;
       (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) mobileCheck = true;})(navigator.userAgent||navigator.vendor||window.opera);
       return mobileCheck;
     };
     ```

     </span>

     **[فهرست](#فهرست)**

167. ### چطوری بدون Regex تشخیص بدیم که یه مرورگر mobile هست یا نه؟

     می‌تونیم مرورگرهای تلفن همراه رو با اجرای فهرستی از دستگاه‌ها و بررسی اینکه آیا `useragent` با چیزی مطابقت داره یا نه، شناسایی کنیم. این یه راه حل جایگزین برای استفاده از RegExp هستش

     <span dir="ltr" align="left">

     ```javascript
     function detectmob() {
      if( navigator.userAgent.match(/Android/i)
          || navigator.userAgent.match(/webOS/i)
          || navigator.userAgent.match(/iPhone/i)
          || navigator.userAgent.match(/iPad/i)
          || navigator.userAgent.match(/iPod/i)
          || navigator.userAgent.match(/BlackBerry/i)
          || navigator.userAgent.match(/Windows Phone/i)
      ){
         return true;
       }
      else {
         return false;
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

168. ### چطوری طول و عرض یه تصویر رو با جاواسکریپت به دست میاری؟

     ما می‌تونیم با استفاده از جاواسکریپت به صورت برنامه ریزی شده تصویر رو بدست بیاریم و ابعاد (عرض و ارتفاع) رو بررسی کنیم.

     <span dir="ltr" align="left">

     ```javascript
     var img = new Image();
     img.onload = function() {
       console.log(this.width + 'x' + this.height);
     }
     img.src = 'http://www.google.com/intl/en_ALL/images/logo.gif';
     ```

     </span>

     **[فهرست](#فهرست)**

169. ### چطوری درخواست‌های synchronous HTTP بزنیم؟

     مرورگرها یه شی `XMLHttpRequest` ارائه می‌دن که می‌تونه برای ایجاد درخواست‌های `HTTP` همزمان از جاواسکریپت استفاده شه.

     <span dir="ltr" align="left">

     ```javascript
     function httpGet(theUrl) {
         var xmlHttpReq = new XMLHttpRequest();
         xmlHttpReq.open( "GET", theUrl, false ); // false for synchronous request
         xmlHttpReq.send( null );
         return xmlHttpReq.responseText;
     }
     ```

     </span>

     **[فهرست](#فهرست)**

170. ### چطوری درخواست‌های asynchronous HTTP بزنیم؟

     مرورگرها یه شی `XMLHttpRequest` رو ارائه می‌دن که می‌تونن برای درخواست‌های `HTTP` ناهمزمان از جاواسکریپت با ارسال پارامتر سوم به عنوان `true` استفاده کنن.

     <span dir="ltr" align="left">

     ```javascript
     function httpGetAsync(theUrl, callback)
     {
         var xmlHttpReq = new XMLHttpRequest();
         xmlHttpReq.onreadystatechange = function() {
             if (xmlHttpReq.readyState == 4 && xmlHttpReq.status == 200)
                 callback(xmlHttpReq.responseText);
         }
         xmlHttp.open("GET", theUrl, true); // true for asynchronous
         xmlHttp.send(null);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

171. ### چطوری یه تاریخ رو به یه تاریخ در timezone دیگه تبدیل کنیم؟

     می‌تونیم از متد `toLocaleString` برای تبدیل تاریخ‌ها تو یه منطقه زمانی به منطقه زمانی دیگر استفاده کنیم.بریم یه مثال درموردش ببینیم.

     <span dir="ltr" align="left">

     ```javascript
     console.log(event.toLocaleString('en-GB', { timeZone: 'UTC' })); //29/06/2019, 09:56:00
     ```

     </span>

     **[فهرست](#فهرست)**

172. ### چه propertyهایی برای اندازه‌گیزی سایز window به کار میره؟

     می‌تونیم از ویژگی‌های `innerWidth،` `innerHeight،` `clientWidth،` `clientHeight` ویندوز، عنصر document و اشیاء بدنه document برای یافتن اندازه یه پنجره استفاده کنیم. بیاین از ترکیب اونا برای محاسبه اندازه یه window یا document استفاده کنیم.

     <span dir="ltr" align="left">

     ```javascript
     var width = window.innerWidth
          || document.documentElement.clientWidth
          || document.body.clientWidth;

     var height = window.innerHeight
          || document.documentElement.clientHeight
          || document.body.clientHeight;
     ```

     </span>

     **[فهرست](#فهرست)**

173. ### عملگر شرطی سه گانه توی جاواسکریپت چیه؟

     عملگر شرطی (ternary) تنها عملگر جاواسکریپت هستش که سه عملوند رو می‌گیره که به عنوان میانبر برای دستور if عمل می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     var isAuthenticated = false;
     console.log(isAuthenticated ? 'Hello, welcome' : 'Sorry, you are not authenticated'); //Sorry, you are not authenticated
     ```

     </span>

     **[فهرست](#فهرست)**

174. ### آیا می‌شه روی عملگر شرطی زنجیره شرط‌ها رو اعمال کرد؟

     بله، می‌تونیم زنجیره‌سازی رو روی عملگرهای شرطی مشابه `if … else if … else if… other chain` اعمال کنیم.

     <span dir="ltr" align="left">

     ```javascript
     function traceValue(someParam) {
         return condition1 ? value1
              : condition2 ? value2
              : condition3 ? value3
              : value4;
     }

     // The above conditional operator is equivalent to:

     function traceValue(someParam) {
         if (condition1) { return value1; }
         else if (condition2) { return value2; }
         else if (condition3) { return value3; }
         else { return value4; }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

175. ### روش‌های اجرای جاواسکریپت بعد از لود شدن صفحه کدوما هستن؟

     1. **window.onload:**

     <span dir="ltr" align="left">

     ```javascript
     window.onload = function ...
     ```

     </span>

     2. **document.onload:**

     <span dir="ltr" align="left">

     ```javascript
     document.onload = function ...
     ```

     </span>

     3. **body onload:**

     <span dir="ltr" align="left">

     ```javascript
     <body onload="script();">
     ```

     </span>

     **[فهرست](#فهرست)**

176. ### تفاوت‌های بین proto و prototype کدوما هستن؟

     آبجکت‌ای `__proto__` آبجکت واقعیه که در زنجیره جستجو برای حل متدها و غیره استفاده می‌شه. در حالی که `prototype` آبجکت‌ای‌ـه که برای ساخت `__proto__`استفاده می‌شه زمانی که یه آبجکت با جدید ایجاد می‌کنین.

     <span dir="ltr" align="left">

     ```javascript
     ( new Employee ).__proto__ === Employee.prototype;
     ( new Employee ).prototype === undefined;
     ```

     </span>

     **[فهرست](#فهرست)**

177. ### میتونی یه مثال از زمانی که واقعا به سمیکولون( ; ) نیاز هست بزنی؟

     توصیه می‌شه بعد از هر عبارت در جاواسکریپت از نقطه ویرگول استفاده کنیم. برای مثال، در مورد زیر به دلیل از دست دادن نقطه ویرگول، خطای `.. is not a function` رو در زمان اجرا میندازه.

     <span dir="ltr" align="left">

     ```javascript
     // define a function
     var fn = function () {
         //...
     } // semicolon missing at this line

     // then execute some code inside a closure
     (function () {
         //...
     })();
     ```

     </span>

     و از اون بدست میاد

     <span dir="ltr" align="left">

     ```javascript
     var fn = function () {
         //...
     }(function () {
         //...
     })();
     ```

     </span>

     در این حالت، تابع دوم رو به عنوان آرگومان به تابع اول ارسال می‌کنیم و سعی می‌کنیم نتیجه فراخوانی تابع اول رو به عنوان تابع فراخوانی کنیم. از این رو، تابع دوم با خطای`.. is not a function` در زمان اجرا ارور می‌گیریم.

     **[فهرست](#فهرست)**

178. ### متد freeze چیکار می‌کنه؟

     متد **freeze** برای فریز کردن یه آبجکت استفاده می‌شه. ثابت کردن یه آبجکت اجازه افزودن ویژگی‌های جدید به یه آبچکت رو نمی‌ده. از حذفش جلوگیری می‌کنه و از تغییر قابلیت شمارش پذیری، پیکربندی یا قابلیت نوشتن ویژگی‌های موجود جلوگیری می‌کنه. یعنی آبچکتء ارسال شده رو برمی‌گردونه و کپی ثابتی ایجاد نمی‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     const obj = {
       prop: 100
     };

     Object.freeze(obj);
     obj.prop = 200; // Throws an error in strict mode

     console.log(obj.prop); //100
     ```

     </span>

     **نکته:** یه تایپ ارور بهمون می‌ده که ارگومان داده شده `object` نیست

     **[فهرست](#فهرست)**

179. ### هدف از متد freeze چیه؟

     1. برای فریز کردن آبجکت‌ها و آرایه‌ها 
     2. برای `imutable` کردن آبجکت‌ها


     **[فهرست](#فهرست)**

180. ### چرا به متد freeze نیاز داریم؟

     در پارادایم شی گرا، یه `API` موجود حاوی عناصر خاصیه که قصد توسعه، اصلاح یا استفاده مجدد در خارج از زمینه فعلی خود رو ندارن. از این رو، این کلمه کلیدیه `final` که در زبان‌های مختلف استفاده می‌شه.

     **[فهرست](#فهرست)**

181. ### چطوری می‌تونیم زبان ترجیحی یه مرورگر رو تشخیص بدیم؟

     ما می‌تونیم از آبجکت `navigator` گه بر روری مرورگر وجود داره این کارو انجام بدیم

     <span dir="ltr" align="left">

     ```javascript
     var language = navigator.languages && navigator.languages[0] || // Chrome / Firefox
                    navigator.language ||   // All browsers
                    navigator.userLanguage; // IE <= 10

     console.log(language);
     ```

     </span>

     **[فهرست](#فهرست)**

182. ### چطوری می‌تونیم حرف اول همه کلمات یه رشته رو به حرف بزرگ تبدیل کنیم؟

     این کار باعث می‌شه که حرف اول یه رشته به صورت بزرگ(زبان انگلیسی) نشون داده بشه که ما می‌تونیم با تابع زیر این کارو انجام بدیم

     <span dir="ltr" align="left">

     ```javascript
         function toTitleCase(str) {
             return str.replace(
                 /\w\S*/g,
                 function(txt) {
                     return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                 }
             );
         }
         toTitleCase("good morning john"); // Good Morning John
     ```

     </span>

     **[فهرست](#فهرست)**

183. ### چطوری می‌شه تشخیص داد که جاواسکریپت یه صفحه وب غیرفعال شده؟

     برای تشخیص غیرفعال بودن یا نبودن جاواسکریپت می‌تونین از تگ `<noscript>` استفاده کنین. بلوک کد داخل `<noscript>` زمانی اجرا می‌شه که جاواسکریپت غیرفعال است، و معمولاً برای نمایش محتوای جایگزین زمانی که صفحه در جاواسکریپت تولید می‌شه، استفاده می‌شه.

     <span dir="ltr" align="left">

     ```html
     <script type="javascript">
         // JS related code goes here
     </script>
     <noscript>
         <a href="next_page.html?noJS=true">JavaScript is disabled in the page. Please click Next Page</a>
     </noscript>
     ```

     </span>

     **[فهرست](#فهرست)**

184. ### عملگرهای پشتیبانی شده توسط جاواسکریپت کدوما هستن؟

     یه عملگر قادر به دستکاری (محاسبات ریاضی و منطقی) مقدار یا عملوند معینه. اپراتورهای مختلفی توسط جاواسکریپت پشتیبانی میشن این اپراتور‌ها هستن
     1. **عملگر‌های حسابی:** شامل + (اضافه),– (منها), * (ضرب), / (تقسیم), % (درصد), + + (اضافه کردن)  و – – (کم کردن)
     2. **عملگر‌های مقایسه ای:** شامل = =(برابر),!= (غیر برابر), ===(برابر و تایپ برابر), > (بزرگتر),> = (بزرگتر مساوی),< (کوچکتر),<= (کوچکتر مساوی)
     3. **عملگر‌های منطقی:** شامل &&("و"منطقی),||("یا"منظقی),!( منطقی"نه")
     4. **عملگر‌های تعیین مقدار:** شامل = (اپراتور تعیین مقدار), += (اضافه کردن و تعیین مقدار), – = (منها کردن و تعیین مقدار), *= (ضرب و تعیین مقدار), /= (تقسیم و تعیین مقدار), %= (باقی مانده و تعیین مقدار)
     5. **اپراتور سه تایی:**  شامل اپراتور‌های شرطی سه تایی
     6. **اپراتور تایپ:** از اون برای پیدا کردن تایپ متغیر‌ها استفاده می‌شه به صورت `typeof variable`

     **[فهرست](#فهرست)**

185. ### پارامتر rest چیکار می‌کنه؟

     پارامتر `Rest` یه روش بهبود یافته برای مدیریت پارامترهای تابع هستش که به ما امکان میده تعداد نامحدودی از آرگومان‌ها رو به عنوان یه آرایه نمایش بدیم

     <span dir="ltr" align="left">

     ```javascript
     function f(a, b, ...theArgs) {
       // ...
     }
     ```

     </span>

     برای مثال، بیاین یه مثال مجموع برای محاسبه تعداد پویا پارامترها در نظر بگیریم،

     <span dir="ltr" align="left">

     ```javascript
     function total(…args){
          let sum = 0;
          for(let i of args){
               sum+=i;
          }
          return sum;
     }
     console.log(fun(1,2)); //3
     console.log(fun(1,2,3)); //6
     console.log(fun(1,2,3,4)); //13
     console.log(fun(1,2,3,4,5)); //15
     ```

     </span>

     **نکته:** Rest parameter is added in ES2015 or ES6

     **[فهرست](#فهرست)**

186. ### اگه پارامتر rest رو به عنوان آخرین پارامتر استفاده نکنیم چی می‌شه؟

     پارامتر ‍‍`Rest` باید آخرین آرگومان باشه، چون وظیفه اش جمع آوری تمام آرگومان‌های باقی مونده تو یه آرایه اس. برای مثال، اگه تابعیو مثل زیر تعریف کنیم معنی نداره و یه خطا ایجاد می کنه.

     <span dir="ltr" align="left">

     ```javascript
     function someFunc(a,…b,c){
          //You code goes here
          return;
     }
     ```

     </span>

     **[فهرست](#فهرست)**

187. ### عملگرهای منطقی باینری توی جاواسکریپت کدوما هستن؟

     1. به صورت بیتی AND ( & )
     2. به صورت بیتی OR ( | )
     3. به صورت بیتی XOR ( ^ )
     4. به صورت بیتی NOT ( ~ )
     5. تغییر مکان به چپ ( << )
     6. علامت در حال انتشار به سمت راست ( >> )
     7. صفر پر کردن Shift راست ( >>> )

     **[فهرست](#فهرست)**

188. ### عملگر spread چیکار می‌کنه؟

     عملگر Spread به تکرارپذیرها (آرایه‌ها / اشیاء / رشته‌ها) اجازه میده تا به آرگومان‌ها / عناصر منفرد گسترش پیدا کنن. برای مشاهده این رفتار مثالی بزنیم،

     <span dir="ltr" align="left">

     ```javascript
     function calculateSum(x, y, z) {
       return x + y + z;
     }

     const numbers = [1, 2, 3];

     console.log(calculateSum(...numbers)); // 6
     ```

     </span>

     **[فهرست](#فهرست)**

189. ### چطوری تشخیص میدی که یه آبجکت freeze شده یا نه؟

     متد Object.isFrozen برای تعیین اینکه آیا یه آبجکت منجمد هس یا نه استفاده می‌شه. اگه همه شرایط زیر درست باشه، یه آبجکت منجمد می‌شه.
     1. اگه قابل توسعه نباشه.
     2. اگه تمام خصوصیاتش غیر قابل تنظیم باشن.
     3. اگه تمام خصوصیات داده اون غیر قابل نوشتن باشه.

     <span dir="ltr" align="left">

     ```javascript
     const object = {
        property: 'Welcome JS world'
     };
     Object.freeze(object);
     console.log(Object.isFrozen(object));
     ```

     </span>

     **[فهرست](#فهرست)**

190. ### چطوری بررسی کنیم که دو تا مقدار(شامل آبجکت) با هم برابرن یا نه؟

     متد Object.is تعیین می‌کنه که آیا دو مقدار یه مقدار هستن یا نه. برای مثال، استفاده با انواع مختلف مقادیر،

     <span dir="ltr" align="left">

     ```javascript
     Object.is('hello', 'hello');     // true
     Object.is(window, window);   // true
     Object.is([], []) // false
     ```

     </span>

     اگه یکی از موارد زیر برقرار باشه، دو مقدار یکسان هستن:
     1. هردو undefined
     2. هردو null
     3. هردو true یا هر دو false
     4. هر دو رشته با طول یکسان با کاراکترهای مشابه به ترتیب یکسان
     5. هر دو یه آبجکت (یعنی هر دو شی رفرنس یکسان دارن)
     6. هر دو عدد و
     هر دو +0
     هر دو -0
     هر دو NaN
     هر دو غیر صفر و هر دو NaN نیستن و هر دو دارای یه مقدار هستن.

     **[فهرست](#فهرست)**

191. ### هدف از متد is روی object چیه؟

     1. برای مقایسه دو رشته استفاده می‌شه.
     2. برای مقایسه دو عدد استفاده می‌شه.
     3. برای مقایسه قطبیت دو عدد استفاده می‌شه.
     4. برای مقایسه دو آبچکت استفاده می‌شه.

     **[فهرست](#فهرست)**

192. ### چطوری propertyهای یه object رو به یه object دیگه کپی می‌کنی؟

     می‌تونین از متد Object.assign استفاده کنین که برای کپی کردن مقادیر و ویژگی‌ها از یه یا چند آبچکت منبع به یه آبچکت هدف استفاده می‌شه. آبچکت مورد نظر رو که دارای خواص و مقادیر کپی شده از آبچکت مورد نظر است، برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     Object.assign(target, ...sources)
     ```

     </span>

     بیاین با یه منبع و یه شی هدف مثال بزنیم،

     <span dir="ltr" align="left">

     ```javascript
     const target = { a: 1, b: 2 };
     const source = { b: 3, c: 4 };

     const returnedTarget = Object.assign(target, source);

     console.log(target); // { a: 1, b: 3, c: 4 }

     console.log(returnedTarget); // { a: 1, b: 3, c: 4 }
     ```

     </span>

     همونطور که در کد بالا مشاهده شد، یه ویژگی مشترک (`b`) از منبع به مقصد وجود داره، بنابراین مقداش بازنویسی شده.

     **[فهرست](#فهرست)**

193. ### کاربردهای ممتد assign چیه؟

     1. برای شبیه سازی یه شی استفاده می‌شه.
     2. برای ادغام اشیاء با ویژگی‌های یکسان استفاده می‌شه.

     **[فهرست](#فهرست)**

194. ### آبجکت proxy چیه؟

     آبجکت Proxy برای تعریف رفتار سفارشی برای عملیات‌های اساسی مثل جستجوی ویژگی، تخصیص، شمارش، فراخوانی تابع و غیره استفاده می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     var p = new Proxy(target, handler);
     ```

     </span>

     بیاین مثالی از شیء پروکسی بزنیم،

     <span dir="ltr" align="left">

     ```javascript
     var handler = {
         get: function(obj, prop) {
             return prop in obj ?
                 obj[prop] :
                 100;
         }
     };

     var p = new Proxy({}, handler);
     p.a = 10;
     p.b = null;

     console.log(p.a, p.b); // 10, null
     console.log('c' in p, p.c); // false, 100
     ```

     </span>

     در کد بالا، از کنترل‌کننده «get» استفاده می‌کنه که رفتار پراکسی رو موقع انجام عملیات روی اون تعریف می‌کنه.

     **[فهرست](#فهرست)**

195. ### هدف از متد seal چیه؟

     روش **Object.seal** برای مهر و موم کردن یه آبجکت با جلوگیری از اضافه شدن ویژگی‌های جدید بهش و علامت گذاری تمام ویژگی‌های موجود به عنوان غیر قابل تنظیم، استفاده می‌شه. اما مقادیر پراپرتی‌های فعلی تا زمانی که قابل نوشتن باشن , قابل تغییر هستن. بیاین مثال زیرو برای درک بیشتر در مورد روش seal ببینیم

     <span dir="ltr" align="left">

     ```javascript
      const object = {
         property: 'Welcome JS world'
      };
      Object.seal(object);
      object.property = 'Welcome to object world';
      console.log(Object.isSealed(object)); // true
      delete object.property; // You cannot delete when sealed
      console.log(object.property); //Welcome to object world
     ```

     </span>

     **[فهرست](#فهرست)**

196. ### کاربردهای متد seal چیه؟

     1. برای آب بندی آبجکت‌ها و آرایه‌ها استفاده می‌شه.
     2. برای غیرقابل تغییر کردن یه آبجکت استفاده می‌شه.

     **[فهرست](#فهرست)**

197. ### تفاوت‌های بین متدهای freeze و seal چیا هست؟

     اگه یه آبجکت با استفاده از متد Object.freeze منجمد شه، ویژگی‌هاش تغییرناپذیر می‌شن و هیچ تغییری در اونا نمیتونیم ایجاد کنیم در حالی که اگه یه آبجکت با استفاده از متد Object.seal مهر و موم شده باشه، می‌توان تغییرات رو در ویژگی‌های موجود ایجاد کرد. از آبجکت

     **[فهرست](#فهرست)**

198. ### چطوری تشخیص میدی که یه آبجکت seal شده یا نه؟

     متد Object.isSealed برای تعیین مهر و موم بودن یا نبودن یه آبجکت استفاده می‌شه. اگه همه شرایط زیر درست باشه یه شی مهر و موم می‌شه
     1. اگه قابل توسعه نباشه.
     2. اگه تمام خصوصیات اون غیر قابل تنظیم باشن.
     3. اگه قابل جابجایی نباشه (اما لزوماً غیرقابل نوشتن نیست).
     بیاین اونو در عمل ببینیم

     <span dir="ltr" align="left">

     ```javascript
     const object = {
     property: 'Hello, Good morning'
     };

     Object.seal(object); // Using seal() method to seal the object

     console.log(Object.isSealed(object));      // checking whether the object is sealed or not
     ```

     </span>

     **[فهرست](#فهرست)**

199. ### چطوری کلید و مقدارهای enumerable رو به دست میاری؟

     متد Object.entries برای برگردوندن آرایه‌ای از جفت‌های [key, value] دارای کلید رشته‌ای شمارش‌پذیر یه شی معین، به همان ترتیبی که توسط یه حلقه for...in ارائه می‌شود، استفاده می‌شود. بیاین عملکرد متد object.entries را تو یه مثال ببینیم،
     

     متد Object.entries برای برگردوندن آرایه‌ای از جفت‌های [key, value] دارای کلید رشته‌ای شمارش‌پذیر یه شی معین، به همون ترتیبی که توسط یه حلقه for...in ارائه می‌شه، استفاده می‌شه. بیاین عملکرد متد object.entries رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     const object = {
          a: 'Good morning',
          b: 100
     };

     for (let [key, value] of Object.entries(object)) {
          console.log(`${key}: ${value}`);      
          // a: 'Good morning'
          // b: 100
     }
     ```

     </span>

     **نکته:** سفارش به عنوان شی تعریف شده تضمین نمی‌شه.


200. ### تفاوت‌های بین متدهای Object.values و Object.entries چیا هست؟

     رفتار متد Object.values مشابه روش Object.entries هست اما به جای جفت [key,value] آرایه ای از مقادیر را برمی گرداند.

     <span dir="ltr" align="left">

     ```javascript
     const object = {
          a: 'Good morning',
          b: 100
     };

     for (let value of Object.values(object)) {
          console.log(`${value}`); // 'Good morning' 100
     }
     ```

     </span>

     **[فهرست](#فهرست)**


201. ### چطوری لیست کلیدهای یه object رو بدست میاری؟

     می‌تونین از متد Object.keys استفاده کنین که برای برگردوندن آرایه‌ای از اسم ویژگی‌های یه شی معین استفاده می‌شه، به همون ترتیبی که با یه حلقه معمولی دریافت می‌کنیم. برای مثال:

     <span dir="ltr" align="left">

     ```javascript
     const user = {
       name: 'John',
       gender: 'male',
       age: 40
     };

     console.log(Object.keys(user)); //['name', 'gender', 'age']
     ```

     </span>

     **[فهرست](#فهرست)**

202. ### چطوری یه object با prototype درست می‌کنی؟

     متد Object.create  برای ایجاد یه object جدید با object نمونه اولیه و ویژگی‌های مشخص شده استفاده می‌شه. برای مثال، از یه object موجود به عنوان نمونه اولیه object جدید ایجاد شده استفاده می‌کنه. یه object جدید رو با object نمونه اولیه و ویژگی‌های مشخص شده برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
      const user = {
        name: 'John',
        printInfo: function () {
          console.log(`My name is ${this.name}.`);
        }
      };

      const admin = Object.create(user);

      admin.name = "Nick"; // Remember that "name" is a property set on "admin" but not on "user" object

      admin.printInfo(); // My name is Nick
     ```

     </span>

     **[فهرست](#فهرست)**

203. ### WeakSet چیه؟

     WeakSet برای ذخیره مجموعه ای از اشیاء ضعیف (مرجع ضعیف) استفاده می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     new WeakSet([iterable]);
     ```

     </span>

     بیاین مثال زیرو برای توضیح رفتارش ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     var ws = new WeakSet();
     var user = {};
     ws.add(user);
     ws.has(user);    // true
     ws.delete(user); // removes user from the set
     ws.has(user);    // false, user has been removed
     ```

     </span>

     **[فهرست](#فهرست)**

204. ### تفاوت‌های بین WeakSet و Set کدوما هستن؟

     تفاوت اصلی اینه که ارجاع به اشیاء تو Set قویه در حالی که ارجاع به اشیا تو WeakSet ضعیفه. برای مثال، یه شی تو WeakSet  میتونه زباله جمع آوری شه اگه مرجع دیگری به اون وجود نداشته باشه.
     تفاوت‌های دیگر عبارتند از
     1. مجموعه‌ها میتونن هر مقداری رو ذخیره کنن در حالی که WeakSets میتونه تنها مجموعه ای از اشیاء رو ذخیره کنه
     2. WeakSet برخلاف Set دارای ویژگی اندازه نیست
     3. WeakSet متدهایی مانند پاک کردن، کلیدها، مقادیر، ورودی‌ها، forEach رو نداره.
     4. WeakSet قابل تکرار نیست.

     **[فهرست](#فهرست)**

205. ### لیست متدهایی که رو WeakSet قابل استفاده هستن رو می‌تونی بگی؟

     در زیر لیستی از روش‌های موجود در WeakSet آمده است،
     1. add(value): یه شی جدید با مقدار داده شده به مجموعه ضعیف اضافه می‌شه
     2. delete(value): مقدار رو از مجموعه WeakSet حذف می‌کنه.
     3. has(value): اگه مقدار در مجموعه WeakSet وجود داشته باشه true رو برمی‌گردونه در غیر این صورت false رو برمی گردونه.
     4. length: طول ضعیف SetObject رو برمی‌گردونه
     بیاین عملکرد تمام روش‌های بالا رو توی یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     var weakSetObject = new WeakSet();
     var firstObject = {};
     var secondObject = {};
     // add(value)
     weakSetObject.add(firstObject);
     weakSetObject.add(secondObject);
     console.log(weakSetObject.has(firstObject)); //true
     console.log(weakSetObject.length()); //2
     weakSetObject.delete(secondObject);
     ```

     </span>

     **[فهرست](#فهرست)**

206. ### WeakMap چیه؟

     آبجکت WeakMap مجموعه ای از جفت‌های کلید/مقداره که تو اون کلیدها به صورت ضعیف ارجاع داده شدن. در این حالت، کلیدها باید اشیا باشن و مقادیر میتونن مقادیر دلخواه باشن.برای مثال:

     <span dir="ltr" align="left">

     ```javascript
     new WeakMap([iterable])
     ```

     </span>

     بیاین مثال زیرو برای توضیح رفتار اون ببینیم،

     <span dir="ltr" align="left">

     ```javascript
      var ws = new WeakMap();
      var user = {};
      ws.set(user);
      ws.has(user);    // true
      ws.delete(user); // removes user from the map
      ws.has(user);    // false, user has been removed
     ```

     </span>

     **[فهرست](#فهرست)**

207. ### تفاوت‌های بین WeakMap و Map کدوما هستن؟

     تفاوت اصلی اینه که ارجاعات به آبجکت‌ها کلیدی در نقشه قوی هستن در حالی که ارجاعات به اشیاء کلیدی در WeakMap ضعیف هستن. برای مثال، یه شی کلیدی در WeakMap در صورتی که هیچ مرجع دیگری بهش وجود نداشته باشه، میتونه زباله جمع آوری شه.
     تفاوت‌های دیگر عبارتند از
     1. Map‌ها میتونن هر نوع کلیدی رو ذخیره کنن، در حالی که WeakMaps فقط میتونه مجموعه ای از اشیاء کلیدی رو ذخیره کنه
     2. WeakMap برخلاف Map دارای ویژگی اندازه نیست
     3. WeakMap متدهایی مانند پاک کردن، کلیدها، مقادیر، ورودی‌ها، forEach رو نداره.
     4. WeakMap قابل تکرار نیست.

     **[فهرست](#فهرست)**

208. ### لیست متدهایی که رو WeakMap قابل استفاده هستن رو می‌تونی بگی؟

     1. set(key, value): مقدار کلید رو در شی WeakMap تنظیم می‌کنه. شی WeakMap رو برمی‌گردونه.
     2. delete(key): هر مقدار مربوط به کلید رو حذف می‌کنه.
     3. has(key): یه Boolean رو برمی‌گردونه که نشون میده آیا مقداری به کلید در شی WeakMap مرتبط شده اس یا نه.
     4. get(key): مقدار مربوط به کلید رو برمی‌گردونه، یا اگه کلیدی وجود نداشته باشه، تعریف نشده.
     بیاین عملکرد تمام روش‌های بالا رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     var weakMapObject = new WeakMap();
     var firstObject = {};
     var secondObject = {};
     // set(key, value)
     weakMapObject.set(firstObject, 'John');
     weakMapObject.set(secondObject, 100);
     console.log(weakMapObject.has(firstObject)); //true
     console.log(weakMapObject.get(firstObject)); // John
     weakMapObject.delete(secondObject);
     ```

     </span>

     **[فهرست](#فهرست)**

209. ### هدف از متد uneval چیه؟

     uneval یه تابع داخلی‌ـه که برای ایجاد نمایش رشته‌ای از کد منبع یه شی استفاده می‌شه. این یه تابع سطح بالاس و با هیچ آبجکت‌ای مرتبط نیست. بیاین مثال زیر رو درموردش ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     var a = 1;
     uneval(a); // returns a String containing 1
     uneval(function user() {}); // returns "(function user(){})"
     ```

     </span>

     **[فهرست](#فهرست)**

210. ### چطوری یه URL رو encode می‌کنی؟

     تابع `encodeURI` برای رمزگذاری URI کامل استفاده می‌شه که دارای کاراکترهای خاص به جز (, / ? : @ & = + $ #) هست.

     <span dir="ltr" align="left">

     ```javascript
     var uri = 'https://mozilla.org/?x=шеллы';
     var encoded = encodeURI(uri);
     console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
     ```

     </span>

     **[فهرست](#فهرست)**

211. ### چطوری یه URL رو decode می‌کنی؟

     تابع `decodeURI` برای رمزگشایی یه شناسه منبع یکنواخت (URI) که قبلا توسط encodeURI ایجاد شده اس استفاده می‌شه.

     <span dir="ltr" align="left">

     ```javascript
      var uri = 'https://mozilla.org/?x=шеллы';
      var encoded = encodeURI(uri);
      console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
     try {
       console.log(decodeURI(encoded)); // "https://mozilla.org/?x=шеллы"
     } catch(e) { // catches a malformed URI
       console.error(e);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

212. ### چطوری محتوای یه صفحه رو پرینت می‌گیری؟

     شی window یه متد print ارائه می‌کنه که برای چاپ محتویات پنجره فعلی استفاده می‌شه. یه کادر محاوره ای چاپ رو باز می‌کنه که به شما امکان میده بین گزینه‌های مختلف چاپ انتخاب کنین. بیاین استفاده از روش چاپ رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```html
     <input type="button" value="Print" onclick="window.print()" />
     ```

     </span>

     **نکته:** در اکثر مرورگرها، زمانی که کادر گفتگوی چاپ باز است، مسدود می‌شه.

     **[فهرست](#فهرست)**

213. ### تفاوت‌های بین uneval و eval چیا هستن؟

     تابع 'uneval' منبع یه شی معین رو برمی‌گردونه. در حالی که تابع "eval" با ارزیابی اون کد منبع تو یه ناحیه حافظه متفاوت، برعکس عمل می‌کنه. بیاین مثالی رو برای روشن شدن تفاوت ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     var msg = uneval(function greeting() { return 'Hello, Good morning'; });
     var greeting = eval(msg);
     greeting(); // returns "Hello, Good morning"
     ```

     </span>

     **[فهرست](#فهرست)**

214. ### تابع anonymous چیه؟

     تابع ناشناس یه تابع بدون نام است! توابع ناشناس معمولاً به یه نام متغیر اختصاص داده می شن یا به عنوان یه تابع فراخوانی استفاده میشن بریم یه مثال در موردش ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     function (optionalParameters) {
       //do something
     }

     const myFunction = function(){ //Anonymous function assigned to a variable
       //do something
     };

     [1, 2, 3].map(function(element){ //Anonymous function used as a callback function
       //do something
     });
     ```

     </span>

     بیاین تابع ناشناس بالا رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     var x = function (a, b) {return a * b};
     var z = x(5, 10);
     console.log(z); // 50
     ```

     </span>

     **[فهرست](#فهرست)**

215. ### تفاوت تقدم بین متغیرهای local و global چطوریه؟

     یه متغیر محلی بر یه متغیر سراسری با همین نام ارجحیت داره. بیاین این رفتار رو تو یه مثال ببینیم.

     <span dir="ltr" align="left">

     ```javascript
     var msg = "Good morning";
     function greeting() {
        msg = "Good Evening";
        console.log(msg);
     }
     greeting();
     ```

     </span>

     **[فهرست](#فهرست)**

216. ### accessorهای جاواسکریپت چیکار می‌کنن؟

     ECMAScript 5 دسترسی‌های شی جاواسکریپت یا ویژگی‌های محاسبه‌شده رو از طریق گیرنده‌ها و تنظیم‌کندنه‌ها معرفی کرد. Getters از کلمه کلیدی "get" استفاده می‌کنه در حالی که Setters از کلمه کلیدی "set" استفاده می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     var user = {
       firstName: "John",
       lastName : "Abraham",
       language : "en",
       get lang() {
         return this.language;
       }
       set lang(lang) {
       this.language = lang;
       }
     };
     console.log(user.lang); // getter access lang as en
     user.lang = 'fr';
     console.log(user.lang); // setter used to set lang as fr
     ```

     </span>

     **[فهرست](#فهرست)**

217. ### چطوری روی constructor یه Object یه مقدار تعریف می‌کنی؟

     متد استاتیک Object.defineProperty برای تعریف یه ویژگی جدید به طور مستقیم بر روی یه آبجکت یا تغییر ویژگی موجود روی یه آبجکت استفاده می‌شه و آبجکت رو برمی‌گردونه. بیاین مثالی رو ببینیم تا بدونیم چجوری ویژگی رو تعریف کنیم،

     <span dir="ltr" align="left">

     ```javascript
     const newObject = {};

     Object.defineProperty(newObject, 'newProperty', {
       value: 100,
       writable: false
     });

     console.log(newObject.newProperty); // 100

     newObject.newProperty = 200; // It throws an error in strict mode due to writable setting

     ```

     </span>

     **[فهرست](#فهرست)**

218. ### تفاوت‌های بین get و defineProperty چیا هست؟

     هر دو نتایج مشابهی دارن مگه اینکه از کلاس‌ها استفاده کنین. اگه از «get» استفاده می‌کنین ویژگی روی نمونه اولیه شی تعریف می‌شه، در حالی که با استفاده از «Object.defineProperty»، ویژگی روی نمونه‌ای که بهش اعمال می‌شه، تعریف می‌شه.

     **[فهرست](#فهرست)**

219. ### مزایای استفاده از Getter و Setter چیه؟

     1. اونا نحو ساده تری ارائه می دهند
     2. اونا برای تعریف ویژگی‌های محاسبه شده یا دسترسی‌ها در JS استفاده میشن
     3. برای ارائه رابطه هم ارزی بین خواص و روش‌ها مفید است
     4. اونا میتونن کیفیت داده‌های بهتری رو ارائه دهند
     5. برای انجام کارها در پشت صحنه با منطق محصور شده مفید است.

     **[فهرست](#فهرست)**

220. ### می‌تونیم getter و setter رو با استفاده از متد defineProperty تعریف کنیم؟

     بله، می‌تونین از روش Object.defineProperty» برای اضافه کردن Getters و Setter استفاده کنین. برای مثال،آبجکت شمارنده زیر از ویژگی‌های افزایش، کاهش، جمع و تفریق استفاده می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     var obj = {counter : 0};

     // Define getters
     Object.defineProperty(obj, "increment", {
       get : function () {this.counter++;}
     });
     Object.defineProperty(obj, "decrement", {
       get : function () {this.counter--;}
     });

     // Define setters
     Object.defineProperty(obj, "add", {
       set : function (value) {this.counter += value;}
     });
     Object.defineProperty(obj, "subtract", {
       set : function (value) {this.counter -= value;}
     });

     obj.add = 10;
     obj.subtract = 5;
     console.log(obj.increment); //6
     console.log(obj.decrement); //5
     ```

     </span>

     **[فهرست](#فهرست)**

221. ### هدف استفاده از switch-case چیه؟

     عبارت switch case در جاواسکریپت برای اهداف تصمیم گیری استفاده می‌شه. در چند مورد، استفاده از دستور switch case راحت‌تر از if-else است. بریم یه مثال در موردش ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     switch (expression)
     {
         case value1:
             statement1;
             break;
         case value2:
             statement2;
             break;
         .
         .
         case valueN:
             statementN;
             break;
         default:
             statementDefault;
     }
     ```

     </span>

     دستور شعبه چند طرفه بالا یه راه آسان برای ارسال اجرا به قسمت‌های مختلف کد بر اساس مقدار عبارت ارائه میده.

     **[فهرست](#فهرست)**

222. ### چه قواعدی برای استفاده از swtich-case باید رعایت بشه؟

     1. عبارت میتونه از نوع عددی یا رشته‌ای باشه.
     2. مقادیر تکراری برای عبارت مجاز نیستن.
     3. بیانیه پیش فرض اختیاری است. اگه عبارت ارسال شده به سوئیچ با هیچ مقدار case مطابقت نداشته باشه، دستور در حالت پیش فرض اجرا میشه.
     4. دستور break در داخل سوئیچ برای پایان دادن به دنباله دستور استفاده می‌شه.
     5. عبارت break اختیاری است. اما اگه حذف شه، اجرا در مورد بعدی ادامه پیدا می‌کنه

     **[فهرست](#فهرست)**

223. ### نوع داده‌های primitive کدوما هستن؟

     یه نوع داده اولیه، داده‌ایه که دارای یه مقدار اولیه اس (که هیچ ویژگی یا روشی نداره). 5 نوع نوع داده اولیه وجود داره.

     1. رشته‌ها
     2. اعداد
     3. boolean
     4. null
     5. undefined

     **[فهرست](#فهرست)**

224. ### روش‌های مختلف دسترسی به propertyهای object کدوما هستن؟

     1. **Dot notation:** از نقطه برای دسترسی به ویژگی‌ها استفاده می‌کنه

     <span dir="ltr" align="left">

     ```javascript
     objectName.property
     ```

     </span>

     1. **Square brackets notation:** از براکت‌های مربعی برای دسترسی به دیتا استفاده می‌کنه

     <span dir="ltr" align="left">

     ```javascript
     objectName["property"]
     ```

     </span>

     1. **Expression notation:** از عبارت در کروشه استفاده می‌کنه
     <span dir="ltr" align="left">

     ```javascript
     objectName[expression]
     ```

     </span>

     **[فهرست](#فهرست)**

225. ### قوانین پارامترهای توابع کدوما هستن؟

     1. تعاریف تابع انواع داده‌ها رو برای پارامترها مشخص نمی‌کنه.
     2. بررسی نوع آرگومان‌های ارسال شده رو انجام نبدین.
     3. تعداد آرگومان‌های دریافتی رو بررسی نکنین.
     یعنی تابع زیر از قوانین بالا پیروی می‌کنه،

     <span dir="ltr" align="left">

     ```javascript
     function functionName(parameter1, parameter2, parameter3) {
       console.log(parameter1); // 1
     }
     functionName(1);
     ```

     </span>

     **[فهرست](#فهرست)**

226. ### آبجکت error چیه؟

     یه error object یه آبجکت خطای داخلیه که موقع بروز خطا، اطلاعات خطا رو ارائه میده. این دو ویژگی داره: نام و پیام. برای مثال، تابع زیر جزئیات خطا رو ثبت می‌کنه،

     <span dir="ltr" align="left">

     ```javascript
     try {
          greeting("Welcome");
     }
     catch(err) {
          console.log(err.name + "<br>" + err.message);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

227. ### چه موقعی خطای syntax دریافت می‌کنیم؟

     اگه بخواهید کد رو با یه خطای نحوی ارزیابی کنین یه SyntaxError پرتاب می‌شه. برای مثال، نقل قول زیر برای پارامتر تابع یه خطای نحوی ایجاد می‌کنه
     <span dir="ltr" align="left">

     ```javascript
     try {
       eval("greeting('welcome)");   // Missing ' will produce an error
     }
     catch(err) {
       console.log(err.name);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

228. ### عنوان خطاهای مختلف که روی error-object برمیگردن کدوما هستن؟

     | نام خطا | توضیحات |
     |---- | --------- |
     | EvalError | خطایی در تابع eval رخ داده است
     | RangeError | خطایی با عدد "خارج از محدوده" | رخ داده است
     | خطای مرجع | خطا به دلیل ارجاع غیرقانونی|
     | SyntaxError | خطای ناشی از خطای نحو|
     | TypeError | خطای ناشی از خطای نوع |
     | خطای URIE | یه خطا به دلیل encodeURI |

     **[فهرست](#فهرست)**

229. ### عبارات مختلف که در هنگام مدیریت error استفاده میشن کدوما هستن؟

     1. **try:** این عبارت برای آزمایش یه بلوک کد برای خطاها استفاده می‌شه
     2. **catch:** این عبارت برای رسیدگی به خطا استفاده می‌شه
     3. **throw:**این عبارت برای ایجاد خطاهای سفارشی استفاده می‌شه.
     4. **finally:**این عبارت برای اجرای کد پس از تلاش و گرفتن بدون توجه به نتیجه استفاده می‌شه.

     **[فهرست](#فهرست)**

230. ### دو نوع مختلف حلفه‌ها در جاواسکریپت کدوما هستن؟

     1. **Entry Controlled loops:** در این نوع حلقه، شرایط تست قبل از ورود به بدنه حلقه آزمایش می‌شه. برای مثال For Loop و while Loop در این دسته قرار می‌گیرن.
     2. **Exit Controlled Loops:** در این نوع حلقه، شرایط تست در انتهای بدنه حلقه آزمایش یا ارزیابی می‌شه. یعنی بدنه حلقه حداقل یه بار بدون در نظر گرفتن شرایط تست true یا false اجرا می‌شه. برای مثال، حلقه do-while در این دسته قرار می‌گیره.

     **[فهرست](#فهرست)**

231. ### nodejs چیه؟

     Node.js یه پلتفرم سمت سروره که بر اساس زمان اجرا جاواسکریپت کروم برای ساخت آسان برنامه‌های شبکه سریع و مقیاس پذیر ساخته شده. این یه زمان اجرا I/O ناهمزمان مبتنی بر رویداد، غیر مسدود کننده اس که از موتور جاواسکریپت V8 گوگل و کتابخانه libuv استفاده می‌کنه.

     **[فهرست](#فهرست)**

232. ### آبجکت Intl چیه؟

     آبجکت Intl فضای نامی برای ECMAScript Internationalization API اس که مقایسه رشته‌های حساس زبان، قالب بندی اعداد و قالب بندی تاریخ و زمان رو ارائه میده. دسترسی به چندین سازنده و توابع حساس به زبان رو فراهم می‌کنه.

     **[فهرست](#فهرست)**

233. ### چطوری تاریخ و زمان رو بر اساس زبان جاری سیستم کاربر نمایش بدیم؟

     می‌تونین از شی «Intl.DateTimeFormat» استفاده کنین که سازنده آبجکت‌هاییه که قالب بندی تاریخ و زمان حساس به زبان رو فعال می‌کنه. بیاین این رفتار رو با یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     var date = new Date(Date.UTC(2019, 07, 07, 3, 0, 0));
     console.log(new Intl.DateTimeFormat('en-GB').format(date)); // 07/08/2019
     console.log(new Intl.DateTimeFormat('en-AU').format(date)); // 07/08/2019
     ```

     </span>

     **[فهرست](#فهرست)**

234. ### Iterator چیه؟

     Iterator آبجکت‌ای‌ـه که پس از خاتمه، یه توالی و یه مقدار بازگشتی رو تعریف می‌کنه. پروتکل Iterator رو با متد «next» پیاده‌سازی می‌کنه که یه شی رو با دو ویژگی برمی‌گردونه: «value» (مقدار بعدی در دنباله) و «done» (که اگه آخرین مقدار در دنباله مصرف شده باشه درسته. ).

     **[فهرست](#فهرست)**

235. ### حلفه‌های synchronous(همزمان) چطوری کار می‌کنن؟

     تکرار همزمان در ES6 معرفی شد و با مجموعه ای از اجزای زیر کار می‌کنه:

     **Iterable:** این یه آبجکت‌ای‌ـه که میتونه از طریق روشی که کلید اون Symbol.iterator هس تکرار شه.
     **Iterator:** این یه آبجکت‌ای‌ـه که با فراخوانی «[Symbol.iterator]» بر روی یه تکرار برگردانده می‌شه. این آبجکت تکرار شونده هر عنصر تکرار شده رو تو یه آبجکت پیچیده می‌کنه و اونو از طریق متد «next» یکی یکی برمی‌گردونه.
     **IteratorResult:** این یه آبجکت‌ای‌ـه که با متد «next» برگردانده می‌شه. آبجکت شامل دو ویژگی است. ویژگی "value" حاوی یه عنصر تکرار شده و ویژگی "done" تعیین می‌کنه که آیا عنصر آخرین عنصر هست یا نه.

     بیاین تکرار همزمان رو با آرایه ای مانند زیر نشون بدیم،

     <span dir="ltr" align="left">

     ```javascript
     const iterable = ['one', 'two', 'three'];
     const iterator = iterable[Symbol.iterator]();
     console.log(iterator.next());  // { value: 'one', done: false }
     console.log(iterator.next());  // { value: 'two', done: false }
     console.log(iterator.next());  // { value: 'three', done: false }
     console.log(iterator.next());  // { value: 'undefined, done: true }
     ```

     </span>

     **[فهرست](#فهرست)**

236. ### Event-loop چیه؟

     event loop یه صف از توابع callback موقعی که یه تابع async اجرا می‌شه، تابع callback در صف قرار می‌گیرد. موتور جاواسکریپت پردازش حلقه رویداد رو شروع نمی‌کنه تا زمانی که تابع async اجرای کد رو به پایان برساند.
     **نکته:** این به Node.js اجازه میده تا عملیات I/O غیر مسدود کننده رو انجام بده حتی اگه جاواسکریپت تک رشته‌ای باشه.

     **[فهرست](#فهرست)**

237. ### Call-stack چیه؟

     Call Stack یه ساختار داده برای مفسران جاواسکریپت‌ـه تا فراخوانی‌های تابع در برنامه رو پیگیری کنه. دو عمل عمده داره،
     1. هر زمان که یه تابع رو برای اجرای آن فراخوانی می‌کنین اونو به پشته هل می بدین.
     2. هر زمان که اجرا به پایان برسد، تابع از پشته خارج می‌شه.

     بیاین مثالی بزنیم و نمایش حالت در قالب نمودار است
     
     <span dir="ltr" align="left">

     ```javascript
     function hungry() {
        eatFruits();
     }
     function eatFruits() {
        return "I'm eating fruits";
     }

     // Invoke the `hungry` function
     hungry();
     ```

     </span>

     کد بالا تو یه پشته تماس به صورت زیر پردازش می‌شه.
     1. تابع 'hungry' رو به لیست پشته تماس اضافه کنین و کد رو اجرا کنین.
     2. تابع 'eatFruits' رو به لیست پشته تماس اضافه کنین و کد رو اجرا کنین.
     3.تابع 'eatFruits' رو از لیست پشته تماس ما حذف کنین.
     4.تابع 'eatFruits' رو از لیست پشته تماس ما حذف کنین.

     ![Screenshot](images/call-stack.png)

     **[فهرست](#فهرست)**

238. ### Event-queue چیه؟

     **[فهرست](#فهرست)**

239. ### Decorator چیه؟

     دکوراتور عبارتیه که یه تابع رو ارزیابی می‌کنه و هدف، نام و توصیف‌کننده تزئین رو به عنوان آرگومان می‌گیره. همچنین، به صورت اختیاری یه توصیفگر دکوراتور رو برای نصب بر روی آبچکت مورد نظر برمی‌گردونه. بیاین در زمان طراحی، دکوراتور ادمین رو برای کلاس کاربر تعریف کنیم،

     <span dir="ltr" align="left">

     ```javascript
     function admin(isAdmin) {
        return function(target) {
            target.isAdmin = isAdmin;
        }
     }

     @admin(true)
     class User() {
     }
     console.log(User.isAdmin); //true

      @admin(false)
      class User() {
      }
      console.log(User.isAdmin); //false
     ```

     </span>

     **[فهرست](#فهرست)**

240. ### مقادیر موجود روی آبجکت Intl کدوما هستن؟
     

     1. **Collator:** اینا آبجکت‌هایی هستن که مقایسه رشته‌های حساس به زبان رو امکان پذیر می‌کنن.
     2. **DateTimeFormat:** اینا آبجکت‌هایی هستن که قالب بندی تاریخ و زمان حساس به زبان رو فعال می‌کنن.
     3. **ListFormat:**اینا آبجکت‌هایی هستن که قالب بندی لیست حساس به زبان رو فعال می‌کنن.
     4. **NumberFormat:** آبجکت‌هایی که قالب بندی اعداد حساس به زبان رو فعال می‌کنن.
     5. **PluralRules:**آبجکت‌هایی که قالب بندی حساس به جمع و قوانین خاص زبان رو برای جمع فعال می‌کنن.
     6. **RelativeTimeFormat:** آبجکت‌هایی که قالب بندی زمان نسبی حساس به زبان رو فعال می‌کنن.

     **[فهرست](#فهرست)**

241. ### عملگر Unary چیه؟

     عملگر unary(+) برای تبدیل یه متغیر به عدد استفاده می‌شه. اگه متغیر قابل تبدیل نباشه، همچنان به عدد تبدیل می‌شه اما با مقدار NaN. بیاین این رفتار رو تو یه عمل ببینیم.

     <span dir="ltr" align="left">

     ```javascript
     var x = "100";
     var y = + x;
     console.log(typeof x, typeof y); // string, number

     var a = "Hello";
     var b = + a;
     console.log(typeof a, typeof b, b); // string, number, NaN
     ```

     </span>

     **[فهرست](#فهرست)**

242. ### چطوری المنت‌های موجود تو یه آرایه رو مرتب می‌کنی؟

     متد sort برای مرتب سازی عناصر یه آرایه در جای خود استفاده می‌شه و آرایه مرتب شده رو برمی‌گردونه. استفاده از مثال زیر خواهد بود،

     <span dir="ltr" align="left">

     ```javascript
     var months = ["Aug", "Sep", "Jan", "June"];
     months.sort();
     console.log(months); //  ["Aug", "Jan", "June", "Sep"]
     ```

     </span>

     **[فهرست](#فهرست)**

243. ### هدف از تابع مرتب‌سازی موقع استفاده از متد sort چیه؟

     از compareFunction برای تعریف ترتیب مرتب سازی استفاده می‌شه. اگه حذف شه، عناصر آرایه به رشته تبدیل می‌شن، سپس بر اساس مقدار نقطه کد یونیکد هر کاراکتر مرتب میشن بیاین مثالی بزنیم تا کاربرد compareFunction رو ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     let numbers = [1, 2, 5, 3, 4];
     numbers.sort((a, b) => b - a);
     console.log(numbers); // [5, 4, 3, 2, 1]
     ```

     </span>

     **[فهرست](#فهرست)**

244. ### چطوری آیتم‌های یه آرایه رو معکوس مرتب کنیم؟

     برای معکوس کردن عناصر یه آرایه می‌تونین از متد reverse استفاده کنین. این روش برای مرتب کردن یه آرایه به ترتیب نزولی مفید است. بیاین استفاده از متد reverse رو تو یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     let numbers = [1, 2, 5, 3, 4];
     numbers.sort((a, b) => b - a);
     numbers.reverse();
     console.log(numbers); // [1, 2, 3, 4 ,5]
     ```

     </span>

     **[فهرست](#فهرست)**

245. ### چطوری حداقل و حداکثر مقدار یه آرایه رو بدست بیاریم؟

     می‌تونین از روش‌های «Math.min» و «Math.max» روی متغیرهای آرایه برای یافتن حداقل و حداکثر عناصر تو یه آرایه استفاده کنین. بیاین دو تابع برای پیدا کردن مقدار min و max تو یه آرایه ایجاد کنیم.

     <span dir="ltr" align="left">

     ```javascript
     var marks = [50, 20, 70, 60, 45, 30];
     function findMin(arr) {
       return Math.min.apply(null, arr);
     }
     function findMax(arr) {
       return Math.max.apply(null, arr);
     }

     console.log(findMin(marks));
     console.log(findMax(marks));
     ```

     </span>

     **[فهرست](#فهرست)**

246. ### چطوری حداقل و حداکثر مقدار یه آرایه رو بدون استفاده از متدهای Math بدست بیاریم؟


     ما میتونیم توابعی بنویسیم که تو یه آرایه حلقه می زنن و هر مقدار را با کمترین یا بالاترین مقدار مقایسه می کنن تا مقادیر حداقل و حداکثر رو پیدا کنن. بریم یه مثال درموردش ببینیم.

     <span dir="ltr" align="left">

     ```javascript
      var marks = [50, 20, 70, 60, 45, 30];
      function findMin(arr) {
        var length = arr.length
        var min = Infinity;
        while (length--) {
          if (arr[length] < min) {
            min = arr[len];
          }
        }
        return min;
      }

      function findMax(arr) {
        var length = arr.length
        var max = -Infinity;
        while (len--) {
          if (arr[length] > max) {
            max = arr[length];
          }
        }
        return max;
      }

      console.log(findMin(marks));
      console.log(findMax(marks));
     ```

     </span>

     **[فهرست](#فهرست)**

247. ### عبارت خالی چیه و هدف از استفاده ازش چیه؟

      ویرگول (;) هس که نشون میده هیچ دستوری اجرا نخواهد شد، حتی اگه نحو جاواسکریپت به اون نیاز داشته باشه. از اونجایی که هیچ اقدامی با دستور خالی وجود نداره، ممکنه فکر کنین که استفاده از اون خیلی کمه اما دستور خالی گاهی اوقات موقعی مفیده که می‌خواین حلقه ای ایجاد کنین که بدنش خالیه. برای مثال، می‌تونین یه آرایه با مقادیر صفر رو مانند زیر مقدارههی اولیه کنین.


     <span dir="ltr" align="left">

     ```javascript
     // Initialize an array a
     for(int i=0; i < a.length; a[i++] = 0) ;
     ```

     </span>

     **[فهرست](#فهرست)**

248. ### چطوری metadata یه ماژول رو بدست میاری؟ meta data of a module

     میتونیم از آبجکت `import.meta‍` استفاده کنیم که یه ویژگی متاعه که متا داده‌های متنی خاص رو تو یه ماژول جاوا اسکریپت قرار می‌ده. این شامل اطلاعاتی در مورد ماژول فعلی، مانند URL ماژوله. در مرورگرها، ممکنه متا داده های متفاوتی نسبت به NodeJS دریافت کنیم.

     <span dir="ltr" align="left">

     ```html
     <script type="module" src="welcome-module.js"></script>
     console.log(import.meta); // { url: "file:///home/user/welcome-module.js" }
     ```

     </span>

     **[فهرست](#فهرست)**

249. ### عملگر comma چیه و چیکار می‌کنه؟

     عملگر کاما برای ارزیابی هر یه از عملوندهاش از چپ به راست استفاده می‌شه و مقدار آخرین عملوند رو برمی‌گردونه. این کاملاً با استفاده از کاما در آرایه‌ها، اشیاء و آرگومان‌ها و پارامترهای تابع متفاوته. بریم یه مثال در موردش ببینیم.

     <span dir="ltr" align="left">

     ```javascript
     var x = 1;
     x = (x++, x);

     console.log(x); // 2
     ```

     </span>

     **[فهرست](#فهرست)**

250. ### مزایای استفاده از عملگر comma چیه؟

     معمولاً برای گنجوندن چندین عبارت در مکانی که به یه عبارت واحد نیاز داره استفاده می‌شه. یکی از کاربردهای رایج این عملگر کاما، ارائه چندین پارامتر تو یه حلقه «for» است. برای مثال، حلقه for زیر از چند عبارت تو یه مکان واحد با استفاده از عملگر کاما استفاده می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     for (var a = 0, b =10; a <= 10; a++, b--)
     ```

     </span>

     همچنین می‌تونین از عملگر کاما تو یه عبارت بازگشتی استفاده کنین جایی که قبل از بازگشت پردازش می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     function myFunction() {
        var a = 1;
        return (a += 10, a); // 11
     }
     ```

     </span>

     **[فهرست](#فهرست)**

251. ### Typescript چیه؟

     TypeScript یه ابر مجموعه تایپ شده از جاواسکریپت‌ـه که توسط مایکروسافت ایجاد شده که انواع اختیاری، کلاس‌ها، async/wait و بسیاری ویژگی‌های دیگر رو اضافه می‌کنه و به جاواسکریپت ساده کامپایل می‌کنه. Angular به طور کامل در TypeScript ساخته شده و به عنوان زبان اصلی استفاده می‌شه. شما می‌تونین اونو به صورت گلوبال نصب کنین

     <span dir="ltr" align="left">

      ```bash
      npm install -g typescript
      ```

     </span>

     بیاین یه مثال ساده از استفاده از TypeScript رو ببینیم،

     <span dir="ltr" align="left">

      ```typescript
      function greeting(name: string): string {
         return "Hello, " + name;
      }

      let user = "Sudheer";

      console.log(greeting(user));
      ```

     </span>

     متد greeting فقط نوع رشته رو به عنوان آرگومان مجاز می‌کنه.

     **[فهرست](#فهرست)**

252. ### تفاوت‌های بین javascript و typescript کدوما هستن؟


     | ویژگی | تایپ | جاواسکریپت |
     |---- | --------- | ---- |
     | پارادایم زبان | زبان برنامه نویسی شی گرا | زبان اسکریپت |
     | پشتیبانی از تایپ | پشتیبانی از تایپ استاتیک | دارای تایپ پویا |
     | ماژول‌ها | پشتیبانی شده | پشتیبانی نمی‌شه |
     | رابط | دارای مفهوم رابط | از رابط‌ها پشتیبانی نمی‌کنه |
     | پارامترهای اختیاری | توابع از پارامترهای اختیاری پشتیبانی می‌کنن | عدم پشتیبانی از پارامترهای اختیاری برای توابع |

     **[فهرست](#فهرست)**

253. ### مزایای typescript نسبت به javascript چیاست؟

     
     1. TypeScript میتونه خطاهای زمان کامپایل رو فقط در زمان توسعه پیدا کنه و باعث می‌شه خطاهای زمان اجرا کمتر شه. در حالی که جاواسکریپت یه زبان تفسیر شده است.
     2. TypeScript به شدت تایپ می‌شه یا از تایپ استاتیک پشتیبانی می‌کنه که امکان بررسی صحت نوع رو در زمان کامپایل فراهم می‌کنه. این در جاواسکریپت در دسترس نیست.
     3. کامپایلر TypeScript برخلاف ویژگی‌های ES6 جاواسکریپت که ممکنه در بعضی از مرورگرها پشتیبانی نشه، میتونه فایل‌های .ts رو در ES3، ES4 و ES5 کامپایل کنه.

     **[فهرست](#فهرست)**

254. ### object-initializer چیه؟

     یه آبجکت اولیه عبارتیه که مقدار دهی اولیه یه آبجکت رو توصیف می‌کنه. نحو این عبارت به صورت فهرستی با کاما از صفر یا چند جفت نام ویژگی و مقادیر مرتبط یه آبجکت، محصور در پرانتزهای فرفری ({}) نشون داده می‌شه. این همچنین به عنوان نماد تحت اللفظی شناخته می‌شه. یکی از راه‌های ایجاد یه آبجکته.

     <span dir="ltr" align="left">

     ```javascript
     var initObject = {a: 'John', b: 50, c: {}};

     console.log(initObject.a); // John
     ```

     </span>

     **[فهرست](#فهرست)**

255. ### متد constructor چیه؟

     متد سازنده یه متد خاص برای ایجاد و مقدارههی اولیه یه آبجکت ایجاد شده تو یه کلاس است. اگه متد سازنده رو مشخص نکنین از سازنده پیش فرض استفاده می‌شه. بریم یه مثال در موردش ببینیم.
     

     <span dir="ltr" align="left">

     ```javascript
     class Employee {
       constructor() {
         this.name = "John";
       }
     }

     var employeeObject = new Employee();

     console.log(employeeObject.name); // John
     ```

     </span>

     **[فهرست](#فهرست)**

256. ### اگه متد constructor رو بیش از یه بار توی کلاس بنویسیم چی می‌شه؟

     "سازنده" تو یه کلاس یه متد خاصه و باید فقط یه بار تو یه کلاس تعریف شه. برای مثال، اگه یه متد سازنده رو بیش از یه بار تو یه کلاس بنویسین، یه خطای «SyntaxError» ایجاد می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
      class Employee {
        constructor() {
          this.name = "John";
        }
        constructor() {   //  Uncaught SyntaxError: A class may only have one constructor
          this.age = 30;
        }
      }

      var employeeObject = new Employee();

      console.log(employeeObject.name);
     ```

     </span>

     **[فهرست](#فهرست)**

257. ### چطوری متد constructor کلاس والد رو صدا بزنیم؟

     می‌تونین از کلمه کلیدی super برای فراخوانی سازنده کلاس والد استفاده کنین. به یاد داشته باشیم که «super» باید قبل از استفاده از مرجع «this» فراخوانی شه. در غیر این صورت باعث خطای مرجع می‌شه. بیاین از اون استفاده کنیم،

     <span dir="ltr" align="left">

     ```javascript
     class Square extends Rectangle {
       constructor(length) {
         super(length, length);
         this.name = 'Square';
       }

       get area() {
         return this.width * this.height;
       }

       set area(value) {
         this.area = value;
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

258. ### چطوری prototype یه object رو به دست میاری؟

     می‌تونین از روش Object.getPrototypeOf(obj) برای برگردوندن نمونه اولیه شی مشخص شده استفاده کنین. یعنی مقدار ویژگی «نمونه اولیه» داخلی. اگه هیچ ویژگی ارثی وجود نداشته باشه، مقدار "null" برگردانده می‌شه.
     <span dir="ltr" align="left">

     ```javascript
     const newPrototype = {};
     const newObject = Object.create(newPrototype);

     console.log(Object.getPrototypeOf(newObject) === newPrototype); // true
     ```

     </span>

     **[فهرست](#فهرست)**

259. ### اگه به متد getPrototype رشته پاس بدیم چی می‌شه؟

     در ES5، اگه پارامتر obj یه شی نباشه، یه استثنا TypeError ایجاد می‌کنه. در حالی که در ES2015، پارامتر به یه «شیء» اجباری می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     // ES5
     Object.getPrototypeOf('James'); // TypeError: "James" is not an object
     // ES2015
     Object.getPrototypeOf('James'); // String.prototype
     ```

     </span>

     **[فهرست](#فهرست)**

260. ### چطوری prototype یه object روی یه object دیگه ست کنیم؟

     می‌تونین از متد «Object.setPrototypeOf» استفاده کنین که نمونه اولیه (یعنی ویژگی داخلی «Prototype») یه شی مشخص شده رو روی یه شی دیگر یا تهی تنظیم می‌کنه. برای مثال، اگه می‌خواین نمونه اولیه یه جسم مربع رو روی شی مستطیلی تنظیم کنین به صورت زیر است:

     <span dir="ltr" align="left">

     ```javascript
     Object.setPrototypeOf(Square.prototype, Rectangle.prototype);
     Object.setPrototypeOf({}, null);
     ```

     </span>

     **[فهرست](#فهرست)**

261. ### چطوری بررسی می‌کنی که یه object قابل extend هست یا نه؟

     متد Object.isExtensible` برای تعیین اینکه یه شی قابل توسعه هس یا نه استفاده می‌شه. یعنی اینکه میتونه ویژگی‌های جدیدی به اون اضافه شه یا نه.

     <span dir="ltr" align="left">

     ```javascript
     const newObject = {};
     console.log(Object.isExtensible(newObject)); //true
     ```

     </span>

     **نکته:** به طور پیش فرض، تمام اشیاء قابل گسترش هستن. برای مثال، ویژگی‌های جدید رو می‌تونیم اضافه یا تغییر بدیم.

     **[فهرست](#فهرست)**

262. ### چطوری جلوی extend یه object رو بگیریم؟

     متد «Object.preventExtensions» برای جلوگیری از افزودن ویژگی‌های جدید به یه شی استفاده می‌شه. به عبارت دیگر، از پسوندهای بعدی به شی جلوگیری می‌کنه. بیاین استفاده از این ویژگی رو ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     const newObject = {};
     Object.preventExtensions(newObject); // NOT extendable

     try {
       Object.defineProperty(newObject, 'newProperty', { // Adding new property
         value: 100
       });
     } catch (e) {
       console.log(e); // TypeError: Cannot define property newProperty, object is not extensible
     }
     ```

     </span>

     **[فهرست](#فهرست)**

263. ### روش‌های مختلف برای تبدیل یه object به object غیرقابل extend چیه؟

     شما می‌تونین یه شی غیر قابل گسترش رو به 3 روش علامت گذاری کنین.
     1. Object.preventExtensions
     2. Object.seal
     3. Object.freeze

     <span dir="ltr" align="left">

     ```javascript
     var newObject = {};

     Object.preventExtensions(newObject); // Prevent objects are non-extensible
     Object.isExtensible(newObject); // false

     var sealedObject = Object.seal({}); // Sealed objects are non-extensible
     Object.isExtensible(sealedObject); // false

     var frozenObject = Object.freeze({}); // Frozen objects are non-extensible
     Object.isExtensible(frozenObject); // false
     ```

     </span>

     **[فهرست](#فهرست)**

264. ### چطوری propertyهای متعددی رو روی یه object تعریف می‌کنی؟

     متد «Object.defineProperties» برای تعریف یا اصلاح ویژگی‌های موجود مستقیماً روی یه شی و برگردوندن شی استفاده می‌شه. بیاین چندین ویژگی رو روی یه شی خالی تعریف کنیم،

     <span dir="ltr" align="left">

     ```javascript
     const newObject = {};

     Object.defineProperties(newObject, {
       newProperty1: {
         value: 'John',
         writable: true
       },
       newProperty2: {}
     });
     ```

     </span>

     **[فهرست](#فهرست)**

265. ### منظور از MEAN توی جاواسکریپت چیه؟ javascript

     پشته MEAN (MongoDB، Express، AngularJS و Node.js) محبوب‌ترین پشته فناوری نرم‌افزار جاواسکریپت منبع بازه که برای ساخت برنامه‌های وب پویا در دسترسه، جایی که می‌تونین نیمه‌های سمت سرور و سمت مشتری پروژه وب رو بنویسین. کاملا در جاواسکریپت

     **[فهرست](#فهرست)**

266. ### Obfuscation توی جاواسکریپت چیه و چیکار می‌کنه؟ javascript

     مبهم سازی عمل عمدی ایجاد کد جاواسکریپت مبهم (یعنی کد منبع یا ماشین) هس که درک اون برای انسان سخته. این چیزی شبیه به رمزگذاریه، اما یه ماشین میتونه کد رو درک کنه و اونو اجرا کنه.
     بیاین تابع زیر رو قبل از Obfuscation ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     function greeting() {
          console.log('Hello, welcome to JS world');
     }
     ```

     </span>

     و بعد از کد Obfuscation به صورت زیر ظاهر می‌شه
     <span dir="ltr" align="left">

     ```javascript
     eval(function(p,a,c,k,e,d){e=function(c){return c};if(!''.replace(/^/,String)){while(c--){d[c]=k[c]||c}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('2 1(){0.3(\'4, 7 6 5 8\')}',9,9,'console|greeting|function|log|Hello|JS|to|welcome|world'.split('|'),0,{}))
     ```

     </span>

     **[فهرست](#فهرست)**

267. ### چه نیازی به Obfuscate کردن داریم؟

     1. اندازه کد کمتر میشه. بنابراین انتقال داده بین سرور و مشتری سریع تر انجام میشه.
     2. این منطق کسب و کار رو از دنیای خارج پنهان می‌کنه و از کد در برابر دیگران محافظت می‌کنه
     3. مهندسی معکوس کردن کد رو سخت میکنه
     4. زمان دانلود کاهش پیدا می‌کنه

     **[فهرست](#فهرست)**

268. ### Minification چیه؟

     `Minification` حذف تمام کاراکترهای غیر ضروریه (فضاهای خالی حذف می‌شن) و متغیرها بدون تغییر در عملکر اون تغییر نام می دن همچنین نوعی مبهمه.

     **[فهرست](#فهرست)**

269. ### مزایای minification یا کم حجم‌سازی چیه؟

     به طور معمول توصیه می‌شه برای ترافیک سنگین و نیازهای فشرده منابع از Minification استفاده کنین. اندازه فایل رو با مزایای زیر کاهش میده
     1. زمان بارگذاری یه صفحه وب رو کاهش میده
     2. در مصرف پهنای باند صرفه جویی می‌کنه

     **[فهرست](#فهرست)**

270. ### تفاوت‌های بین Obfuscation و Encryption چیه؟

     | ویژگی | مبهم سازی | رمزگذاری |
     |---- | --------- | ----
      | تعریف | تغییر فرم هر داده به هر شکل دیگر | تغییر فرم اطلاعات به فرمت ناخوانا با استفاده از کلید |
      | کلیدی برای رمزگشایی | می‌شه اونو بدون هیچ کلید رمزگشایی کرد | لازمه |
      | فرمت داده‌های هدف | به فرم پیچیده تبدیل می‌شه | تبدیل به فرمت ناخوانا |

     **[فهرست](#فهرست)**

271. ### ابزارهای مختلف برای minification کدوما هستن؟

     1. کامپایلر بسته شدن گوگل
     2. UglifyJS2
     3. jsmin
     4. javascript-minifier.com/
     5. prettydiff.com

     **[فهرست](#فهرست)**

272. ### چطوری اعتبارسنجی فرم رو با javascript انجام میدی؟

     از جاواسکریپت می‌شه برای اعتبار سنجی فرم HTML استفاده کرد. برای مثال، اگه فیلد فرم خالی باشه، تابع باید اطلاع بده و false رو برگرداند تا از ارسال فرم جلوگیری شه.
      اجازه بدین ورود کاربر رو در فرم html انجام بدیم،

     <span dir="ltr" align="left">

     ```html
     <form name="myForm" onsubmit="return validateForm()" method="post">
          User name: <input type="text" name="uname">
          <input type="submit" value="Submit">
     </form>
     ```

     </span>

     و اعتبار سنجی ورود کاربر در زیر است،

     <span dir="ltr" align="left">

     ```javascript
     function validateForm() {
       var x = document.forms["myForm"]["uname"].value;
       if (x == "") {
         alert("The username shouldn't be empty");
         return false;
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

273. ### چطوری اعتبارسنجی فرم رو بدون javascript انجام میدی؟

     می‌تونین بدون استفاده از جاواسکریپت اعتبار سنجی فرم HTML رو به صورت خودکار انجام بدین. اعتبار سنجی با اعمال ویژگی «لازم» برای جلوگیری از ارسال فرم زمانی که ورودی خالیه فعال می‌شه.

     <span dir="ltr" align="left">

     ```html
     <form method="post">
       <input type="text" name="uname" required>
       <input type="submit" value="Submit">
     </form>
     ```

     </span>

     **نکته:** اعتبار سنجی فرم خودکار در اینترنت اکسپلورر 9 یا قبل از اون کار نمی‌کنه.

     **[فهرست](#فهرست)**

274. ### متدهای موجود روی DOM برای اعتبارسنجی کدوما هستن؟

     روش‌های DOM زیر برای اعتبارسنجی محدودیت در ورودی نامعتبر موجود است.
     1. checkValidity: اگه یه عنصر ورودی حاوی داده‌های معتبر باشه، مقدار true رو برمی‌گردونه.
     2. setCustomValidity: برای تنظیم خاصیت validationMessage یه عنصر ورودی استفاده می‌شه.
     بیاین یه فرم ورود کاربر با اعتبارسنجی DOM بگیریم

     <span dir="ltr" align="left">

     ```javascript
     function myFunction() {
       var userName = document.getElementById("uname");
       if (!userName.checkValidity()) {
         document.getElementById("message").innerHTML = userName.validationMessage;
       } else {
         document.getElementById("message").innerHTML = "Entered a valid username";
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

275. ### مقادیر موجود روی DOM برای اعتبارسنجی کدوما هستن؟

     در زیر لیستی از بعضی از ویژگی‌های DOM اعتبارسنجی محدودیت موجود است،

     1. validity: فهرستی از ویژگی‌های بولین مربوط به اعتبار یه عنصر ورودی رو ارائه میده.
     2. validationMessage: زمانی که اعتبار نادرست باشه، پیام رو نمایش میده.
     3. willValidate: این نشون میده که آیا یه عنصر ورودی اعتبار سنجی می‌شه یا نه.

     **[فهرست](#فهرست)**

276. ### مقادیر موجود روی input برای اعتبارسنجی کدوما هستن؟

     ویژگی اعتبار یه عنصر ورودی مجموعه ای از ویژگی‌های مربوط به اعتبار داده‌ها رو ارائه میده.

     1. customError: اگه یه پیام اعتبار سفارشی تنظیم شده باشه، true رو برمی‌گردونه.
     2. patternMismatch: اگه مقدار یه عنصر با ویژگی الگوی آن مطابقت نداشته باشه، مقدار true رو برمی‌گردونه.
     3. rangeOverflow: اگه مقدار یه عنصر از ویژگی max آن بیشتر باشه، مقدار true رو برمی‌گردونه.
     4. rangeUnderflow:اگه مقدار یه عنصر کمتر از ویژگی min باشه، مقدار true رو برمی‌گردونه.
     5. stepMismatch:اگه مقدار عنصر مطابق با ویژگی step نامعتبر باشه، مقدار true رو برمی‌گردونه.
     6. tooLong: اگه مقدار یه عنصر از ویژگی maxLength آن بیشتر شه، مقدار true رو برمی‌گردونه.
     7. typeMismatch: اگه مقدار یه عنصر بر اساس ویژگی نوع نامعتبر باشه، مقدار true رو برمی‌گردونه.
     8. valueMissing: اگه عنصری با ویژگی مورد نیاز ارزش نداشته باشه، مقدار true رو برمی‌گردونه.
     9. valid: اگه مقدار یه عنصر معتبر باشه، مقدار true رو برمی‌گردونه.

     **[فهرست](#فهرست)**

277. ### یه مثال از استفاده ویژگی rangeOverflow می‌تونی بزنی؟

     اگه مقدار یه عنصر از ویژگی max آن بیشتر باشه، ویژگی rangeOverflow مقدار true رو برمی‌گردونه. برای مثال، فرم ارسالی زیر اگه مقدار آن بیش از 100 باشه، خطا میده.

     <span dir="ltr" align="left">

     ```html
     <input id="age" type="number" max="100">
     <button onclick="myOverflowFunction()">OK</button>
     ```

     </span>

     <span dir="ltr" align="left">

     ```javascript
     function myOverflowFunction() {
       if (document.getElementById("age").validity.rangeOverflow) {
         alert("The mentioned age is not allowed");
       }
     }
     ```

     </span>

     **[فهرست](#فهرست)**

278. ### جاواسکریپت قابلیت استفاده از enum رو پیش‌فرض توی خودش داره؟

     نه، جاواسکریپت به صورت بومی از enum‌ها پشتیبانی نمی‌کنه. اما انواع مختلفی از راه‌حل‌ها برای شبیه‌سازی اونا وجود داره، اگرچه ممکنه معادل‌های دقیقی ارائه نکنن. برای مثال، می‌تونین از فریز یا مهر و موم روی شی استفاده کنین

     <span dir="ltr" align="left">

     ```javascript
     var DaysEnum = Object.freeze({"monday":1, "tuesday":2, "wednesday":3, ...})
     ```

     </span>

     **[فهرست](#فهرست)**

279. ### enum چیه؟

     enum نوعیه که متغیرها رو به یه مقدار از مجموعه ای از ثابت‌های از پیش تعریف شده محدود می‌کنه. جاواسکریپت هیچ enum نداره اما تایپ اسکریپت از enum داخلی پشتیبانی می‌کنه.
     <span dir="ltr" align="left">

     ```javascript
     enum Color {
      RED, GREEN, BLUE
     }
     ```

     </span>

     **[فهرست](#فهرست)**

280. ### چطوری همه propertyهای یه object رو به دست بیاریم؟

     می‌تونین از متد Object.getOwnPropertyNames» استفاده کنین که آرایه‌ای از تمام ویژگی‌هایی رو که مستقیماً تو یه شیء داده شده یافت می‌شه، برمی‌گردونه. بیاین استفاده از اونو تو یه مثال بیان کنیم،

     <span dir="ltr" align="left">

     ```javascript
     const newObject = {
       a: 1,
       b: 2,
       c: 3
     };

     console.log(Object.getOwnPropertyNames(newObject));  ["a", "b", "c"]
     ```

     </span>

     **[فهرست](#فهرست)**

281. ### چطوری get property descriptors of an object

     می‌تونین از متد Object.getOwnPropertyDescriptors» استفاده کنین که تمام توصیف‌گرهای ویژگی یه شی معین رو برمی‌گردونه. مثال استفاده از این روش در زیر آمده است

     <span dir="ltr" align="left">

     ```javascript
      const newObject = {
        a: 1,
        b: 2,
        c: 3
      };
     const descriptorsObject = Object.getOwnPropertyDescriptors(newObject);
     console.log(descriptorsObject.a.writable); //true
     console.log(descriptorsObject.a.configurable); //true
     console.log(descriptorsObject.a.enumerable); //true
     console.log(descriptorsObject.a.value); // 1
     ```

     </span>

     **[فهرست](#فهرست)**

282. ### گزینه‌هایی که موقع تعریف ویژگی object با descriptor داریم کدوما هستن؟

     1. value:ارزش مرتبط با ملک
     2. writable:تعیین می‌کنه که آیا مقدار مرتبط با ویژگی قابل تغییر هس یا نه
     3. configurable: اگه بتوان نوع توصیفگر این ویژگی رو تغییر داد و اگه ویژگی رو بتوان از شی مربوطه حذف کرد، مقدار true رو برمی‌گردونه.
     4. enumerable: تعیین می‌کنه که آیا ویژگی در موقع شمارش خصوصیات روی شی مربوطه ظاهر می‌شه یا نه.
     5. set: تابعی که به عنوان تنظیم کننده برای ویژگی عمل می‌کنه
     6. get: تابعی که به عنوان یه گیرنده برای ملک عمل می‌کنه

     **[فهرست](#فهرست)**

283. ### چطوری کلاس‌ها رو extend می‌کنی؟

     کلمه کلیدی "extends" در اعلان‌ها/عبارات کلاس برای ایجاد کلاسی که فرزند کلاس دیگه ایه استفاده می‌شه. می‌شه از اون برای زیر کلاس بندی کلاس‌های سفارشی و همچنین اشیاء داخلی استفاده کرد. بریم یه مثال در موردش ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     class ChildClass extends ParentClass { ... }
     ```

     </span>

     بیاین یه نمونه از زیر کلاس مربع از کلاس والد Polygon رو مثال بزنیم،

     <span dir="ltr" align="left">

     ```javascript
      class Square extends Rectangle {
        constructor(length) {
          super(length, length);
          this.name = 'Square';
        }

        get area() {
          return this.width * this.height;
        }

        set area(value) {
          this.area = value;
        }
      }
     ```

     </span>

     **[فهرست](#فهرست)**

284. ### چطوری آدرس صفحه رو بدون رفرش صفحه عوض کنیم؟

     ویژگی «window.location.url» برای تغییر url مفید خواهد بود اما صفحه رو دوباره بارگیری می‌کنه. HTML5 متدهای «history.pushState» و «history.replaceState» رو معرفی کرد که به شما اجازه میده به ترتیب ورودی‌های تاریخ رو اضافه و تغییر بدین. برای مثال، می‌تونین از pushState مانند زیر استفاده کنین.

     <span dir="ltr" align="left">

     ```javascript
     window.history.pushState('page2', 'Title', '/page2.html');
     ```

     </span>

     **[فهرست](#فهرست)**

285. ### چطوری بررسی می‌کنی که یه آرایه یه مقدار مشخص رو داره یا نه؟

     متد «Array#includes» برای تعیین اینکه آیا یه آرایه دارای مقدار خاصی در میان ورودی‌های خود با برگردوندن true یا false هس یا نه استفاده می‌شه. بیاین مثالی برای یافتن یه عنصر (عددی و رشته‌ای) تو یه آرایه ببینیم.

     <span dir="ltr" align="left">

     ```javascript
     var numericArray = [1, 2, 3, 4];
     console.log(numericArray.includes(3)); // true

     var stringArray = ['green', 'yellow', 'blue'];
     console.log(stringArray.includes('blue')); //true
     ```

     </span>

     **[فهرست](#فهرست)**

286. ### چطوری آرایه‌های scalar رو با هم مقایسه می‌کنی؟

     می‌تونین از طول و هر روش آرایه برای مقایسه دو آرایه اسکالر (مقایسه مستقیم با استفاده از ===) استفاده کنین. ترکیب این عبارات میتونه نتیجه مورد انتظار رو به دست بده،

     <span dir="ltr" align="left">

     ```javascript
     const arrayFirst = [1,2,3,4,5];
     const arraySecond = [1,2,3,4,5];
     console.log(arrayFirst.length === arraySecond.length && arrayFirst.every((value, index) => value === arraySecond[index])); // true
     ```

     </span>


     اگه می‌خواین آرایه‌ها رو بدون توجه به ترتیب مقایسه کنین باید اونا رو قبل از مرتب سازی، مرتب کنین.

     <span dir="ltr" align="left">

     ```javascript
     const arrayFirst = [2,3,1,4,5];
     const arraySecond = [1,2,3,4,5];
     console.log(arrayFirst.length === arraySecond.length && arrayFirst.sort().every((value, index) => value === arraySecond[index])); //true
     ````

     </span>

     **[فهرست](#فهرست)**

287. ### چطوری می‌شه پارامترهای صفحه رو از متد GET گرفت؟

     شیء «URL» رشته url رو می‌پذیرد و از ویژگی «searchParams» این شی می‌توان برای دسترسی به پارامترهای get استفاده کرد. به یاد داشته باشیم که ممکنه برای دسترسی به URL در مرورگرهای قدیمی (از جمله IE) نیاز به استفاده از polyfill یا «window.location» داشته باشیم.

     <span dir="ltr" align="left">

     ```javascript
     let urlString = "http://www.some-domain.com/about.html?x=1&y=2&z=3"; //window.location.href
     let url = new URL(urlString);
     let parameterZ = url.searchParams.get("z");
     console.log(parameterZ); // 3
     ```

     </span>

     **[فهرست](#فهرست)**

288. ### چطوری اعداد رو می‌شه سه رقم سه رقم جدا کرد؟

     می‌تونین از متد «Number.prototype.toLocaleString» استفاده کنین که رشته‌ای رو با نمایشی حساس به زبان مانند جداکننده هزار، ارز و غیره از این عدد برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     function convertToThousandFormat(x){
       return x.toLocaleString(); // 12,345.679
     }

     console.log(convertToThousandFormat(12345.6789));
     ```

     </span>

     **[فهرست](#فهرست)**

289. ### تفاوت‌ بین java و javascript چیه؟

     هر دو زبان برنامه نویسی کاملاً نامرتبط هستن و هیچ ارتباطی بین اونا وجود نداره. جاوا بصورت ایستا تایپ می‌شه، کامپایل می‌شه، روی ماشین مجازی خود اجرا می‌شه. در حالی که جاواسکریپت به صورت پویا تایپ می‌شه، تفسیر می‌شه و در محیط‌های مرورگر و nodejs اجرا می‌شه. بیاین تفاوت‌های عمده رو در قالب جدولی ببینیم،
      | ویژگی | جاوا | جاواسکریپت |
      |---- | ---- | -----
      | تایپ شده | این یه زبان قوی تایپ شده اس| این یه زبان تایپ شده پویاس |
      | پارادایم | برنامه نویسی شی گرا | برنامه نویسی مبتنی بر نمونه اولیه |
      | محدوده | محدوده بلوک | محدوده عملکردی |
      | همزمانی | بر اساس موضوع | مبتنی بر رویداد |
      | حافظه | از حافظه بیشتر استفاده می‌کنه | از حافظه کمتری استفاده می‌کنه. از این رو برای صفحات وب استفاده خواهد شد |
     **[فهرست](#فهرست)**

290. ### آیا جاواسکریپت namespace رو پشتیبانی می‌کنه؟

     جاواسکریپت به طور پیش فرض از فضای نام پشتیبانی نمی‌کنه. بنابراین اگه هر عنصری (تابع، روش، شی، متغیر) ایجاد کنین گلوبال می‌شه و فضای نام گلوبال رو آلوده می‌کنه. بیاین مثالی از تعریف دو تابع بدون فضای نام بزنیم،

     <span dir="ltr" align="left">

     ```javascript
     function func1() {
         console.log("This is a first definition");

     }
     function func1() {
         console.log("This is a second definition");
     }
     func1(); // This is a second definition
     ```

     </span>

     همی‌شه تعریف تابع دوم رو فراخوانی می‌کنه. در این صورت فضای نام مشکل برخورد نام رو حل می‌کنه.

     **[فهرست](#فهرست)**

291. ### چطوری namespace تعریف می‌کنی؟

     حتی اگه جاواسکریپت فاقد فضاهای نام باشه، می‌تونیم از Objects، IIFE برای ایجاد فضاهای نام استفاده کنیم.
     1. **Using Object Literal Notation:** بیاین متغیرها و توابع رو درون یه Object literal بپیچیم که به عنوان فضای نام عمل می‌کنه. پس از اون می‌تونین با استفاده از نماد شیء به اونا دسترسی داشته باشیم

     <span dir="ltr" align="left">

     ```javascript
     var namespaceOne = {
        function func1() {
            console.log("This is a first definition");
        }
     }
     var namespaceTwo = {
          function func1() {
              console.log("This is a second definition");
          }
      }
     namespaceOne.func1(); // This is a first definition
     namespaceTwo.func1(); // This is a second definition
     ```

     </span>

     2. **Using IIFE (Immediately invoked function expression):** جفت پرانتز بیرونی IIFE یه محدوده محلی برای تمام کدهای داخل آن ایجاد می‌کنه و تابع ناشناس رو به یه عبارت تابع تبدیل می‌کنه. به همین دلیل، می‌تونین یه تابع رو در دو عبارت تابع مختلف ایجاد کنین تا به عنوان فضای نام عمل کنه.

     <span dir="ltr" align="left">

     ```javascript
     (function() {
      function fun1(){
        console.log("This is a first definition");
        } fun1();
     }());

     (function() {
         function fun1(){
            console.log("This is a second definition");
        } fun1();
      }());
     ```

     </span>

     3. **Using a block and a let/const declaration:** در ECMAScript 6، شما می‌تونین به سادگی از یه بلوک و یه اعلان let برای محدود کردن دامنه یه متغیر به یه بلوک استفاده کنین.

     <span dir="ltr" align="left">

     ```javascript
      {
       let myFunction= function fun1(){
       console.log("This is a first definition");
       }
       myFunction();
      }
       //myFunction(): ReferenceError: myFunction is not defined.

      {
       let myFunction= function fun1(){
       console.log("This is a second definition");
       }
       myFunction();
      }
       //myFunction(): ReferenceError: myFunction is not defined.
     ```

     </span>

     **[فهرست](#فهرست)**

292. ### چطوری می‌تونیم تکه کد جاواسکریپت داخل یه iframe رو از صفحه والد صدا بزنیم؟

     در ابتدا باید iFrame با استفاده از «document.getElementBy» یا «window.frames» قابل دسترسی باشه. پس از اون ویژگی «contentWindow» iFrame به targetFunction دسترسی میده

     <span dir="ltr" align="left">

     ```javascript
     document.getElementById('targetFrame').contentWindow.targetFunction();
     window.frames[0].frameElement.contentWindow.targetFunction(); // Accessing iframe this way may not work in latest versions chrome and firefox

     ```

     </span>

     **[فهرست](#فهرست)**

293. ### چطوری می‌شه اختلاف timezone رو از آبجکت date بگیریم؟

     می‌تونین از روش «getTimezoneOffset» شی تاریخ استفاده کنین. این روش اختلاف منطقه زمانی رو بر حسب دقیقه از محلی فعلی (تنظیمات سیستم میزبان) به UTC برمی‌گردونه

     <span dir="ltr" align="left">

     ```javascript
     var offset = new Date().getTimezoneOffset();
     console.log(offset); // -480
     ```

     </span>

     **[فهرست](#فهرست)**

294. ### چطوری فایل‌های CSS و JS رو به شکل داینامیک بارگذاری کنیم؟

     شما می‌تونین هر دو عنصر پیوند و اسکریپت رو در DOM ایجاد کنین و اونا رو به عنوان فرزند به تگ head اضافه کنین. بیاین یه تابع برای اضافه کردن منابع اسکریپت و سبک مثل زیر ایجاد کنیم.

     <span dir="ltr" align="left">

     ```javascript
     function loadAssets(filename, filetype) {
       if (filetype == "css") { // External CSS file
            var fileReference = document.createElement("link")
            fileReference.setAttribute("rel", "stylesheet");
            fileReference.setAttribute("type", "text/css");
            fileReference.setAttribute("href", filename);
       } else if (filetype == "js") { // External JavaScript file
            var fileReference = document.createElement('script');
            fileReference.setAttribute("type", "text/javascript");
            fileReference.setAttribute("src", filename);
       }
       if (typeof fileReference != "undefined")
            document.getElementsByTagName("head")[0].appendChild(fileReference)
      }
     ```

     </span>

     **[فهرست](#فهرست)**

295. ### روش‌های مختلف برای پیدا کردن elementها توی DOM کدوما هستن؟

     اگه می‌خواین به هر عنصری در صفحه HTML دسترسی داشته باشیم، باید با دسترسی به شی سند شروع کنین. بعداً می‌تونین از یکی از روش‌های زیر برای یافتن عنصر HTML استفاده کنین.
     1. document.getElementById(id): یه عنصر رو با Id پیدا می‌کنه
     2. document.getElementsByTagName(name): یه عنصر رو با نام تگ پیدا می‌کنه
     3. document.getElementsByClassName(name):یک عنصر رو با نام کلاس پیدا می‌کنه

     **[فهرست](#فهرست)**

296. ### jQuery چیه؟

     jQuery یه کتابخانه جاواسکریپت متقابل مرورگر محبوبه که با به حداقل رسوندن اختلاف بین مرورگرها، پیمایش مدل شی سند (DOM)، مدیریت رویداد، انیمیشن‌ها و تعاملات AJAX رو فراهم می‌کنه. با فلسفه اش «کمتر بنویس، بیشتر انجام بده» شهرت زیادی داره. برای مثال، می‌تونین پیام خوش آمدگویی رو در بارگذاری صفحه با استفاده از jQuery به صورت زیر نمایش بدین.

     <span dir="ltr" align="left">

     ```javascript
     $(document).ready(function(){ // It selects the document and apply the function on page load
         alert('Welcome to jQuery world');
     });
     ```

     </span>

     **نکته:**می‌تونین اونو از سایت رسمی jquery دانلود کنین یا از CDN‌ها مانند گوگل نصب کنین.

     **[فهرست](#فهرست)**

297. ### موتور V8 جاواسکریپت چیه؟

     V8 یه موتور جاواسکریپت با کارایی بالا منبع بازه که توسط مرورگر Google Chrome استفاده می‌شه و به زبان C++ نوشته شده است. همچنین در پروژه node.js استفاده می‌شه. ECMAScript و WebAssembly رو پیاده‌سازی می‌کنه و روی ویندوز 7 یا بالاتر، macOS 10.12+ و سیستم‌های لینوکس که از پردازنده‌های x64، IA-32، ARM یا MIPS استفاده میکنن اجرا می‌شه.
     **نکته:** میتونه به صورت مستقل اجرا شه یا میتونه در هر برنامه C++ تعبیه شه.

     **[فهرست](#فهرست)**

298. ### چرا ما جاواسکریپت رو به عنوان یه زبان داینامیک می‌شناسیم؟

     جاواسکریپت یه زبان ساده تایپ شده یا یه زبان پویاعه چون متغیرها در جاواسکریپت مستقیماً با هیچ نوع مقدار خاصی مرتبط نیستن و هر متغیری رو می‌شه با مقادیری از همه نوع تخصیص/تخصیص مجدد داد.

     <span dir="ltr" align="left">

     ```javascript
     let age = 50;    // age is a number now
     age  = 'old'; // age is a string now
     age  = true;  // age is a boolean
     ```

     </span>

     **[فهرست](#فهرست)**

299. ### عملگر void چیکار می‌کنه؟

     عملگر `‍void` عبارت داده شده رو ارزیابی می‌کنه و بعد تعریف نشده (یعنی بدون بازگشت مقدار) رو برمی‌گردونه. بریم یه مثال در موردش ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     void (expression)
     void expression
     ```

     </span>

     بیاین پیامی رو بدون هیچ گونه تغییر مسیر یا بارگیری مجدد نمایش بدیم
     <span dir="ltr" align="left">

     ```javascript
     <a href="javascript:void(alert('Welcome to JS world'))">Click here to see a message</a>
     ```

     </span>

     **نکته:** این عملگر بیشتر برای بدست آوردن مقدار اولیه تعریف نشده با استفاده از "void(0)" استفاده می‌شه.

     **[فهرست](#فهرست)**

300. ### چطوری می‌شه نمایشگر موس صفحه رو به درحال لود تغییر داد؟

     مکان نما رو می‌شه برای انتظار در جاواسکریپت با استفاده از ویژگی `cursor`تنظیم کرد. بیاین این رفتار رو در بارگذاری صفحه با استفاده از تابع زیر انجام بدیم.

     <span dir="ltr" align="left">

     ```javascript
     function myFunction() {
          window.document.body.style.cursor = "wait";
     }
     ```

     </span>

     و این تابع در بارگذاری صفحه فراخوانی می‌شه

     <span dir="ltr" align="left">

     ```html
     <body onload="myFunction()">
     ```

     </span>

     **[فهرست](#فهرست)**

301. ### چطوری می‌شه یه حلقه بی‌نهایت درست کرد؟

     شما می‌تونین حلقه‌های بی نهایت با استفاده از حلقه‌های for و while بدون استفاده از هیچ عبارتی ایجاد کنین. ساختار یا نحو حلقه for از نظر ESLint و ابزارهای بهینه ساز کد، رویکرد بهتریه.

     <span dir="ltr" align="left">

     ```javascript
     for (;;) {}

     while(true) {
     }
     ```

     </span>

     **[فهرست](#فهرست)**

302. ### چرا باید در استفاده از عبارت with تجدیدنظر کرد؟

     دستور با جاواسکریپت در نظر گرفته شده بود که مختصری برای نوشتن دسترسی‌های تکرارشونده به اشیا ارائه بده. بنابراین میتونه با کاهش نیاز به تکرار یه مرجع طولانی بدون جریمه عملکرد، به کاهش اندازه فایل کمک کنه. بیاین مثالی بزنیم که تو اون برای جلوگیری از افزونگی موقع چندین بار دسترسی به یه شی استفاده می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     a.b.c.greeting   = 'welcome';
     a.b.c.age = 32;
     ```

     </span>

     استفاده از "with" کد رو به این شکل تبدیل می کنه:

     <span dir="ltr" align="left">

     ```javascript
     with(a.b.c) {
          greeting   = "welcome";
          age = 32;
     }
     ```

     </span>

     اما این عبارت `with` مشکلات عملکردی ایجاد می‌کنه، چون نمی‌شه پیش‌بینی کرد که آیا یه آرگومان به یه متغیر واقعی اشاره می‌کنه یا به یه ویژگی درون آرگومان with.

     **[فهرست](#فهرست)**

303. ### خروجی این حلقه‌ها چی می‌شه؟

     <span dir="ltr" align="left">

     ```javascript
     for (var i = 0; i < 4; i++) { // global scope
       setTimeout(() => console.log(i));
     }

     for (let i = 0; i < 4; i++) { // block scope
       setTimeout(() => console.log(i));
     }
     ```

     </span>

     خروجی حلقه‌های بالا 4 4 4 4 و 0 1 2 3 است
     **توضیح:** با توجه به صف رویداد/حلقه جاواسکریپت، تابع 'setTimeout' پس از اجرای حلقه فراخوانی می‌شه. از اونجایی که متغیر i با کلمه کلیدی "var" اعلان می‌شه، به یه متغیر جهانی تبدیل می‌شه و با استفاده از تکرار زمانی که تابع time setTimeout فراخوانی می‌شه، مقدار آن برابر با 4. بنابراین، خروجی حلقه اول '4 4 4 4' است. در حالی که در حلقه دوم، متغیر i به‌عنوان کلمه کلیدی «let» اعلام می‌شه، به متغیری با محدوده بلوک تبدیل می‌شه و یه مقدار جدید (0, 1,2 3) برای هر تکرار داره. بنابراین، خروجی حلقه اول «0 1 2 3» است.

     **[فهرست](#فهرست)**

304. ### می‌تونی یه سری از ویژگی‌های ES6 رو اسم ببری؟

     در زیر لیستی از بعضی از ویژگی‌های جدید ES6 اومده.
     1. پشتیبانی از ثابت‌ها یا متغیرهای تغییرناپذیر
     2. پشتیبانی Block-scope برای متغیرها، ثابت‌ها و توابع
     3. Arrow functions
     4. پارامترهای پیش فرض
     5. پارامتر‌های Rest and Spread 
     6. Template Literals
     7. Multi-line Strings
     8. Destructuring Assignment
     9. Enhanced Object Literals
     10. Promises
     11. Classes
     12. Modules

     **[فهرست](#فهرست)**

305. ### ES6 چیه؟

     ES6 ششمین نسخه از زبان جاواسکریپت‌ـه و در ژوئن 2015 منتشر شد. در ابتدا با نام ECMAScript 6 (ES6) شناخته شد و بعداً به ECMAScript 2015 تغییر نام داد. تقریباً همه مرورگرهای مدرن از ES6 پشتیبانی می‌کنن اما برای مرورگرهای قدیمی ترانسپایلرهای زیادی وجود داره.، مانند Babel.js و غیره

     **[فهرست](#فهرست)**

306. ### آیا می‌تونیم متغیرهای تعریف شده با let و const رو مجددا declare کنیم؟

     نه، شما نمی‌تونین متغیرهای let و const رو مجدداً اعلام کنین. اگه این کار رو انجام بدین، خطای زیر رو نشون میده

     <span dir="ltr" align="left">

     ```bash
     Uncaught SyntaxError: Identifier 'someVariable' has already been declared
     ```

     </span>

     **توضیح:** اعلان متغیر با کلمه کلیدی "var" به یه محدوده تابع اشاره داره و با متغیر به دلیل ویژگی بالا بردن به گونه ای رفتار می‌شه که گویی در بالای محدوده محصور اعلام شده است. بنابراین همه اعلان‌های چندگانه بدون هیچ خطایی در ایجاد یه متغیر hoisted مشترک نقش دارن. بیاین مثالی از اعلان مجدد متغیرها تو یه محدوده برای متغیرهای var و let/const بزنیم.

     <span dir="ltr" align="left">

     ```javascript
     var name = 'John';
     function myFunc() {
         var name = 'Nick';
         var name = 'Abraham'; // Re-assigned in the same function block
         alert(name); // Abraham
     }
     myFunc();
     alert(name); // John
     ```

     </span>

     اعلان چندگانه با محدوده بلوک، خطای نحوی ایجاد می‌کنه،

     <span dir="ltr" align="left">

     ```javascript
     let name = 'John';
     function myFunc() {
         let name = 'Nick';
         let name = 'Abraham'; // Uncaught SyntaxError: Identifier 'name' has already been declared
         alert(name);
     }

     myFunc();
     alert(name);
     ```

     </span>

     **[فهرست](#فهرست)**

307. ### آیا استفاده از const برای تعریف متغیر اونا رو immutable می‌کنه؟

     خیر، متغیر const مقدار رو تغییرناپذیر نمی‌کنه. اما تخصیص‌های بعدی رو مجاز نمی‌داند (یعنی می‌تونین با تخصیص اعلام کنین اما بعداً نمی‌تونین مقدار دیگری رو اختصاص بدین)

     <span dir="ltr" align="left">

     ```javascript
     const userList = [];
     userList.push('John'); // Can mutate even though it can't re-assign
     console.log(userList); // ['John']
     ```

     </span>

     **[فهرست](#فهرست)**

308. ### parameterهای پیش‌فرض چی هستن؟

     در E5، برای مدیریت مقادیر پیش‌فرض پارامترهای تابع، باید به عملگرهای OR منطقی وابسته باشیم. در حالی که در ES6، ویژگی پارامترهای تابع پیش‌فرض اجازه میده تا پارامترها با مقادیر پیش‌فرض مقداردهی اولیه بشن، اگه مقداری یا تعریف‌نشده ارسال نشه. بیاین رفتار رو با یه مثال مقایسه کنیم،

     <span dir="ltr" align="left">

     ```javascript
     //ES5
     var calculateArea = function(height, width) {
        height =  height || 50;
        width = width || 60;

        return width * height;
     }
     console.log(calculateArea()); //300
     ```

     </span>

     پارامترهای پیش فرض، مقدارههی اولیه رو ساده تر می‌کنه،

     <span dir="ltr" align="left">

     ```javascript
     //ES6
     var calculateArea = function(height = 50, width = 60) {
        return width * height;
     }

     console.log(calculateArea()); //300
     ```

     </span>

     **[فهرست](#فهرست)**

309. ### template-literalها چی هستن؟

     حروف الفبای الگو یا رشته‌های الگو، حروف الفبای رشته‌ای هستن که امکان عبارات تعبیه‌شده رو میدن. اینا به جای گیومه‌های دوتایی یا تکی با کاراکتر بک تیک (`) محصور میشن
      در E6، این ویژگی استفاده از عبارات پویا رو به شرح زیر امکان پذیر می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     var greeting = `Welcome to JS World, Mr. ${firstName} ${lastName}.`
     ```

     </span>

     In ES5, you need break string like below,

     <span dir="ltr" align="left">

     ```javascript
     var greeting = 'Welcome to JS World, Mr. ' + firstName + ' ' + lastName.`
     ```

     </span>

     **نکته:** می‌تونین از رشته‌های چند خطی و ویژگی‌های درون‌یابی رشته‌ای با الفبای الگو استفاده کنین.

     **[فهرست](#فهرست)**

310. ### چطوری رشته‌های چند خطی رو توی template-literalها می‌نویسیم؟

     در ES5، برای بدست آوردن رشته‌های چند خطی، باید از کاراکترهای فرار از خط جدید ('\\n') و نمادهای الحاقی (+) استفاده کنین.

     <span dir="ltr" align="left">

     ```javascript
     console.log('This is string sentence 1\n' +
     'This is string sentence 2');
     ```

     </span>

     در حالی که در ES6، نیازی به ذکر کاراکتر دنباله خط جدید نیست،

     <span dir="ltr" align="left">

     ```javascript
     console.log(`This is string sentence
     'This is string sentence 2`);
     ```

     </span>

     **[فهرست](#فهرست)**

311. ### template-literal‌های تودرتو چی هستن؟

     الگوی تودرتو یه ویژگیه که در نحو تحت اللفظی الگو پشتیبانی می‌شه تا امکان بکتیک‌های درونی تو یه مکان‌نمای ${ } رو در قالب فراهم کنه. برای مثال، الگوی تودرتو زیر برای نمایش نمادها بر اساس مجوزهای کاربر استفاده می‌شه، در حالی که الگوی بیرونی نوع پلت فرم رو بررسی می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     const iconStyles = `icon ${ isMobilePlatform() ? '' :
      `icon-${user.isAuthorized ? 'submit' : 'disabled'}` }`;
     ```

     </span>

     می‌تونین مورد استفاده بالا رو بدون ویژگی‌های الگوی تودرتو هم بنویسین. با این حال، ویژگی الگوی تودرتو فشرده‌تر و خواناتر است.

     <span dir="ltr" align="left">

     ```javascript
     //Without nesting templates
      const iconStyles = `icon ${ isMobilePlatform() ? '' :
       (user.isAuthorized ? 'icon-submit' : 'icon-disabled'}`;
     ```

     </span>

     **[فهرست](#فهرست)**

312. ### tagged-templateها چی هستن؟

     الگوهای برچسب‌گذاری شده شکل پیشرفته‌ای از قالب‌ها هستن که تو اون برچسب‌ها به شما اجازه میدن تا کلمات قالب رو با یه تابع تجزیه کنین. تابع تگ اولین پارامتر رو به عنوان آرایه ای از رشته‌ها و پارامترهای باقی مانده رو به عنوان عبارات می پذیرد. این تابع همچنین میتونه رشته‌های دستکاری شده رو بر اساس پارامترها برگرداند. بیاین نحوه استفاده از رفتار الگوی برچسب گذاری شده مجموعه مهارت‌های حرفه ای فناوری اطلاعات تو یه سازمان رو ببینیم.

     <span dir="ltr" align="left">

     ```javascript
     var user1 = 'John';
     var skill1 = 'JavaScript';
     var experience1 = 15;

     var user2 = 'Kane';
     var skill2 = 'JavaScript';
     var experience2 = 5;

     function myInfoTag(strings, userExp, experienceExp, skillExp) {
       var str0 = strings[0]; // "Mr/Ms. "
       var str1 = strings[1]; // " is a/an "
       var str2 = strings[2]; // "in"

       var expertiseStr;
       if (experienceExp > 10){
         expertiseStr = 'expert developer';
       } else if(skillExp > 5 && skillExp <= 10) {
         expertiseStr = 'senior developer';
       } else {
         expertiseStr = 'junior developer';
       }

       return ${str0}${userExp}${str1}${expertiseStr}${str2}${skillExp};
     }

     var output1 = myInfoTag`Mr/Ms. ${ user1 } is a/an ${ experience1 } in ${skill1}`;
     var output2 = myInfoTag`Mr/Ms. ${ user2 } is a/an ${ experience2 } in ${skill2}`;

     console.log(output1);// Mr/Ms. John is a/an expert developer in JavaScript
     console.log(output2);// Mr/Ms. Kane is a/an junior developer in JavaScript
     ```

     </span>

     **[فهرست](#فهرست)**

313. ### رشته‌های خام چی هستن؟

     ES6 با استفاده از روش «String.raw» ویژگی رشته‌های خام رو ارائه می‌کنه که برای دریافت شکل رشته خام رشته‌های الگو استفاده می‌شه. این ویژگی به شما این امکان رو میده تا به رشته‌های خام همونطور که وارد شده‌اند، بدون پردازش دنباله‌های فرار دسترسی داشته باشیم. بریم یه مثال در موردش ببینیم،

      <span dir="ltr" align="left">

      ```javascript
      var calculationString = String.raw `The sum of numbers is \n${1+2+3+4}!`;
      console.log(calculationString); // The sum of numbers is 10
      ```

      </span>

     اگه از رشته‌های خام استفاده نمی‌کنین دنباله کاراکترهای خط جدید با نمایش خروجی در چندین خط پردازش می‌شه.

     <span dir="ltr" align="left">

      ```javascript
      var calculationString = `The sum of numbers is \n${1+2+3+4}!`;
      console.log(calculationString);
      // The sum of numbers is
      // 10
      ```

      </span>

     همچنین، ویژگی خام در اولین آرگومان تابع تگ موجود است

      <span dir="ltr" align="left">

      ```javascript
      function tag(strings) {
         console.log(strings.raw[0]);
      }
      ```

      </span>

     **[فهرست](#فهرست)**

314. ### assign کردن با destructuring چیه و چطوری انجام می‌شه؟

     تخصیص `destructuring` یه عبارت جاواسکریپت‌ـه که امکان باز کردن مقادیر آرایه‌ها یا خصوصیات از اشیاء به متغیرهای مجزا رو فراهم می‌کنه.
      بیاین مقادیر ماه رو از یه آرایه با استفاده از تخصیص ساختارشکن به دست آوریم

     <span dir="ltr" align="left">

     ```javascript
     var [one, two, three] = ['JAN', 'FEB', 'MARCH'];

     console.log(one); // "JAN"
     console.log(two); // "FEB"
     console.log(three); // "MARCH"
     ```

     </span>

     و شما می‌تونین ویژگی‌های کاربر یه آبجکت رو با استفاده از انتساب destructuring به دست بیارین،

     <span dir="ltr" align="left">

     ```javascript
     var {name, age} = {name: 'John', age: 32};

     console.log(name); // John
     console.log(age); // 32
     ```

     </span>

     **[فهرست](#فهرست)**

315. ### موقع assign کردن با destructuring چطوری می‌شه مقدار اولیه تعریف کرد؟

     زمانی که مقدار باز شده از آرایه یا شیء در طول تخصیص ساختارشکن تعریف نشده باشه، می‌شه به یه متغیر یه مقدار پیش فرض اختصاص داد. این کمک می‌کنه تا از تنظیم مقادیر پیش فرض جداگانه برای هر انتساب جلوگیری کنین. بیاین برای هر دو آرایه و موارد استفاده از شی مثالی بزنیم،

     **Arrays destructuring:**

     <span dir="ltr" align="left">

     ```javascript
     var x, y, z;

     [x=2, y=4, z=6] = [10];
     console.log(x); // 10
     console.log(y); // 4
     console.log(z); // 6
     ```

     </span>

     **Objects destructuring:**

     <span dir="ltr" align="left">

     ```javascript
     var {x=2, y=4, z=6} = {x: 10};

     console.log(x); // 10
     console.log(y); // 4
     console.log(z); // 6
     ```

     </span>

     **[فهرست](#فهرست)**

316. ### چطوری می‌تونیم مقدار یه آرایه رو با استفاده از destructuring-assignment تعویض کنیم؟

     اگه از destructuring-assignment استفاده نمی‌کنین تعویض دو مقدار به یه متغیر موقت نیاز داره. در حالی که با استفاده از یه ویژگی ساختارشکن، دو مقدار متغیر رو می‌شه تو یه عبارت ساختار شکن جایگزین کرد. بیاین دو متغیر عددی رو در انتساب ساختارزدایی آرایه با هم عوض کنیم،

     <span dir="ltr" align="left">

     ```javascript
     var x = 10, y = 20;

     [x, y] = [y, x];
     console.log(x); // 20
     console.log(y); // 10
     ```

     </span>

     **[فهرست](#فهرست)**

317. ### Enhanced-object-literalها چی هستن؟

     Enhanced-object-literal ایجاد سریع اجسام با ویژگی‌های درون براکت رو آسان می‌کنه. برای مثال، نحو کوتاه‌تری رو برای تعریف ویژگی شی مشترک به شرح زیر ارائه می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     //ES6
     var x = 10, y = 20
     obj = { x, y }
     console.log(obj); // {x: 10, y:20}
     //ES5
     var x = 10, y = 20
     obj = { x : x, y : y}
     console.log(obj); // {x: 10, y:20}
     ```

     </span>

     **[فهرست](#فهرست)**

318. ### importهای داینامیک چی هستن؟

     واردات پویا با استفاده از نحو تابع «import» به ما اجازه میده تا ماژول‌ها رو در صورت تقاضا با استفاده از دستورات یا دستور async/await بارگذاری کنیم. در حال حاضر این ویژگی در [پیشنهاد مرحله4] (https://github.com/tc39/proposal-dynamic-import) هستش. مزیت اصلی واردات پویا کاهش اندازه بسته‌های ما، پاسخ حجم/بار بار درخواست‌های ما و بهبود کلی در تجربه کاربر است.

     <span dir="ltr" align="left">

     ```javascript
     import('./Module').then(Module => Module.method());
     ```

     </span>

     **[فهرست](#فهرست)**

319. ### کاربرد importهای داینامیک چیه؟

     در زیر بعضی از موارد استفاده از واردات پویا نسبت به واردات استاتیک آورده شده است.
     1. یه ماژول رو به صورت درخواستی یا مشروط وارد کنین. برای مثال، اگه می‌خواین یه polyfill رو در مرورگر قدیمی بارگذاری کنین

     <span dir="ltr" align="left">

     ```javascript
     if (isLegacyBrowser()) {
         import(···)
         .then(···);
     }
     ```

     </span>

     2. تعیین کننده ماژول رو در زمان اجرا محاسبه کنین. برای مثال می‌تونین از اون برای گلوبال سازی استفاده کنین.

     <span dir="ltr" align="left">

     ```javascript
     import(`messages_${getLocale()}.js`).then(···);
     ```

     </span>

     3. یه ماژول رو از داخل یه اسکریپت معمولی به جای یه ماژول وارد کنین.

     **[فهرست](#فهرست)**

320. ### آرایه‌های نوع‌دار(typed-arrays) چیه؟

     آرایه‌های تایپ شده آبجکت‌هایی آرایه مانند از ECMAScript 6 API برای مدیریت داده‌های باینری هستن. جاواسکریپت 8 نوع آرایه تایپ شده رو ارائه میده،

     1. Int8Array: آرایه ای از اعداد صحیح امضا شده 8 بیتی
     2. Int16Array: آرایه ای از اعداد صحیح امضا شده 16 بیتی
     3. Int32Array: آرایه ای از اعداد صحیح امضا شده 32 بیتی
     4. Uint8Array: آرایه ای از اعداد صحیح بدون علامت 8 بیتی
     5. Uint16Array: آرایه ای از اعداد صحیح بدون علامت 16 بیتی
     6. Uint32Array:  آرایه ای از اعداد صحیح بدون علامت 32 بیتی
     7. Float32Array:آرایه ای از اعداد ممیز شناور 32 بیتی
     8. Float64Array: آرایه ای از اعداد ممیز شناور 64 بیتی

     برای مثال، شما می‌تونین یه آرایه از اعداد صحیح امضا شده 8 بیتی مانند زیر ایجاد کنین

     <span dir="ltr" align="left">

     ```javascript
     const a = new Int8Array();
     // You can pre-allocate n bytes
     const bytes = 1024
     const a = new Int8Array(bytes)
     ```

     </span>

     **[فهرست](#فهرست)**

321. ### مزایای لودر ماژول‌ها چیه؟

     ماژول لودر ویژگی‌های زیر رو ارائه میده
     1. Dynamic loading
     2. State isolation
     3. Global namespace isolation
     4. Compilation hooks
     5. Nested virtualization

     **[فهرست](#فهرست)**

322. ### collation چیه؟

     Collation برای مرتب سازی مجموعه ای از رشته‌ها و جستجو در مجموعه ای از رشته‌ها استفاده می‌شه. این پارامتر توسط محلی و از Unicode آگاه است. بیاین ویژگی‌های مقایسه و مرتب سازی رو در نظر بگیریم،
     1. **Comparison:**

     <span dir="ltr" align="left">

     ```javascript
     var list = [ "ä", "a", "z" ]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
     var l10nDE = new Intl.Collator("de");
     var l10nSV = new Intl.Collator("sv");
     console.log(l10nDE.compare("ä", "z") === -1); // true
     console.log(l10nSV.compare("ä", "z") === +1); // true
     ```

     </span>

     2. **Sorting:**

     <span dir="ltr" align="left">

     ```javascript
     var list = [ "ä", "a", "z" ]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
     var l10nDE = new Intl.Collator("de");
     var l10nSV = new Intl.Collator("sv");
     console.log(list.sort(l10nDE.compare)) // [ "a", "ä", "z" ]
     console.log(list.sort(l10nSV.compare)) // [ "a", "z", "ä" ]
     ```

     </span>

     **[فهرست](#فهرست)**

323. ### عبارت for...of چیه؟

     دستور for...of یه حلقه تکرار بر روی اشیاء یا عناصر قابل تکرار مثل رشته داخلی، آرایه، اشیاء آرایه مانند (مثل آرگومان‌ها یا NodeList)، TypedArray، Map، Set و تکرارهای تعریف شده توسط کاربر ایجاد می‌کنه. 

     <span dir="ltr" align="left">

     ```javascript
     let arrayIterable = [10, 20, 30, 40, 50];

     for (let value of arrayIterable) {
       value ++;
       console.log(value); // 11 21 31 41 51
     }
     ```

     </span>

     **[فهرست](#فهرست)**

324. ### خروجی عملگر spread روی آرایه زیر چیه؟

     <span dir="ltr" align="left">

     ```javascript
     [...'John Resig']
     ```

     </span>

     خروجی آرایه ['J', 'o', 'h', 'n', ', 'R', 'e', 's', 'i', 'g'] است.
      **توضیح:** رشته یه نوع تکرارپذیره و عملگر spread تو یه آرایه هر کاراکتر یه تکرارپذیر رو به یه عنصر نگاشت می‌کنه. از این رو، هر کاراکتر یه رشته به عنصری تو یه آرایه تبدیل می‌شه.

     **[فهرست](#فهرست)**

325. ### آیا PostMessage امنه؟

     بله، تا زمانی که برنامه‌نویس/توسعه‌دهنده مراقب منشأ و منبع پیام دریافتی باشه، postMessages رو می‌شه بسیار امن در نظر گرفت. اما اگه بخواین پیامی رو بدون تأیید منبع آن ارسال یا دریافت کنین حملات اسکریپت بین سایتی ایجاد می‌شه.

     **[فهرست](#فهرست)**

326. ### مشکلات استفاده از postmessage با origin روی wildcard چیه؟

     آرگومان دوم متد postMessage مشخص می‌کنه که کدوم مبدا مجاز به دریافت پیامه. اگه از علامت "*" به عنوان آرگومان استفاده کنین هر منبعی مجاز به دریافت پیامه. در این حالت، هیچ راهی برای پنجره فرستنده وجود نداره که بفهمه پنجره هدف در موقع ارسال پیام در مبدأ هدف قرار داره یا نه. اگه پنجره هدف به مبدأ دیگری هدایت شه، مبدا دیگر داده‌ها رو دریافت می‌کنه. از این رو، این ممکنه منجر به آسیب پذیری‌های XSS شه.

     <span dir="ltr" align="left">

     ```javascript
     targetWindow.postMessage(message, '*');
     ```

     </span>

     **[فهرست](#فهرست)**

327. ### چطوری از دریافت postMessageهای ناخواسته و ناامن از طرف هکرها جلوگیری کنیم؟

     از اونجایی که شنونده به هر پیامی گوش میده، مهاجم میتونه برنامه رو با ارسال پیامی از مبدأ مهاجم فریب بده که این تصور رو ایجاد می‌کنه که گیرنده پیام رو از پنجره فرستنده واقعی دریافت کرده. شما می‌تونین با اعتبارسنجی مبدا پیام در انتهای گیرنده با استفاده از ویژگی "message.origin" از این مشکل جلوگیری کنین. برای مثال، اجازه بدین مبدا فرستنده [http://www.some-sender.com](http://www.some-sender.com) در سمت گیرنده [www.some-receiver.com] (www.some) رو بررسی کنیم -receiver.com)،

     <span dir="ltr" align="left">

     ```javascript
     //Listener on http://www.some-receiver.com/
     window.addEventListener("message", function(message){
         if(/^http://www\.some-sender\.com$/.test(message.origin)){
              console.log('You received the data from valid sender', message.data);
        }
     });
     ```

     </span>

     **[فهرست](#فهرست)**

328. ### می‌تونیم کلا postMessageها رو غیرفعال کنیم؟

     شما نمی‌تونین به طور کامل (یا 100٪) از postMessages استفاده نکنین. حتی اگه برنامه شما با توجه به خطرات از postMessage استفاده نمی‌کنه، بسیاری از اسکریپت‌های شخص ثالث از postMessage برای برقراری ارتباط با سرویس شخص ثالث استفاده می‌کنن. بنابراین ممکنه برنامه شما بدون اطلاع شما از postMessage استفاده کنه.

     **[فهرست](#فهرست)**

329. ### آیا postMessageها به صورت synchronous و همزمان کار می‌کنن؟

     postMessages در مرورگر IE8 همگام هستن اما در IE9 و سایر مرورگرهای مدرن دیگر (یعنی IE9+، Firefox، Chrome، Safari) ناهمزمان هستن. به دلیل این رفتار ناهمزمان، زمانی که postMessage برگردونده می‌شه، از مکانیزم callback استفاده می‌کنیم.

     **[فهرست](#فهرست)**

330. ### پارادیم زبان جاواسکریپت چیه؟

     جاواسکریپت یه زبان چند پارادایمه که از برنامه نویسی امری/روشی، برنامه نویسی شی گرا و برنامه نویسی تابعی پشتیبانی می‌کنه. جاواسکریپت از برنامه نویسی شی گرا با وراثت اولیه پشتیبانی می‌کنه.

     **[فهرست](#فهرست)**

331. ### تفاوت‌های بین جاواسکریپت داخلی و خارجی چیه؟

     **جاواسکریپت داخلی:** کد منبع درون تگ اسکریپته.
      **جاواسکریپت خارجی:** کد منبع تو یه فایل خارجی (ذخیره شده با پسوند js.) ذخیره می‌شه و در تگ ارجاع می‌شه.

     **[فهرست](#فهرست)**

332. ### آیا جاواسکریپت سریعتر از اسکریپت‌های سمت سرور است؟

     بله، جاواسکریپت سریعتر از اسکریپت سمت سروره. از اونجایی که جاواسکریپت یه اسکریپت سمت کلاینته برای محاسبات یا محاسبات خودش به کمک سرور وب نیازی نداره. بنابراین جاواسکریپت همی‌شه سریعتر از هر اسکریپت سمت سرور مانند ASP، PHP و غیره اس.

     **[فهرست](#فهرست)**

333. ### چطوری وضعیت چک بودن یه checkbox رو بدست بیاریم؟

     می‌تونین ویژگی`‍checked` رو در کادر انتخاب شده در DOM اعمال کنین. اگه مقدار "True" باشه به این معنیه که چک باکس علامت زده شده در غیر این صورت علامت اونو بردارین. برای مثال، عنصر چک باکس HTML زیر رو می‌شه با استفاده از جاواسکریپت به صورت زیر در دسترس قرار داد.

     <span dir="ltr" align="left">

     ```html
       <input type="checkbox" name="checkboxname" value="Agree"> Agree the conditions<br>
     ```

     </span>

     <span dir="ltr" align="left">

     ```javascript
     console.log(document.getElementById(‘checkboxname’).checked); // true or false
     ```

     </span>

     **[فهرست](#فهرست)**

334. ### هدف از عملگر double-tilde چیه؟

     عملگر دابل tilde(~~) به عنوان عملگر bitwise double NOT شناخته می‌شه. این عملگر قراره جایگزین سریع تری برای `Math.floor`.

     **[فهرست](#فهرست)**

335. ### چطوری یه کاراکتر رو به کد ASCII تبدیل کنیم؟

     برای تبدیل کاراکترهای رشته به اعداد اسکی می‌تونین از متد `String.prototype.charCodeAt` استفاده کنین. برای مثال، بیاین کد ASCII رو برای حرف اول رشته «ABC» پیدا کنیم،

     <span dir="ltr" align="left">

     ```javascript
     "ABC".charCodeAt(0) // returns 65
     ```

     </span>

     در حالی که روش `String.fromCharCode` اعداد رو به کاراکترهای `ASCII` برابر تبدیل می‌کنه.

     <span dir="ltr" align="left">

     ```javascript
     String.fromCharCode(65,66,67); // returns 'ABC'
     ```

     </span>

     **[فهرست](#فهرست)**

336. ### ArrayBuffer چیه؟

     یه شی ArrayBuffer برای نشون دادن یه بافر داده باینری خام عمومی با طول ثابت استفاده می‌شه. می‌تونین اونو به صورت زیر ایجاد کنین

     <span dir="ltr" align="left">

     ```javascript
     let buffer = new ArrayBuffer(16); // create a buffer of length 16
     alert(buffer.byteLength); // 16
     ```

     </span>

     برای دستکاری یه ArrayBuffer، باید از یه شی "view" استفاده کنیم.

     <span dir="ltr" align="left">

     ```javascript
     //Create a DataView referring to the buffer
      let view = new DataView(buffer);
     ```

     </span>

     **[فهرست](#فهرست)**

337. ### خروجی کد زیر چی خواهد بود؟

     <span dir="ltr" align="left">

     ```javascript
     console.log("Welcome to JS world"[0])
     ```

     </span>

     خروجی عبارت بالا "W" عه.
      **توضیح:** نماد براکت با شاخص خاص روی یه رشته کاراکتر رو تو یه مکان خاص برمی‌گردونه. از این رو، کاراکتر "W" رشته رو برمی‌گردونه. از اونجایی که این مورد در نسخه‌های IE7 و پایین‌تر پشتیبانی نمی‌شه، ممکنه لازم باشه از متد charAt برای به دست آوردن نتیجه دلخواه استفاده کنین.

     **[فهرست](#فهرست)**

338. ### هدف از Error-object چیه؟

     سازنده Error یه شی خطا ایجاد می‌کنه و نمونه‌هایی از آبجکت‌های خطا موقع رخ دادن خطاهای زمان اجرا پرتاب میشن شی Error همچنین میتونه به عنوان یه شی پایه برای استثناهای تعریف شده توسط کاربر استفاده شه. برای مثال

     <span dir="ltr" align="left">

     ```javascript
     new Error([message[, fileName[, lineNumber]]])
     ```

     </span>

     شما می‌تونین استثناها یا خطاهای تعریف شده توسط کاربر رو با استفاده از آبجکت Error در بلوک try...catch مانند زیر پرتاب کنین.

     <span dir="ltr" align="left">

     ```javascript
     try {
       if(withdraw > balance)
       throw new Error("Oops! You don't have enough balance");
     } catch (e) {
       console.log(e.name + ': ' + e.message);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

339. ### هدف از EvalError-object چیه؟

     شی `EvalError` یه خطا در رابطه با تابع `eval` جهانی رو نشون میده. حتی اگه این استثنا دیگر توسط جاواسکریپت پرتاب نمی‌شه، شی EvalError برای سازگاری باقی می ماند. برای مثال

     <span dir="ltr" align="left">

     ```javascript
     new EvalError([message[, fileName[, lineNumber]]])
     ```

     </span>

     می‌تونین EvalError رو با بلوک try...catch مانند زیر پرتاب کنین.

     <span dir="ltr" align="left">

     ```javascript
     try {
       throw new EvalError('Eval function error', 'someFile.js', 100);
     } catch (e) {
       console.log(e.message, e.name, e.fileName);              // "Eval function error", "EvalError", "someFile.js"
     }
     ```

     </span>

     **[فهرست](#فهرست)**

340. ### خطاهایی که در حالت strict-mode رخ میدن ولی در غیر اون وجود ندارن کدوما هستن؟

     وقتی `use strict` رو اعمال می‌کنین. syntax، بعضی از موارد زیر قبل از اجرای اسکریپت یه SyntaxError ایجاد می‌کنن
     1. وقتی از دستور `Octal` استفاده می‌کنین

     <span dir="ltr" align="left">

     ```javascript
     var n = 022;
     ```

     </span>
     
     2. استفاده از عبارت ‍‍‍`with`.
     3. وقتی از عملگر حذف روی نام متغیر استفاده می‌کنین
     4. استفاده از eval یا آرگومان‌ها به عنوان متغیر یا نام آرگومان تابع
     5. موقعی که از کلمات کلیدی رزرو شده جدید استفاده می‌کنین
     6. موقعی که یه تابع رو تو یه بلوک اعلام می‌کنین

     <span dir="ltr" align="left">

     ```javascript
     if (someCondition) { function f() {} }
     ```

     </span>

     از این رو، خطاهای موارد بالا برای جلوگیری از خطا در محیط‌های توسعه/تولید مفید هستن.

     **[فهرست](#فهرست)**

341. ### آیا همه objectها دارای prototype هستن؟

     خیر. همه objectها دارای نمونه اولیه هستن به جز object پایه که توسط کاربر ایجاد می‌شه یا آبجکت‌ای که با استفاده از کلمه کلیدی new ایجاد می‌شه.

     **[فهرست](#فهرست)**

342. ### تفاوت‌های بین parameter و argument چیه؟

     پارامتر نام متغیر تعریف یه تابعه در حالی که یه آرگومان نشون دهنده مقدار داده شده به تابع موقع کال شدنشه. بیاین این رو با یه تابع ساده توضیح بدیم

     <span dir="ltr" align="left">

     ```javascript
     function myFunction(parameter1, parameter2, parameter3) {
       console.log(arguments[0]) // "argument1"
       console.log(arguments[1]) // "argument2"
       console.log(arguments[2]) // "argument3"
     }
     myFunction("argument1", "argument2", "argument3")
     ```

     </span>

     **[فهرست](#فهرست)**

343. ### هدف از متد some روی آرایه‌ها چیه؟

     متد `some` برای آزمایش اینکه آیا حداقل یه عنصر در آرایه از آزمون پیاده‌سازی شده توسط تابع ارائه شده عبور می‌کنه یا نه استفاده می‌شه. متد یه مقدار بولین برمی‌گردونه. بیاین مثالی بزنیم تا هر عنصر عجیب و غریب رو آزمایش کنیم،

     <span dir="ltr" align="left">

     ```javascript
     var array = [1, 2, 3, 4, 5, 6 ,7, 8, 9, 10];

     var odd = element ==> element % 2 !== 0;

     console.log(array.some(odd)); // true (the odd element exists)
     ```

     </span>

     **[فهرست](#فهرست)**

344. ### چطوری دو یا تعداد بیشتری از آرایه‌ها رو با هم ترکیب کنیم؟

     متد `concat` برای پیوستن دو یا چند آرایه با برگردوندن یه آرایه جدید حاوی تمام عناصر استفاده می‌شه.مثال:

     <span dir="ltr" align="left">

     ```javascript
     array1.concat(array2, array3, ..., arrayX)
     ```

     </span>

     بیاین مثالی از الحاق آرایه با آرایه‌های سبزیجات و میوه‌ها رو مثال بزنیم.

     <span dir="ltr" align="left">

     ```javascript
       var veggies = ["Tomato", "Carrot", "Cabbage"];
       var fruits = ["Apple", "Orange", "Pears"];
       var veggiesAndFruits = veggies.concat(fruits);
       console.log(veggiesAndFruits); // Tomato, Carrot, Cabbage, Apple, Orange, Pears
     ```

     </span>

     **[فهرست](#فهرست)**

345. ### تفاوت‌های بین Shallow و Deep کپی چیه؟


     **کپی کم عمق:**
      کپی کم عمق یه کپی بیتی از یه شی است. یه شی جدید ایجاد می‌شه که یه کپی دقیق از مقادیر موجود در شی اصلی داره. اگه هر یه از فیلدهای شی ارجاع به آبجکت‌های دیگه باشه، فقط آدرس‌های مرجع کپی می شن یعنی فقط آدرس حافظه کپی می‌شه.

     **مثال**

      <span dir="ltr" align="left">

      ```javascript
      var empDetails = {
        name: "John", age: 25, expertise: "Software Developer"
      }
      ```

      </span>

     برای ایجاد یه نسخه تکراری

      <span dir="ltr" align="left">

      ```javascript
      var empDetailsShallowCopy = empDetails    //Shallow copying!
      ```

      </span>

     اگه مقداری از ویژگی رو تو یه تکراری به این صورت تغییر بدیم:

      <span dir="ltr" align="left">

      ```javascript
      empDetailsShallowCopy.name = "Johnson"
      ```

      </span>

     دستور بالا همچنین نام ‍`empDetails` رو تغییر میده، چون ما یه کپی کم عمق داریم. یعنی ما داده‌های اصلی رو هم از دست می دیم.

     **کپی عمیق(Deep):**
     یه کپی عمیق همه فیلدها رو کپی می‌کنه و از حافظه تخصیص یافته به صورت پویا که توسط فیلدها به آن اشاره می‌شه کپی می‌کنه. یه کپی عمیق زمانی اتفاق میوفته که یه شی همراه با آبجکت‌هایی که به اون اشاره داره کپی شه.

     **Example**

      <span dir="ltr" align="left">

      ```javascript
      var empDetails = {
        name: "John", age: 25, expertise: "Software Developer"
      }
      ```

      </span>

     یه کپی عمیق با استفاده از خواص از ابچکت اصلی در متغیر جدید ایجاد کنین

      <span dir="ltr" align="left">

      ```javascript
      var empDetailsDeepCopy = {
        name: empDetails.name,
        age: empDetails.age,
        expertise: empDetails.expertise
      }
      ```

      </span>

      اگه ‍‍`empDetailsDeepCopy.name` رو تغییر بدین، فقط `empDetailsDeepCopy` و نه `empDetails` رو تحت تأثیر قرار خواهد داد.

     **[فهرست](#فهرست)**

346. ### چطوری می‌تونیم به یه تعداد مشخص از یه رشته کپی کنیم؟

     متد`repeat` برای ساخت و برگردوندن یه رشته جدید استفاده می‌شه که حاوی تعداد مشخصی از کپی‌های رشته‌ای هس که روی آن فراخوانی شده و به هم پیوسته شدن. به یاد داشته باشیم که این روش به مشخصات ECMAScript 2015 اضافه شده است.
      بیاین یه مثال از رشته Hello رو برای تکرار آن 4 بار در نظر بگیریم.

     <span dir="ltr" align="left">

     ```javascript
     'Hello'.repeat(4);  // 'HelloHelloHelloHello'
     ```

     </span>

347. ### چطوری همه stringهای match شده با یه regular-expression رو برگردونیم؟

     متد «matchAll» می‌تواند برای برگردوندن یه تکرارکننده از تمام نتایجی که یه رشته با یه عبارت منظم مطابقت دارن، استفاده شه. برای مثال، مثال زیر آرایه ای از نتایج رشته منطبق رو در برابر یه عبارت منظم برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     let regexp = /Hello(\d?))/g;
     let greeting = 'Hello1Hello2Hello3';

     let greetingList = [...greeting.matchAll(regexp)];

     console.log(greetingList[0]); //Hello1
     console.log(greetingList[1]); //Hello2
     console.log(greetingList[2]); //Hello3
     ```

     </span>

     **[فهرست](#فهرست)**

348. ### چطوری یه رشته رو از اول یا از آخر trim کنیم؟

     روش trim نمونه اولیه رشته برای برش دادن دو طرف یه رشته استفاده می‌شه. اما اگه می‌خواهید به‌خصوص در ابتدا یا انتهای رشته رو برش بدین، می‌تونین از روش‌های «trimStart/trimLeft» و «trimEnd/trimRight» استفاده کنین. بیاین نمونه ای از این روش‌ها رو در پیام تبریک ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     var greeting = '   Hello, Goodmorning!   ';

     console.log(greeting); // "   Hello, Goodmorning!   "
     console.log(greeting.trimStart()); // "Hello, Goodmorning!   "
     console.log(greeting.trimLeft()); // "Hello, Goodmorning!   "

     console.log(greeting.trimEnd()); // "   Hello, Goodmorning!"
     console.log(greeting.trimRight()); // "   Hello, Goodmorning!"
     ```

     </span>

     **[فهرست](#فهرست)**

349. ### خروجی کنسول زیر با عملگر unary چی می‌شه؟

     بیاین دستور کنسول رو با عملگر unary همونطور که در زیر نشون داده شده است، بگیریم.

     <span dir="ltr" align="left">

     ```javascript
     console.log(+ 'Hello');
     ```

     </span>

     خروجی دستور log کنسول بالا NaN رو برمی‌گردونه. از اونجا که عنصر توسط عملگر unary پیشونده و مفسر جاواسکریپت سعی می‌کنه آن عنصر رو به یه نوع عدد تبدیل کنه. از اونجایی که تبدیل با شکست مواجه می‌شه، مقدار عبارت به مقدار NaN منجر می‌شه.

     **[فهرست](#فهرست)**

350. ### آیا جاواسکریپت از mixinها استفاده می‌کنه؟

     **[فهرست](#فهرست)**

351. ### تابع thunk چیه و چیکار می‌کنه؟

     thunk فقط تابعیه که ارزیابی مقدار رو به تاخیر میندازه. هیچ آرگومانی نمی‌گیره، اما هر زمان که thunk رو فراخوانی می‌کنین مقدار رو میده. برای مثال، از اون استفاده می‌شه که الان اجرا نشه، اما زمانی در آینده اجرا می‌شه. بیاین یه مثال همزمان بگیریم،

     <span dir="ltr" align="left">

     ```javascript
     const add = (x,y) => x + y;

     const thunk = () => add(2,3);

     thunk() // 5
     ```

     </span>

     **[فهرست](#فهرست)**

352. ### thunkهای asynchronous چیکار می‌کنن؟

     Thunk‌های ناهمزمان برای ایجاد درخواست‌های شبکه مفید هستن. بیاین نمونه ای از درخواست‌های شبکه رو ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     function fetchData(fn){
       fetch('https://jsonplaceholder.typicode.com/todos/1')
       .then(response => response.json())
       .then(json => fn(json))
     }

     const asyncThunk = function (){
        return fetchData(function getData(data){
           console.log(data)
       })
     }

     asyncThunk()
     ```

     </span>

     تابع "getData" فوراً فراخوانی نمی‌شه و تنها زمانی فراخوانی می‌شه که داده‌ها از نقطه پایانی API در دسترس باشن. تابع setTimeout هم برای ناهمزمان کردن کد ما استفاده می‌شه. بهترین مثال زمان واقعی، کتابخانه مدیریت حالت redux هس که از thunk‌های ناهمزمان برای به تاخیر انداختن اعمال برای ارسال استفاده می‌کنه.

     **[فهرست](#فهرست)**

353. ### خروجی فراخوانی‌های توابع زیر چی می‌شه؟

     **Code snippet:**

     <span dir="ltr" align="left">

     ```javascript
     const circle = {
       radius: 20,
       diameter() {
         return this.radius * 2;
       },
       perimeter: () => 2 * Math.PI * this.radius
     };

     console.log(circle.diameter());
     console.log(circle.perimeter());
     ```

     </span>

     **Output:**

     خروجی 40 و NaN است. به یاد داشته باشیم که قطر یه تابع منظم است، در حالی که مقدار محیط یه تابع فلش است. کلمه کلیدی «this» یه تابع معمولی (یعنی قطر) به محدوده اطراف که یه کلاسه (یعنی شی شکل) اشاره داره. در حالی که این کلمه کلیدی تابع محیطی به محدوده اطراف که یه آبجکت window هس اشاره داره. از اونجایی که هیچ ویژگی شعاع در آبجکت‌های window وجود نداره، یه مقدار تعریف نشده برمی‌گردونه و مضرب مقدار مقدار NaN رو برمی‌گردونه.

     **[فهرست](#فهرست)**

354. ### چطوری همه خطوط جدید رو از یه رشته حذف کرد؟

     ساده ترین روش استفاده از عبارات منظم برای شناسایی و جایگزینی خطوط جدید در رشته است. در این حالت از تابع تعویض به همراه رشته برای جایگزینی استفاده می‌کنیم که در مورد ما یه رشته خالی است.

     <span dir="ltr" align="left">

     ```javascript
     function remove_linebreaks( var message ) {
         return message.replace( /[\r\n]+/gm, "" );
     }
     ```

     </span>

     در عبارت بالا g و m برای پرچم‌های سراسری و چند خطی هستن.

     **[فهرست](#فهرست)**

355. ### تفاوت‌ بین reflow و repaint چیه؟

     *رنگ‌آمیزی مجدد* زمانی اتفاق می‌افتد که تغییراتی ایجاد می‌شه که روی دید یه عنصر تأثیر می‌گذارد، اما روی طرح آن تأثیر نمی‌گذارد. نمونه‌هایی از این موارد شامل طرح کلی، نمایان بودن یا رنگ پس زمینه است. یه *reflow* شامل تغییراتیه که بر طرح بندی بخشی از صفحه (یا کل صفحه) تأثیر میزاره. تغییر اندازه پنجره مرورگر، تغییر فونت، تغییر محتوا (مانند تایپ متن توسط کاربر)، استفاده از روش‌های جاواسکریپت شامل سبک‌های محاسبه‌شده، افزودن یا حذف عناصر از DOM، و تغییر کلاس‌های یه عنصر چند مورد از مواردی هستن که می‌تونن جریان مجدد رو آغاز کنن. جریان مجدد یه عنصر باعث جریان مجدد بعدی همه عناصر فرزند و اجداد و همچنین هر عنصری که به دنبال آن در DOM است می‌شه.

     **[فهرست](#فهرست)**

356. ### اگه قبل از یه آرایه عملگر نفی «!» بزاریم چی می‌شه؟

     نفی یه آرایه با کاراکتر «!»، آرایه رو به یه بولین وادار می‌کنه. از اونجایی که آرایه‌ها صدق در نظر گرفته می شن، پس نفی اون false رو برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     console.log(![]); // false
     ```

     </span>

     **[فهرست](#فهرست)**

357. ### اگه دو تا آرایه رو با هم جمع ببندیم چی می‌شه؟

     اگه دو آرایه رو با هم اضافه کنین هر دو اونا رو به رشته تبدیل می‌کنه و اونا رو به هم متصل می‌کنه. برای بریم یه مثال در موردش ببینیم.

     <span dir="ltr" align="left">

     ```javascript
     console.log(['a'] + ['b']);  // "ab"
     console.log([] + []); // ""
     console.log(![] + []); // "false", because ![] returns false.
     ```

     </span>

     **[فهرست](#فهرست)**

358. ### اگه عملگر جمع «+» روی قبل از مقادیر falsy قرار بدیم چی می‌شه؟

     اگه عملگر additive(+) رو روی مقادیر نادرست (null، undefined، NaN، false، "") قرار بدین، مقدار falsy به مقدار عددی صفر تبدیل می‌شه. بیاین اونا رو در کنسول مرورگر به صورت زیر نمایش بدیم،
     <span dir="ltr" align="left">

     ```javascript
     console.log(+null); // 0
     console.log(+undefined);// NaN
     console.log(+false); // 0
     console.log(+NaN); // NaN
     console.log(+""); // 0
     ```

     </span>

     **[فهرست](#فهرست)**

359. ### چطوری با استفاده از آرایه‌ها و عملگرهای منطقی می‌تونیم رشته self رو تولید کنیم؟

     رشته self رو می‌شه با ترکیب کاراکترهای `[]()!+` تشکیل داد. برای رسیدن به این الگو باید قراردادهای زیر رو به خاطر بسپارید.
     1. از اونجایی که آرایه‌ها مقادیر true هستن، با نفی آرایه‌ها false تولید می‌شه: ![] === false
     2. طبق قوانین اجباری جاواسکریپت، اضافه کردن آرایه‌ها به هم اونا رو به رشته‌بندی تبدیل می‌کنه: [] + [] === ""
     3. Prepend یه آرایه با عملگر + یه آرایه رو به نادرست تبدیل می‌کنه، انکار اونو درست می‌کنه و در نهایت تبدیل نتیجه مقدار '1' رو تولید می‌کنه: +(!(+[])) === 1

      با اعمال قوانین بالا می‌تونیم شرایط زیر رو استخراج کنیم

     <span dir="ltr" align="left">

     ```javascript
     ![] + [] === "false"
     +!+[] === 1
     ```

     </span>

     اکنون الگوی کاراکتر به صورت زیر ایجاد می‌شه.

     <span dir="ltr" align="left">

     ```javascript
           s               e               l               f
      ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^

      (![] + [])[3] + (![] + [])[4] + (![] + [])[2] + (![] + [])[0]
      ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^
     (![] + [])[+!+[]+!+[]+!+[]] +
     (![] + [])[+!+[]+!+[]+!+[]+!+[]] +
     (![] + [])[+!+[]+!+[]] +
     (![] + [])[+[]]
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     (![]+[])[+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]]+(![]+[])[+[]]
     ```

     </span>

     **[فهرست](#فهرست)**

360. ### چطوری می‌تونیم مقادیر falsy رو از آرایه حذف کنیم؟

     شما می‌تونین با وارد کردن Boolean به عنوان پارامتر، روش فیلتر رو روی آرایه اعمال کنین. به این ترتیب تمام مقادیر نادرست (0، تعریف نشده، null، false و "") از آرایه حذف می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     const myArray = [false, null, 1,5, undefined]
     myArray.filter(Boolean); // [1, 5] // is same as myArray.filter(x => x);
     ```

     </span>

     **[فهرست](#فهرست)**

361. ### چطوری مقادیر تکراری رو از یه آرایه حذف کنیم؟

     شما می‌تونین مقادیر منحصر به فرد یه آرایه رو با ترکیب دستور "Set" و rest expression/spread(...) دریافت کنین.

     <span dir="ltr" align="left">

     ```javascript
     console.log([...new Set([1, 2, 4, 4, 3])]); // [1, 2, 4, 3]
     ```

     </span>

     **[فهرست](#فهرست)**

362. ### aliaseهای همزمان با destructuring چطوری کار می‌کنن؟

     گاهی اوقات شما دوست دارید یه متغیر تخریب شده با نامی متفاوت از نام ویژگی داشته باشیم. در این صورت، از یه «: newName» برای تعیین نام برای متغیر استفاده خواهید کرد. این فرآیند نام مستعار تخریب ساختاری نامیده می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     const obj = { x: 1 };
     // Grabs obj.x as as { otherName }
     const { x: otherName } = obj;
     ```

     </span>

     **[فهرست](#فهرست)**

363. ### چطوری آیتم‌های یه آرایه رو بدون استفاده از متد map پیمایش کنیم؟

     می‌تونین مقادیر آرایه‌ها رو بدون استفاده از روش «نقشه» تنها با استفاده از روش «از» آرایه ترسیم کنین. بیاین نام شهرها رو از آرایه کشورها ترسیم کنیم،

     <span dir="ltr" align="left">

     ```javascript
     const countries = [
         { name: 'India', capital: 'Delhi' },
         { name: 'US', capital: 'Washington' },
         { name: 'Russia', capital: 'Moscow' },
         { name: 'Singapore', capital: 'Singapore' },
         { name: 'China', capital: 'Beijing' },
         { name: 'France', capital: 'Paris' },
     ];

     const cityNames = Array.from(countries, ({ capital}) => capital);
     console.log(cityNames); // ['Delhi, 'Washington', 'Moscow', 'Singapore', 'Beijing', 'Paris']
     ```

     </span>

     **[فهرست](#فهرست)**

364. ### چطوری یه آرایه رو خالی کنیم؟

     با صفر کردن طول آرایه می‌تونین به سرعت یه آرایه رو خالی کنین.

     <span dir="ltr" align="left">

     ```javascript
     let cities = ['Singapore', 'Delhi', 'London'];
     cities.length = 0; // cities becomes []
     ```

     </span>

     **[فهرست](#فهرست)**

365. ### چطوری اعداد رو با تعداد رقم اعشار مشخص رند می‌کنی؟

     می‌تونین با استفاده از روش «toFixed» از جاواسکریپت، اعداد رو به تعداد معینی از اعشار گرد کنین.

     <span dir="ltr" align="left">

     ```javascript
     let pie = 3.141592653;
     pie = pie.toFixed(3); // 3.142
     ```

     </span>

     **[فهرست](#فهرست)**

366. ### ساده‌ترین روش برای تبدیل آرایه به object چیه؟

     شما می‌تونین با استفاده از عملگر spread(...) یه آرایه رو به یه شی با همون داده تبدیل کنین.

     <span dir="ltr" align="left">

     ```javascript
     var fruits = ["banana", "apple", "orange", "watermelon"];
     var fruitsObject = {...fruits};
     console.log(fruitsObject); // {0: "banana", 1: "apple", 2: "orange", 3: "watermelon"}
     ```

     </span>

     **[فهرست](#فهرست)**

367. ### چطوری یه آرایه با یه سری داده درست کنیم؟

     می‌تونین با استفاده از روش «fill» یه آرایه با مقداری داده یا یه آرایه با همون مقادیر ایجاد کنین.

     <span dir="ltr" align="left">

     ```javascript
     var newArray = new Array(5).fill("0");
     console.log(newArray); // ["0", "0", "0", "0", "0"]
     ```

     </span>

     **[فهرست](#فهرست)**

368. ### متغیرهای موجود روی آبجکت console کدوما هستن؟

     1. %o - یه شی رو می‌گیرد،
     2. %s - یه رشته می‌گیره،
     3. %d - برای اعشار یا عدد صحیح استفاده می‌شه
      این متغیرها رو می‌شه در console.log به صورت زیر نشون داد

     <span dir="ltr" align="left">

     ```javascript
     const user = { "name":"John", "id": 1, "city": "Delhi"};
     console.log("Hello %s, your details %o are available in the object form", "John", user); // Hello John, your details {name: "John", id: 1, city: "Delhi"} are available in object
     ```

     </span>

     **[فهرست](#فهرست)**

369. ### می‌شه پیام‌های کنسول رو استایل‌دهی کرد؟

     بله، می‌تونین سبک‌های CSS رو برای پیام‌های کنسول مشابه متن html در صفحه وب اعمال کنین.

     <span dir="ltr" align="left">

     ```javascript
     console.log('%c The text has blue color, with large font and red background', 'color: blue; font-size: x-large; background: red');
     ```

     </span>

     متن به صورت زیر نمایش داده می‌شه
     ![Screenshot](images/console-css.png)

     **نکته:** تمام سبک‌های CSS رو می‌شه برای پیام‌های کنسول اعمال کرد.

     **[فهرست](#فهرست)**

370. ### هدف از متد dir روی آبجکت console چیه؟

     «console.dir» برای نمایش یه لیست تعاملی از ویژگی‌های شی جاواسکریپت مشخص شده به عنوان JSON استفاده می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     const user = { "name":"John", "id": 1, "city": "Delhi"};
     console.dir(user);
     ```

     </span>

     شی کاربر نمایش داده شده در نمایش JSON
     ![Screenshot](images/console-dir.png)

     **[فهرست](#فهرست)**

371. ### آیا می‌شه المنت‌های HTML رو توی console دیباگ کرد؟

     بله، دریافت و اشکال زدایی عناصر HTML در کنسول، درست مانند بازرسی عناصر، امکان پذیر است.

     <span dir="ltr" align="left">

     ```javascript
     const element = document.getElementsByTagName("body")[0];
     console.log(element);
     ```

     </span>

     این عنصر HTML رو در کنسول چاپ می‌کنه،

     ![Screenshot](images/console-html.png)

     **[فهرست](#فهرست)**

372. ### چطوری می‌شه داده‌ها رو به شکل جدولی توی console نمایش بدیم؟

     «console.table» برای نمایش داده‌ها در کنسول در قالب جدولی برای تجسم آرایه‌ها یا اشیاء پیچیده استفاده می‌شه.

     <span dir="ltr" align="left">

     ```js
     const users = [{ "name":"John", "id": 1, "city": "Delhi"}, { "name":"Max", "id": 2, "city": "London"}, { "name":"Rod", "id": 3, "city": "Paris"} ];
     console.table(users);
     ```

     </span>

     داده‌هایی که در قالب جدول مشاهده می‌شن،

     ![Screenshot](images/console-table.png)

     **نکته:** یادتون باشه `console.table` توی مرورگر IE پشتیبانی نمی‌شه :-/

     **[فهرست](#فهرست)**

373. ### چطوری می‌شه بررسی کرد که یه پارامتر Number هست یا نه؟

     ترکیبی از روش‌های IsNaN و isFinite برای تأیید عدد بودن یا نبودن آرگومان استفاده می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     function isNumber(n){
         return !isNaN(parseFloat(n)) && isFinite(n);
     }
     ```

     </span>

     **[فهرست](#فهرست)**

374. ### چطوری یه متن رو می‌تونیم به clipboard کپی کنیم؟

     شما باید محتوا (با استفاده از روش .select) عنصر ورودی رو انتخاب کنین و دستور copy رو با execCommand اجرا کنین (یعنی execCommand('copy')). شما همچنین می‌تونین سایر دستورات سیستم مانند cut و paste رو اجرا کنین.

     <span dir="ltr" align="left">

     ```javascript
     document.querySelector("#copy-button").onclick = function() {
       // Select the content
       document.querySelector("#copy-input").select();
       // Copy to the clipboard
       document.execCommand('copy');
     };
     ```

     </span>

     **[فهرست](#فهرست)**

375. ### چطوری می‌شه timestamp رو بدست آورد؟

     می‌تونین از «Date.getTime» برای دریافت مهر زمانی فعلی استفاده کنین. یه میانبر جایگزین برای دریافت مقدار وجود داره.

     <span dir="ltr" align="left">

     ```javascript
     console.log(+new Date());
     console.log(Date.now());
     ```

     </span>

     **[فهرست](#فهرست)**

376. ### چطوری یه آرایه چندسطحی رو تک سطحی کنیم؟

     مسطح کردن آرایه‌های دو بعدی با عملگر Spread بی اهمیت است.

     <span dir="ltr" align="left">

     ```javascript
     const biDimensionalArr = [11, [22, 33], [44, 55], [66, 77], 88, 99];
     const flattenArr = [].concat(...biDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
     ```

     </span>

     اما شما می‌تونین اونو با آرایه‌های چند بعدی با تماس‌های بازگشتی کار کنین

     <span dir="ltr" align="left">

     ```javascript
     function flattenMultiArray(arr) {
         const flattened = [].concat(...arr);
         return flattened.some(item => Array.isArray(item)) ? flattenMultiArray(flattened) : flattened;
      }
     const multiDimensionalArr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];
     const flatArr = flattenMultiArray(multiDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
     ```

     </span>

     **[فهرست](#فهرست)**

377. ### ساده‌ترین روش برای بررسی چندشرطی چیه؟

     می‌تونین از «indexOf» برای مقایسه ورودی با چندین مقدار به جای بررسی هر مقدار به عنوان یه شرط استفاده کنین.

     <span dir="ltr" align="left">

     ```javascript
     // Verbose approach
     if (input === 'first' || input === 1 || input === 'second' || input === 2) {
       someFunction();
     }
     // Shortcut
     if (['first', 1, 'second', 2].indexOf(input) !== -1) {
       someFunction();
     }
     ```

     </span>

     **[فهرست](#فهرست)**

378. ### چطوری کلیک روی دکمه برگشت مرورگر رو متوجه بشیم؟

     روش «window.onbeforeunload» برای ضبط رویدادهای دکمه بازگشت مرورگر استفاده می‌شه. این برای هشدار دادن به کاربران در مورد از دست دادن داده‌های فعلی مفید است.

     <span dir="ltr" align="left">

     ```javascript
      window.onbeforeunload = function() {
         alert("You work will be lost");
      };
     ```

     </span>

     **[فهرست](#فهرست)**

379. ### چطوری می‌تونیم کلیک راست رو غیرفعال کنیم؟

     کلیک راست روی صفحه رو می‌شه با برگردوندن false از ویژگی «oncontextmenu» در عنصر بدنه غیرفعال کرد.

     <span dir="ltr" align="left">

     ```html
     <body oncontextmenu="return false;">
     ```

     </span>

     **[فهرست](#فهرست)**

380. ### object-wrapperها چی هستن؟

     مقادیر اولیه مانند رشته، عدد و بولین خواص و روشی ندارن، اما زمانی که می‌خواهید اقداماتی رو روی اونا انجام بدین، به طور موقت به یه شی (آبجکت Wrapper) تبدیل یا مجبور می‌شن. برای مثال، اگه متد UpperCase رو روی یه مقدار رشته اولیه اعمال کنین خطایی ایجاد نمی‌کنه، اما حروف بزرگ رشته رو برمی‌گردونه.

     <span dir="ltr" align="left">

     ```javascript
     let name = "john";

     console.log(name.toUpperCase());  // Behind the scenes treated as console.log(new String(name).toUpperCase());
     ```

     </span>

     یعنی هر اولیه به جز null و undefined دارای Wrapper Object هس و لیست اشیاء wrapper عبارتند از String، Number، Boolean، Symbol و BigInt.

     **[فهرست](#فهرست)**

381. ### AJAX چیه؟

     AJAX مخفف Asynchronous JavaScript و XML هس و گروهی از فناوری‌های مرتبط (HTML، CSS، JavaScript، XMLHttpRequest API و غیره) که برای نمایش داده‌ها به صورت ناهمزمان استفاده می‌شه. یعنی ما می‌تونیم داده‌ها رو به سرور ارسال کنیم و بدون بارگیری مجدد صفحه وب، داده‌ها رو از سرور دریافت کنیم.

     **[فهرست](#فهرست)**

382. ### روش‌های مختلف مدیریت یه کد Asynchronous چیه؟

     1. callback‌ها
     2. پرامیس‌ها
     3. Async/await
     4. کتابخانه‌های شخص ثالث مانند async.js، bluebird و غیره

     **[فهرست](#فهرست)**

383. ### چطوری یه درخواست fetch رو کنسل کنیم؟

     تا چند روز پیش، یکی از کاستی‌های وعده‌های بومی راه مستقیمی برای لغو درخواست fetch نیست. اما «AbortController» جدید از مشخصات js به شما امکان میده از سیگنالی برای لغو یه یا چند تماس fetch استفاده کنین.
      جریان اصلی لغو یه درخواست fetch اینجوری می‌شه.
     1. یه نمونه «AbortController» ایجاد کنین
     2. ویژگی سیگنال یه نمونه رو دریافت کنین و سیگنال رو به عنوان یه گزینه fetch برای سیگنال ارسال کنین
     3. برای لغو تمام fetch‌هایی که از اون سیگنال استفاده میکنن با ویژگی abort's AbortController رو کال کنید.
      برای مثال، بیاین یه سیگنال رو به چندین تماس fetch ارسال کنیم، همه درخواست‌های با آن سیگنال لغو میشن.

     <span dir="ltr" align="left">

     ```javascript
     const controller = new AbortController();
     const { signal } = controller;

     fetch("http://localhost:8000", { signal }).then(response => {
         console.log(`Request 1 is complete!`);
     }).catch(e => {
         if(e.name === "AbortError") {
             // We know it's been canceled!
         }
     });

     fetch("http://localhost:8000", { signal }).then(response => {
         console.log(`Request 2 is complete!`);
     }).catch(e => {
          if(e.name === "AbortError") {
              // We know it's been canceled!
           }
     });

     // Wait 2 seconds to abort both requests
     setTimeout(() => controller.abort(), 2000);
     ```

     </span>

     **[فهرست](#فهرست)**

384. ### Speech-API چیه؟

     API گفتار وب برای فعال کردن مرورگرهای مدرن برای شناسایی و ترکیب گفتار (یعنی داده‌های صوتی در برنامه‌های وب) استفاده می‌شه. این API توسط انجمن W3C در سال 2012 معرفی شد و دارای دو بخش اصلیه.
     1. **تشخیص گفتار (تشخیص گفتار ناهمزمان یا گفتار به متن):** این امکان رو فراهم می‌کنه که زمینه صدا رو از ورودی صوتی تشخیص داده و به اون پاسخ بدین. این توسط رابط "SpeechRecognition" قابل دسترسیه.
      مثال زیر نحوه استفاده از این API برای دریافت متن از گفتار رو نشون میده.

     <span dir="ltr" align="left">

     ```javascript
     window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;  // webkitSpeechRecognition for Chrome and SpeechRecognition for FF
     const recognition = new window.SpeechRecognition();
     recognition.onresult = (event) => { // SpeechRecognitionEvent type
       const speechToText = event.results[0][0].transcript;
       console.log(speechToText);
     }
     recognition.start();
     ```

     </span>

     در این API، مرورگر برای استفاده از میکروفون شما از شما اجازه می خواهد
     2. **SpeechSynthesis (Text-to-Speech):** این امکان رو فراهم می‌کنه تا زمینه صدا رو از ورودی صوتی تشخیص داده و پاسخ بده. این توسط رابط "SpeechSynthesis" قابل دسترسیه.
      برای مثال، کد زیر برای دریافت صدا/گفتار از متن استفاده می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     if('speechSynthesis' in window){
         var speech = new SpeechSynthesisUtterance('Hello World!');
         speech.lang = 'en-US';
         window.speechSynthesis.speak(speech);
     }
     ```

     </span>

     نمونه‌های بالا رو می‌شه روی کنسول برنامه‌نویس مرورگر کروم (33+) آزمایش کرد.
      **توجه:** این API هنوز یه پیش نویس فعاله و فقط در مرورگرهای کروم و فایرفاکس وجود داره (البته کروم فقط مشخصات رو اجرا می‌کنه)
     
     **[فهرست](#فهرست)**

385. ### حداقل timeout توی throttling چقدره؟

     هم مرورگر و هم محیط‌های جاواسکریپت NodeJS با حداقل تاخیری که بیشتر از 0 میلی ثانیه اس throttles رو انجام می دهند. این بدان معناست که حتی اگه تنظیم یه تاخیر 0ms به طور آنی اتفاق نیوفته.
      **مرورگرها:** حداقل 4 میلی ثانیه تاخیر دارن. این throttles زمانی اتفاق میوفته که تماس‌های متوالی به دلیل تودرتوی Callback (عمق معین) یا پس از تعداد معینی فواصل متوالی آغاز شه.
      توجه: مرورگرهای قدیمی حداقل 10 میلی ثانیه تاخیر دارن.
      **Nodejs:** حداقل 1ms تاخیر دارن. این throttles زمانی اتفاق میوفته که تاخیر بزرگتر از 2147483647 یا کمتر از 1 باشه.
      بهترین مثال برای توضیح این رفتار throttling وقفه، ترتیب قطعه کد.

     <span dir="ltr" align="left">

     ```javascript
     function runMeFirst() {
         console.log('My script is initialized');
     }
     setTimeout(runMeFirst, 0);
     console.log('Script loaded');
     ```

     </span>

     و خروجی

     <span dir="ltr" align="left">

     ```cmd
     Script loaded
     My script is initialized
     ```

     </span>

     اگه از «setTimeout» استفاده نمی‌کنین ترتیب گزارش‌ها این شکلی می‌شه.

     <span dir="ltr" align="left">

     ```javascript
     function runMeFirst() {
        console.log('My script is initialized');
     }
     runMeFirst();
     console.log('Script loaded');
     ```

     </span>

     و خروجی

     <span dir="ltr" align="left">

     ```cmd
     My script is initialized
     Script loaded
     ```

     </span>

     **[فهرست](#فهرست)**

386. ### چطوری می‌شه یه timeout صفر توی مرورگر اجرا کرد؟

     به دلیل حداقل تاخیر بیش از 0 میلی ثانیه، نمی‌تونین از setTimeout(fn, 0) برای اجرای فوری کد استفاده کنین. اما برای دستیابی به این رفتار می‌تونین از window.postMessage() استفاده کنین.

     **[فهرست](#فهرست)**

387. ### taskها توی event-loop چی هستن؟

     وظیفه هر کد/برنامه جاواسکریپتیه که قراره توسط مکانیسم‌های استانداره اجرا شه، مثل شروع اولیه اجرای یه برنامه، اجرای یه رویداد، callback یا یه بازه زمانی یا وقفه در حال اجرا. همه این وظایف تو یه صف کار برنامه ریزی میشن
      در زیر لیستی از موارد استفاده برای افزودن وظایف به صف کار اوردیم.
     1. موقعی که یه برنامه جاواسکریپت جدید مستقیماً از کنسول اجرا می‌شه یا توسط عنصر ```<script>``` اجرا می‌شه، وظیفه به صف کار اضافه می‌شه.
     2. موقعی که یه رویداد شلیک می‌شه، پاسخ تماس رویداد به صف کار اضافه می‌شه
     3. وقتی به یه setTimeout یا setInterval رسید، پاسخ تماس مربوطه به صف کار اضافه می‌شه

     **[فهرست](#فهرست)**

388. ### microtaskها چی هستن؟

     Microtask کد جاواسکریپت‌ـه که باید بلافاصله پس از تکمیل task/Microtask در حال اجرا اجرا شه. اونا در طبیعت به نوعی مسدود کننده هستن. یعنی تا زمانی که صف microtask خالی نشه، رشته اصلی مسدود می‌شه.
      منابع اصلی Microtaskها عبارتند از Promise.resolve، Promise.reject، MutationObservers، IntersectionObservers و غیره.

      **توجه:** همه این Microtaskها در همون چرخش event-loop پردازش میشن
     
     **[فهرست](#فهرست)**

389. ### event-loopهای مختلف کدوما هستن؟

     MainAppLoop - این حلقه اصلی یه برنامه اس. به طور معمول این در پایین صفحه اصلیه. خروج معمولاً نشان دهنده تمایل به بسته شدن برنامه اس. در هر برنامه فقط یکی از این موارد می‌تونه وجود داشته باشد. ThreadLoop - این حلقه ایه که معمولاً در پایین رویه اصلی یه UI Thread یافت می‌شه.

     **[فهرست](#فهرست)**

390. ### هدف از queueMicrotask چیه؟

     این به کد شما اجازه میده بدون تداخل با کد دیگه با اولویت بالاتری که در حالت تعلیقه اجرا بشه اما قبل از اینکه مرورگر کنترل روی زمینه اجرا رو دوباره به دست آورد، بسته به کاری که باید تکمیل کنین.

     **[فهرست](#فهرست)**

391. ### چطوری می‌شه از کتابخونه‌های جاواسکریپت توی فایل typescript استفاده کرد؟

     مشخصه که همه‌ی کتابخونه‌ها یا چارچوب‌های جاواسکریپت دارای فایل‌های اعلان TypeScript نیستن. اما اگه هنوزم می‌خواین از کتابخانه‌ها یا فریم‌ورک‌ها در فایل‌های TypeScript بدون دریافت خطاهای کامپایل استفاده کنین تنها راه‌حل کلمه کلیدی `declare به همراه یه اعلان متغیره. برای مثال، بیاین تصور کنیم که شما یه کتابخونه‌ به نام "customLibrary" دارید که اعلان TypeScript نداره و فضای نامی به نام "customLibrary" در فضای نام گلوبال داره. می‌تونین از این کتابخانه در کد تایپ اسکریپت به صورت زیر استفاده کنین.

     <span dir="ltr" align="left">

     ```javascript
     declare var customLibrary;
     ```

     </span>

     در زمان اجرا، تایپ اسکریپت نوع اونو به متغیر «کتابخانه سفارشی» به صورت «هرگونه» ارائه می‌کنه. جایگزین دیگه بدون استفاده از کلمه کلیدی declare رو تو مثال زیر ببینیم

     <span dir="ltr" align="left">

     ```javascript
     var customLibrary: any;
     ```

     </span>

     **[فهرست](#فهرست)**

392. ### تفاوت‌های بین promiseها و observableها کدوما هستن؟


      | promise‌ها | observableها |
      |---- | --------- |
      | فقط یه مقدار رو تو یه زمان منتشر می‌کنه | چندین مقدار رو تو یه دوره زمانی منتشر می‌کنه (جریان مقادیری از 0 تا چندگانه) |
      | قراره فوراً فراخوانی شن | اونا برای فراخوانی نیاز به اشتراک دارن |
      | Promise همی‌شه ناهمزمانه حتی اگه بلافاصله حل شه | observableها میتونن همزمان یا ناهمزمان|
      | هیچ اپراتور ارائه نمیده | اپراتورهایی مانند map، forEach، filter، reduce، retry و retryWhen و غیره رو ارائه میده.
      | قابل لغو نیست | با استفاده از روش unsubscribe لغو میشن

     **[فهرست](#فهرست)**

393. ### heap چیه؟

     Heap (یا پشته حافظه) محلیه که تو اون آبجکت‌ها در موقع تعریف متغیرها ذخیره میشن یعنی این محلیه که تمام تخصیص حافظه و عدم تخصیص تو اون انجام می‌شه. هر دو heap و call-stack دو ظرف زمان اجرا JS هستن.
      هر زمان که زمان اجرا با متغیرها و اعلان‌های تابع در کد مواجه می‌شه، اونا رو در Heap ذخیره می‌کنه.

     ![Screenshot](images/heap.png)

     **[فهرست](#فهرست)**

394. ### event-table چیه؟

     Event Table یه ساختار داده‌ای‌ـه که تمام رویدادهایی رو که به صورت ناهمزمان اجرا می‌شن، مانند پس از مدتی فاصله زمانی یا پس از رفع بعضی از درخواست‌های API، ذخیره و ردیابی می‌کنه. یعنی هر زمان که یه تابع setTimeout رو فراخوانی کنین یا عملیات async رو فراخوانی کنین به جدول رویداد اضافه می‌شه.
      توابع رو به تنهایی اجرا نمی‌کنه. هدف اصلی جدول رویدادها پیگیری رویدادها و ارسال اونا به صف رویداد همونطور که در نمودار زیر نشون داده شده.

     ![Screenshot](images/event-table.png)

     **[فهرست](#فهرست)**

395. ### صف microTask چیه؟

     Microtask Queue صف جدیدیه که تو اون تمام وظایف آغاز شده توسط اشیاء promise قبل از صف برگشت پردازش میشن
      صف microtasks قبل از کارهای رندر و نقاشی بعدی پردازش می‌شه. اما اگه این ریزکارها برای مدت طولانی اجرا شن، منجر به تخریب بصری میشن.

     **[فهرست](#فهرست)**

396. ### تفاوت بین shim و polyfill چیه؟

     shim کتابخونه ایه که یه API جدید رو با استفاده از ابزارهای آن محیط به یه محیط قدیمی تر میاره. لزوماً محدود به یه برنامه وب نیست. برای مثال، es5-shim.js برای شبیه سازی ویژگی‌های ES5 در مرورگرهای قدیمی (عمدتا قبل از IE9) استفاده می‌شه.
      در حالی که polyfill یه قطعه کد (یا افزونه) اس که فناوری رو ارائه می‌کنه که شما، توسعه‌دهنده، از مرورگر انتظار دارید که به صورت بومی ارائه کنه.
      تو یه جمله ساده، A polyfill یه shim برای API مرورگره.

     **[فهرست](#فهرست)**

397. ### چطوری متوجه primitive یا غیر primitive بودن یه نوع داده میشیم؟

     در جاواسکریپت، انواع ابتدایی عبارتند از boolean، string، number، BigInt، null، Symbol و undefined. در حالی که انواع غیر ابتدایی شامل Object‌ها می‌شه. اما با تابع زیر می‌تونین به راحتی اونا رو شناسایی کنین

     <span dir="ltr" align="left">

     ```javascript
     var myPrimitive = 30;
     var myNonPrimitive = {};
     function isPrimitive(val) {
         return Object(val) !== val;
     }

     isPrimitive(myPrimitive);
     isPrimitive(myNonPrimitive);
     ```

     </span>

     اگه مقدار یه نوع داده اولیه باشه، سازنده Object یه آبجکت پوشاننده جدید برای مقدار ایجاد می‌کنه. اما اگه مقدار یه نوع داده غیر ابتدایی (یک آبجکت) باشه، سازنده Object همون آبجکت رو میده.

     **[فهرست](#فهرست)**

398. ### babel چیه؟

     Babel یه ترانسپایلر جاواسکریپت برای تبدیل کد ECMAScript 2015+ به یه نسخه سازگار جاواسکریپت در مرورگرها یا محیط‌های فعلی و قدیمی تر است. بعضی از ویژگی‌های اصلی در زیر ذکر شده است،
     1. تبدیل نحو
     2. ویژگی‌های Polyfill که در محیط هدف شما وجود نداره (با استفاده از @babel/polyfill)
     3. تبدیل کد منبع (یا کد مد)


     **[فهرست](#فهرست)**

399. ### آیا Node.js به شکل کامل تک thread کار می‌کنه؟

     Node یه رشته است، اما بعضی از توابع موجود در کتابخانه استانداره Node.js (برای مثال، توابع ماژول fs) تک رشته‌ای نیستن. یعنی منطق اونا خارج از رشته Node.js اجرا می‌شه تا سرعت و عملکرد یه برنامه رو بهبود بخشد.

     **[فهرست](#فهرست)**

400. ### کاربردهای مرسوم observableها کدوما هستن؟

     بعضی از رایج‌ترین موارد استفاده از موارد مشاهده‌شده عبارتند از سوکت‌های وب با اعلان‌های فشار، تغییرات ورودی کاربر، فواصل تکراری و غیره.

     **[فهرست](#فهرست)**

401. ### RxJS چیه؟

     RxJS (افزونه‌های واکنش‌گرا برای جاواسکریپت) کتابخانه‌ای برای پیاده‌سازی برنامه‌نویسی واکنش‌گرا با استفاده از مشاهده‌پذیره که نوشتن کد ناهمزمان یا مبتنی بر تماس رو آسان‌تر می‌کنه. همچنین توابع کاربردی رو برای ایجاد و کار با مشاهده پذیرها فراهم می‌کنه.

     **[فهرست](#فهرست)**

402. ### تفاوت بین Function-constructor و function-declaration چیه؟

     توابعی که با "سازنده تابع" ایجاد می‌شن، برای زمینه‌های ایجاد خود بسته ایجاد نمی‌کنن، اما همی‌شه در محدوده جهانی ایجاد میشن یعنی تابع فقط میتونه به متغیرهای محلی خود و متغیرهای دامنه جهانی دسترسی داشته باشه. در حالی که اعلان‌های تابع میتونن به متغیرهای تابع بیرونی (بسته شدن) هم دسترسی داشته باشن.

      بیاین این تفاوت رو با یه مثال ببینیم،

     **Function Constructor:**

     <span dir="ltr" align="left">

     ```javascript
     var a = 100;
     function createFunction() {
         var a = 200;
         return new Function('return a;');
     }
     console.log(createFunction()()); // 100
     ```

     </span>

     **Function declaration:**

     <span dir="ltr" align="left">

     ```javascript
     var a = 100;
     function createFunction() {
         var a = 200;
         return function func() {
             return a;
         }
     }
     console.log(createFunction()()); // 200
     ```

     </span>

     **[فهرست](#فهرست)**

403. ### شرط Short-circuit یا اتصال کوتاه چیه؟

     شرایط اتصال کوتاه برای روش فشرده نوشتن دستورات if ساده در نظر گرفته شده است. بیاین سناریو رو با استفاده از یه مثال نشون بدیم. اگه می‌خواین وارد پورتالی با شرایط احراز هویت شوید، عبارت زیر خواهد بود:

     <span dir="ltr" align="left">

     ```javascript
     if (authenticate) {
        loginToPorta();
     }
     ```

     </span>

     از اونجایی که عملگرهای منطقی جاواسکریپت از چپ به راست ارزیابی می شن عبارت بالا رو می‌شه با استفاده از عملگر منطقی && ساده کرد.

     <span dir="ltr" align="left">

     ```javascript
     authenticate && loginToPorta();
     ```

     </span>

     **[فهرست](#فهرست)**

404. ### ساده‌ترین روش برای تغییر سایز یه آرایه چیه؟

     ویژگی length یه آرایه برای تغییر اندازه یا خالی کردن سریع آرایه اس. بیاین ویژگی length رو روی آرایه اعداد اعمال کنیم تا تعداد عناصر رو از 5 به 2 تغییر بدیم.

     <span dir="ltr" align="left">

     ```javascript
     var array = [1, 2, 3, 4, 5];
     console.log(array.length); // 5

     array.length = 2;
     console.log(array.length); // 2
     console.log(array); // [1,2]
     ```

     </span>

     و آرایه رو هم می‌شه خالی کرد

     <span dir="ltr" align="left">

     ```javascript
     var array = [1, 2, 3, 4, 5];
     array.length = 0;
     console.log(array.length); // 0
     console.log(array); // []
     ```

     </span>

     **[فهرست](#فهرست)**

405. ### observable چیه؟

     Observable اساساً تابعیه که میتونه جریانی از مقادیر رو به صورت همزمان یا ناهمزمان به یه ناظر در طول زمان برگردونه. مصرف کننده میتونه با فراخوانی متد «subscribe» مقدار رو دریافت کنه.
      بیاین به یه مثال ساده از یه Observable نگاه کنیم

     <span dir="ltr" align="left">

     ```javascript
     import { Observable } from 'rxjs';

     const observable = new Observable(observer => {
       setTimeout(() => {
         observer.next('Message from a Observable!');
       }, 3000);
     });

     observable.subscribe(value => console.log(value));
     ```

     </span>

     ![Screenshot](images/observables.png)

     **توجه:** Observableها هنوز بخشی از زبان جاواسکریپت نیستن اما پیشنهاد شده که به زبان اضافه بشن.

     **[فهرست](#فهرست)**

406. ### تفاوت‌های بین توابع و کلاس‌ها چیه؟

     تفاوت اصلی بین اعلان‌های تابع و اعلان‌های کلاس "بالا بردن" هس. اعلان‌های تابع بالا می رن اما اعلان‌های کلاس نه.

     **Classes:**

     <span dir="ltr" align="left">

     ```javascript
     const user = new User(); // ReferenceError

     class User {}
     ```

     </span>

     **Constructor Function:**

     <span dir="ltr" align="left">

     ```javascript
      const user = new User(); // No error

      function User() {
      }
     ```

     </span>

     **[فهرست](#فهرست)**

407. ### تابع async چیه؟

     یه تابع async تابعیه که با کلمه کلیدی `async` اعلام شده که با اجتناب از زنجیره پرامیس رفتار ناهمزمان و مبتنی بر قول به سبک تمیزتری نوشته شه. این توابع میتونن شامل صفر یا بیشتر عبارت `await` باشن.

     بیاین یه مثال تابع همگام زیر رو در نظر بگیریم،

     <span dir="ltr" align="left">

     ```javascript
     async function logger() {

       let data = await fetch('http://someapi.com/users'); // pause until fetch returns
       console.log(data)
     }
     logger();
     ```

     </span>

     این اساساً خوبی نحوی بیش از پرامیس‌ها و توابع جنریتور ES2015 هست.

     **[فهرست](#فهرست)**

408. ### چطوری خطاهای ایجاد شده هنگام استفاده از promiseها رو کنترل کنیم؟

     در حین استفاده از کد ناهمزمان، promiseهای ES6 جاواسکریپت میتونن زندگی شما رو بدون داشتن هرم callbackها و مدیریت خطا در هر خط دوم بسیار آسان‌تر کنن. اما Promiseها مشکلاتی دارن و بزرگ‌ترین اونا به‌طور پیش‌فرض بلعیدن خطاهاس.

      فرض کنین انتظار دارید برای تمام موارد زیر یه خطا توی کنسول چاپ کنن.

     <span dir="ltr" align="left">

     ```javascript
      Promise.resolve('promised value').then(function() {
            throw new Error('error');
      });

      Promise.reject('error value').catch(function() {
            throw new Error('error');
      });

      new Promise(function(resolve, reject) {
            throw new Error('error');
      });
     ```

     </span>

     اما بسیاری از محیط‌های جاواسکریپت مدرن وجود دارن که هیچ خطایی رو چاپ نمی‌کنن. شما می‌تونین این مشکل رو به روش‌های مختلف حل کنین

     1. **Add catch block at the end of each chain:** You can add catch block to the end of each of your promise chains


     <span dir="ltr" align="left">

     ```javascript
     Promise.resolve('promised value').th    (function() {
         throw new Error('error');
     }).catch(function(error) {
       console.error(error.stack);
     });
     ```

     </span>

     اما تایپ کردن برای هر زنجیره پرامیس‌ها و پرمخاطب هم خیلی سخته.

     2. **Add done method:** می‌تونین ابتدا راه حل‌ها رو جایگزین کنین و بعد با روش انجام شده بلوک‌ها رو بگیرید

     <span dir="ltr" align="left">

     ```javascript
     Promise.resolve('promised value').don(function() {
         throw new Error('error');
     });
     ```

     </span>

     فرض کنین می‌خواین داده‌ها رو با استفاده از HTTP fetch کنین و بعداً پردازش داده‌های حاصل رو به صورت ناهمزمان انجام بدین. می‌تونین بلوک «انجام شد» رو به صورت زیر بنویسین.

     <span dir="ltr" align="left">

     ```javascript
     getDataFromHttp()
       .then(function(result) {
         return processDataAsync(result);
       })
       .done(function(processed) {
         displayData(processed);
       });
     ```

     </span>

     در آینده، اگه API کتابخانه پردازش به همگام تغییر کنه، می‌تونین بلوک «انجام شد» رو مانند زیر حذف کنین.

     <span dir="ltr" align="left">

      ```javascript
       getDataFromHttp()
         .then(function(result) {
           return displayData(processDataAsyn(result));
        })
     ```
     </span>

      سپس فراموش کردین که بلوک «انجام شد» رو به بلوک then اضافه کنین که منجر به خطاهای خاموش می‌شه.

     3. **Extend ES6 Promises by Bluebird:**

        Bluebird-API میاد Promiseهای اکما اسکریپت رو گسترش میده تا در راه حل دوم مشکلی ایجاد نشه. این کتابخانه یه کنترل کننده "پیش فرض" در Rejection هس که تمام خطاها رو از Promises رد شده به stderr چاپ می‌کنه. پس از نصب، می‌تونین ردهای کنترل نشده رو پردازش کنین

     <span dir="ltr" align="left">

     ```javascript
     Promise.onPossiblyUnhandledRejection(function(error){
          throw error;
     });
     ```

     </span>

     یه reject رو انجام بدین فقط با یه catch خالی اونو مدیریت کنین

     <span dir="ltr" align="left">

     ```javascript
     Promise.reject('error value').catch(function() {});
     ```

     </span>


     **[فهرست](#فهرست)**

409. ### Deno چیه؟

     Deno یه ران تایم(run-time) ساده، مدرن و ایمن برای جاواسکریپت و تایپ اسکریپته که از موتور جاواسکریپت V8 و زبان برنامه نویسی Rust استفاده می‌کنه و توسط رایان دال، خالق نود جی اس استارت توسعه‌اش زده شده.

     **[فهرست](#فهرست)**

410. ### توی جاواسکریپت چطوری یه object قابل پیمایش درست کنیم؟

     به طور پیش فرض، اشیاء ساده قابل تکرار نیستن. اما می‌تونین با تعریف ویژگی «Symbol.iterator» روی اون شی رو قابل تکرار کنین.

     بیاین این رو با یه مثال نشون بدیم،

     <span dir="ltr" align="left">

     ```javascript
     const collection = {
       one: 1,
       two: 2,
       three: 3,
       [Symbol.iterator]() {
         const values = Object.keys(this);
         let i = 0;
         return {
           next: () => {
             return {
               value: this[values[i++]],
               done: i > values.length
             }
           }
         };
       }
     };

     const iterator = collection[Symbol.iterator]();

     console.log(iterator.next());    // → {value: 1, done: false}
     console.log(iterator.next());    // → {value: 2, done: false}
     console.log(iterator.next());    // → {value: 3, done: false}
     console.log(iterator.next());    // → {value: undefined, done: true}
     ```

     </span>


     فرآیند بالا رو می‌شه با استفاده از یه تابع مولد ساده کرد،

     <span dir="ltr" align="left">

     ```javascript
      const collection = {
        one: 1,
        two: 2,
        three: 3,
        [Symbol.iterator]: function * () {
          for (let key in this) {
            yield this[key];
          }
        }
      };
      const iterator = collection[Symbol.iterator]();
      console.log(iterator.next());    // {value: 1, done: false}
      console.log(iterator.next());    // {value: 2, done: false}
      console.log(iterator.next());    // {value: 3, done: false}
      console.log(iterator.next());    // {value: undefined, done: true}
     ```

     </span>


     **[فهرست](#فهرست)**

411. ### روش مناسب برای فراخوانی توابع بازگشتی چیه؟

     ابتدا، قبل از صحبت در مورد "دوم خوانی مناسب" باید در مورد دم دم بدونیم. فراخوانی دنباله یه فراخوانی فرعی یا تابعیه که به عنوان آخرین عمل یه تابع فراخوانی انجام می‌شه. در حالی که**فراخوانی دنباله مناسب (PTC)** تکنیکیه که تو اون برنامه یا کد فریم‌های پشته ای اضافی برای بازگشت ایجاد نمی‌کنه، زمانی که فراخوانی تابع یه فراخوانی دنباله اس.

     برای مثال، بازگشت کلاسیک یا سر تابع فاکتوریل زیر به پشته برای هر مرحله بستگی داره. هر مرحله باید تا "n * فاکتوریل(n - 1)" پردازش شه

     <span dir="ltr" align="left">

     ```javascript
     function factorial(n) {
       if (n === 0) {
         return 1
       }
       return n * factorial(n - 1)
     }
     console.log(factorial(5)); //120
     ```

     </span>

     اما اگه از callbackها Tail استفاده می‌کنین اونا تمام داده‌های لازم رو که به آن نیاز داره رو بدون تکیه بر پشته، در بازگشت به پایین منتقل می‌کنن.

     <span dir="ltr" align="left">

     ```javascript
     function factorial(n, acc = 1) {
       if (n === 0) {
         return acc
       }
       return factorial(n - 1, n * acc)
     }
     console.log(factorial(5)); //120
     ```

     </span>

     الگوی بالا همون خروجی مورد اول رو برمی‌گردونه. اما انباشت کننده کل رو به عنوان آرگومان بدون استفاده از حافظه پشته توی callBack ردیابی می‌کنه.

     **[فهرست](#فهرست)**

412. ### چطوری بررسی کنیم که یه آبجکت promise هست یا نه؟

     اگه نمی‌دونین یه مقدار یه promise هس یا نه، مقدار رو به صورت ‍`Promise.resolve(value)` بپیچید که یه قول رو برمی‌گردونه.

      <span dir="ltr" align="left">

      ```javascript
         function isPromise(object){
            if(Promise && Promise.resolve){
            return Promise.resolve(object) == object;
            }else{
            throw "Promise not supported in your environment"
            }
         }

         var i = 1;
         var promise = new Promise(function(resolve,reject){
            resolve()
         });

         console.log(isPromise(i)); // false
         console.log(isPromise(p)); // true
      ```

      </span>

     راه دیگر اینه که نوع handler.then رو بررسی کنین

      <span dir="ltr" align="left">

      ```javascript
      function isPromise(value) {
         return Boolean(value && typeof value.then === 'function');
      }
      var i = 1;
      var promise = new Promise(function(resolve,reject){
         resolve()
      });

      console.log(isPromise(i)) // false
      console.log(isPromise(promise)); // true
      ```

      </span>

     **[فهرست](#فهرست)**

413. ### چطوری متوجه بشیم که یا تابع با تابع constructor صدا زده شده یا نه؟

     می‌تونین از ویژگی شبه «new.target» برای تشخیص اینکه آیا یه تابع به عنوان سازنده (با استفاده از عملگر جدید) فراخوانی شده یا به عنوان یه فراخوانی تابع معمولی استفاده کنین.

     1. اگه سازنده یا تابعی با استفاده از عملگر جدید فراخوانی شه، new.target یه مرجع به سازنده یا تابع برمی‌گردونه.
     2. برای فراخوانی تابع، new.target تعریف نشده اس.

      <span dir="ltr" align="left">

      ```javascript
      function Myfunc() {
         if (new.target) {
            console.log('called with new');
         } else {
            console.log('not called with new');
         }
      }

      new Myfunc(); // called with new
      Myfunc(); // not called with new
      Myfunc.call({}); not called with new
      ```

      </span>

     **[فهرست](#فهرست)**

414. ### تفاوت‌های بین آبجکت argument و پارامتر rest چیه؟


     1. آبجکت آرگومان‌ها آرایه ماننده اما آرایه نیست. در حالی که بقیه پارامترها نمونه‌های آرایه هستن.
     2. آبجکت آرگومان‌ها از روش‌هایی مانند sort، map، forEach یا pop پشتیبانی نمی‌کنه. در حالی که این روش‌ها رو می‌شه در پارامترهای استراحت استفاده کرد.
     3. بقیه پارامترها فقط اونایی هستن که نام جداگانه ای به اونا داده نشده در حالی که آبجکت آرگومان‌ها شامل تمام آرگومان‌های ارسال شده به تابعه.

     **[فهرست](#فهرست)**

415. ### تفاوت‌های بین عملگر spread و پارامتر rest چیه؟

     پارامتر Rest تمام عناصر باقی مانده رو در یه آرایه جمع آوری می‌کنه. در حالی که عملگر Spread به تکرارپذیرها (آرایه‌ها / اشیاء / رشته‌ها) اجازه میده تا به آرگومان‌ها / عناصر منفرد گسترش  پیدا کنن. یعنی پارامتر Rest مخالف عملگر spread هس.

     **[فهرست](#فهرست)**

416. ### نوع‌های مختلف generatorها کدوما هستن؟


     1. **Generator function declaration:**

       <span dir="ltr" align="left">

       ```javascript
       function* myGenFunc() {
            yield 1;
            yield 2;
            yield 3;
       }
       const genObj = myGenFunc();
       ```

       </span>

     2. **Generator function expressions:**

       <span dir="ltr" align="left">

       ```javascript
       const myGenFunc = function* () {
            yield 1;
            yield 2;
            yield 3;
       };
       const genObj = myGenFunc();
       ```

       </span>

     3. **Generator method definitions in object literals:**

       <span dir="ltr" align="left">

       ```javascript
       const myObj = {
          * myGeneratorMethod() {
             yield 1;
             yield 2;
             yield 3;
          }
       };
       const genObj = myObj.myGeneratorMethod();
       ```

       </span>

     4. **Generator method definitions in class:**

       <span dir="ltr" align="left">

       ```javascript
       class MyClass {
          * myGeneratorMethod() {
             yield 1;
             yield 2;
             yield 3;
          }
       }
       const myObject = new MyClass();
       const genObj = myObject.myGeneratorMethod();
       ```

       </span>

     5. **Generator as a computed property:**

       <span dir="ltr" align="left">

       ```javascript
       const SomeObj = {
          *[Symbol.iterator] () {
            yield 1;
            yield 2;
            yield 3;
          }
       }

       console.log(Array.from(SomeObj)); // [ 1, 2, 3 ]
       ```

       </span>

     **[فهرست](#فهرست)**

417. ### iterableهای built-in کدوما هستن؟


     1. آرایه‌ها و TypedArrays
     2. رشته‌ها: روی هر کاراکتر یا نقاط کد یونیکد تکرار کنین
     3. نقشه‌ها: روی جفت‌های کلید-مقدار آن تکرار شه
     4. مجموعه‌ها: روی عناصر خود تکرار می‌شه
     5. آرگومان‌ها: یه متغیر خاص آرایه مانند در توابع
     6. مجموعه DOM مانند NodeList

     **[فهرست](#فهرست)**

418. ### تفاوت‌های بین حلقه for...of و for...in چیه؟

     هم برای...in و هم برای...از دستورات روی ساختارهای داده js تکرار می‌شن. تنها تفاوت در مورد  چیزیه که اونا تکرار میکننده:

     1. for..in روی تمام کلیدهای خصوصیت شمارش پذیر یه شی تکرار می‌شه
     2. for..of iterates بیش از مقادیر یه شی قابل تکرار.

     بیاین این تفاوت رو توی یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     let arr = ['a', 'b', 'c'];

     arr.newProp = 'newVlue';

     // key are the property keys
     for (let key in arr) {
       console.log(key);
     }

     // value are the property values
     for (let value of arr) {
       console.log(value);
     }
     ```

     </span>

     از اونجا که حلقه for..in روی کلیدهای شی تکرار می‌شه حلقه اول 0، 1، 2 و newProp رو در حین تکرار روی شی آرایه ثبت می‌کنه. حلقه for..of روی مقادیر یه ساختار داده arr تکرار می‌شه و a، b، c رو در کنسول ثبت می‌کنه.

     **[فهرست](#فهرست)**

419. ### چطوری propertyهای instance و غیر instanceای تعریف می‌کنی؟

     خصوصیات Instance باید در داخل متدهای کلاس تعریف بشن. برای مثال، مشخصات نام و سن سازنده داخلی هم مثل مثال پایین تعریف میشن.

     <span dir="ltr" align="left">

     ```javascript
     class Person {
       constructor(name, age) {
         this.name = name;
         this.age = age;
       }
     }
     ```

     </span>

     اما خصوصیات داده Static(class) و نمونه اولیه باید خارج از اعلان ClassBody تعریف بشن. بیاین مقدار سن رو برای کلاس Person به صورت زیر اختصاص بدیم.

     <span dir="ltr" align="left">

     ```javascript
     Person.staticAge = 30;
     Person.prototype.prototypeAge = 40;
     ```

     </span>

     **[فهرست](#فهرست)**

420. ### تفاوت‌های بین isNaN و Number.isNaN کدوما هستن؟

     1. **isNaN**: تابع سراسری «isNaN» آرگومان رو به عدد تبدیل می‌کنه و اگه مقدار حاصل NaN باشه، true رو برمی‌گردونه.

     2. **Number.isNaN**: این روش آرگومان رو تبدیل نمی‌کنه. اما زمانی که نوع یه عدد و مقدار NaN باشه مقدار true رو برمی‌گردونه.

     بیاین تفاوت رو با یه مثال ببینیم،

     <span dir="ltr" align="left">

     ```javascript
     isNaN(‘hello’);   // true
     Number.isNaN('hello'); // false
     ```

     </span>

**[فهرست](#فهرست)**

</div>
